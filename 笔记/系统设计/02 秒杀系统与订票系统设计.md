# 关键词

![](image/Pasted%20image%2020221006170830.png)

# 4S分析法

- 在面试的时候区分你的面试成绩，往往都是你的语言组织能力，和你的思维逻辑能力，即使你的笔试成绩很好，但是你在面试的时候无法组织自己的语言和逻辑，这样面试你的成绩并不会有多好。即使你没有答对，但是你有清晰的思路，没太大问题的，都可以纠正。
- 这个4S分析法，就是分析问题的模版和手段

![](image/Pasted%20image%2020221006171037.png)

## Scenario 场景

- 具体场景有哪些?
- 实际需求有什么? 
- 详细流程怎么样?

### 秒杀系统场景

- 2020年6月18日**0点开始**，京东自营**限量 100 台**，以 4000 元的价格，抢购 iPhone 11 64G 版 本，先到先得，**一人限购一台**，售完即止。
- 微信抢红包
- 抢春运火车票
- 抢购小米手机

### QPS 分析

- 平日每秒 1000 人访问该页面
- 秒杀时每秒数10万人访问该页面
- QPS 增加 100 倍以上

### 商品购买和下单流程

![](image/Pasted%20image%2020221006173033.png)

### 秒杀(seckill system)系统需要解决的问题

#### Large flow and high concurrency

- 瞬时大流量高并发
- 服务器、数据库等能承载的 QPS 有限，如数据库一般是单机 1000 QPS。需要根据业务预估并发量。

#### Over Sale

- 有限库存，不能超卖
- 库存是有限的，需要精准地保证，就是卖掉了 N 个商品。不能超卖，当然也不能少卖了。

#### Malicious ticket Grab

- 黄牛恶意请求
- 使用脚本模拟用户购买，模拟出十几万个请求去抢购。

#### Purchase limit

- 严格限购
- 一个用户，只能购买 1 个或 N 个。

#### 固定时间开启

- 时间到了才能购买，提前一秒都不可以(以商家「京东」「淘宝」的时间为准)。

### 需求拆解

#### 商家侧（京东自营、淘宝天猫店家）

##### 新建秒杀活动

##### 配置秒杀活动

#### 用户侧

##### 商品秒杀页面（前端或客户端）

##### 购买

##### 下单

##### 付款

## Service 服务

- 单体架构 or 微服务？

### 服务结构设计

#### 单体架构(Monolithic)

![](image/Pasted%20image%2020221006174136.png)

- 前后端耦合(Coupling)，服务压力较大。
- 各功能模块耦合严重。
- 系统复杂，一个模块的升级需要导致整个服务都升级。
- 扩展性(Expandability)差，难以针对某个模块单独扩展。
- 开发协作(Cooperation)困难，各个部门的人都在开发同一个代码仓库。
- 级联故障(Cascading Failure)，一个模块的故障导致整个服务不可用。
- 陷入某种单一技术和语言中。
- 数据库崩溃导致整个服务崩溃。

#### 微服务(MicroService)

![](image/Pasted%20image%2020221006175617.png)

- 各功能模块解耦(Decoupling)，保证单一职责(Single Responsibility)。 
- 系统简单，升级某个服务不影响其他服务。
- 扩展性强(Expandability)。可对某个服务进行单独扩容(Expansion)或缩容(Shrink)。
- 各个部门协作(Cooperation)明晰。
- 故障隔离(Isolation)。某个服务出现故障不完全影响其他服务。 
- 可对不同的服务选用更合适的技术架构或语言。 
- 数据库独立，互不干扰。

## Storage 存储

- 数据如何存储与访问
	1. Select 为每个 Service 选择存储结构
	2. Schema 细化表结构

### 数据库表设计

- 都是一些简单的描述
- 对于锁定的简单阐述
	- 创建订单的时候：stock - 1 , lock + 1
	- 付款成功了：lock - 1
	- 付款失败：stock + 1 , lock - 1

![](image/Pasted%20image%2020221006181151.png)

#### 如何添加索引？

- 商品信息表
	- 商品id
- 库存信息表
	- 库存id、商品id、活动id
- 秒杀活动表
	- 秒杀id、商品id
- 订单信息表
	- 订单id

### 数据流

#### 商家侧(京东自营、淘宝天猫店家)

![](image/Pasted%20image%2020221006181808.png)

#### 用户侧

![](image/Pasted%20image%2020221006182000.png)

### 秒杀操作

#### 扣减库存

- 读取判断库存，然后扣减库存

1. 查询库存余量
```sql
SELECT stock FROM `stock_info`  
WHERE commodity_id = 189 AND seckill_id = 28;
```

2. 扣减库存
```sql
UPDATE `stock_info` SET stock = stock - 1 WHERE commodity_id = 189 AND seckill_id = 28;
```

#### 并发导致超卖的问题如何解决

- 假设此时只剩下最后一个库存了，同时有多个请求过来了，第一步都会去查询库存数量，结果都认为自己有库存，都可以买到，到了第二步库存的扣减，就出问题了，此时商品就发生了超卖。

##### 读取和判断过程中加上事务(Database Transaction)

- 具体可以查看[数据库索引和事务](16%20数据库索引和事务.md)
- 但是有个问题，就是事务本身就是一种很耗时的操作，但是秒杀操作更多的是希望提供访问量，这个方式不太推荐

1. 事务开始
```sql
START TRANSACTION;
```

2. 查询库存余量，并锁住数据
```sql
SELECT stock FROM `stock_info`  
WHERE commodity_id = 189 AND seckill_id = 28 FOR UPDATE;
```

3. 扣减库存
```sql
UPDATE `stock_info` SET stock = stock - 1 WHERE commodity_id = 189 AND seckill_id = 28;
```

4. 事务提交

##### 使用 UPDATE 语句自带的行锁(Database row lock)

1. 查询库存余量
```sql
SELECT stock FROM `stock_info`  
WHERE commodity_id = 189 AND seckill_id = 28;
```

2. 扣减库存
```sql
UPDATE `stock_info` SET stock = stock - 1  
WHERE commodity_id = 189 AND seckill_id = 28 AND stock > 0;
```

- 超卖问题解决了，其他问题呢?

1. 大量请求都访问数据库，导致数据库崩溃。  
2. 对于抢购活动来说，可能几十万人抢 100 台 iPhone，实际大部分请求都是无效的，不需要下沉到数据库。

#### 库存预热

- 秒杀的本质，就是对库存的抢夺。 每个秒杀的用户来都去数据库查询库存校验库存，然后扣减库存，导致数据库崩溃。
- 到后面其实都没有库存了，但是还是会有人抢购，这也会导致数据库占用偏高
- MySQL 数据库单点能支撑 1000 QPS，但是 Redis 单点能支撑 10万 QPS，可以考虑将库存信息加载到 Redis 中。 直接通过 Redis 来判断并扣减库存。

##### Redis 介绍

- 一种主要将数据**存储于内存中**的非关系型的键值对数据库 (NoSQL 的一种) ，但也可以将数据持久化 (Data Persistence) 到磁盘中。
- 支持多种数据**非关系型**(Non-relational)的数据结构。 
	1. 字符串/数字 (STRING)
	2. 哈希表 (HASH)
	3. 链表 (LIST)
	4. 集合 (SET)
	5. 有序集合 (ZSET)
- 单线程的数据库。通过IO多路复用实现并发。
- 支持数据的主备容灾 (Disaster Tolerance) 存储。
- 所有单个指令操作都是原子的，即要么完全执行成功，要么完全执行失败。多个指令也可以通过 Lua 脚本事务操作 实现原子性。
- 因为都在内存中操作，性能极高，单机一般可支撑 10万数量级的 QPS。 
- 可用作**数据缓存 (Cache)**、数据持久存储和消息队列 (Message Queue)。

##### 什么时候进行预热 (Warm-up)

![](image/Pasted%20image%2020221006212917.png)

##### 通过 Redis 扣减库存

- 为什么要先锁定库存，付款后再来进行库存扣减
	- 举个例子：你要买水果，但是没有钱，你和老板约好了，回家拿钱来买，但是老板怕你不守信用，于是和你约定了半个小时的时间，时间到了，你没有来，水果拿着接着卖，来了，水果就卖给你，在你没到来之前，苹果就是属于一个锁定状态

![](image/Pasted%20image%2020221006213311.png)

- 这个流程有没有问题
	- 检查 Redis 库存和扣减 Redis 库存是两步操作（不是原子操作，但是可以通过 Lua 脚本解决）。
	- 有并发问题仍然会导致超卖(Oversold)。

- 解决方案
	- 哪怕 Redis 侧放行，可以创建订单了，到 MySQL 的时候也需要再检查一次。

- 新的问题
	- 如果并发量超高，Redis 侧实际超卖的量过大， 如 100万个请求同时到达，Redis 全部放行。再 到 MySQL 去检测，那 Redis 作用等于没有。

- 通过 Lua 脚本执行原子操作(Atomic Operation)
	- Lua 脚本功能是 Reids 在 2.6 版本中推出， 通过内嵌对 Lua 环境的支持，Redis 解决了长久以来不能高效地处理 CAS （check-and-set）命令的缺点， 并且可以通过组合使用多个命令， 轻松实现以前很难实现或者不能高效实现的模式。
	- Lua 脚本是类似 Redis 事务，有一定的原子性，不会被其他命令插队，可以完成一些 Redis 事务性的操作。

![](image/Pasted%20image%2020221006214713.png)

- 如果秒杀数量是1万台，或者10万台呢?
	- 因为 Redis 和 MySQL 处理能力的巨大差异。实际下沉到 MySQL 的量还是巨大，MySQL 无法承受。

- 解决思路
	- 可不可以在通过 Redis 扣库存后，到 MySQL 的请求慢一 点?

- 解决方案
	- 通过消息队列(Message Queue，MQ)进行削峰(Peak Clipping)操作。

##### 消息队列简介

- 一类基于**生产者/消费者模型(Producer/Consumer Model)** 的组件。
- 用于实现两个不同的系统之间的**解耦(Decoupling)** 和**异步(Asynchronous)** 操作。
- 消费者(Consumer)可以按照自己的节奏去消费(Consume)生产者投递的消息。
- 消息队列一般带有重试(Retry)的能力。可以持续投递，直到消费者消费成功。

![](image/Pasted%20image%2020221006215505.png)

##### 通过消息队列异步地创建订单

- 如果消息队列出现部分投递失败怎么办?
	- Redis 中的库存量，可以比实际的库存量多一点，比如 1.5 倍或者 2 倍。

![](image/Pasted%20image%2020221006215836.png)

#### 库存扣减时机

##### 下单时立即减库存

- 用户体验最好，控制最精准，只要下单成功，利用数据库锁机制，用户一定能成功付款。
- 可能被恶意下单。下单后不付款，别人也买不了了。

##### 先下单，不减库存。实际支付成功后减库存

- 可以有效避免恶意下单。 对用户体验极差，因为下单时没有减库存，可能造成用户下单成功但无法付款。

##### 下单后锁定库存，支付成功后，减库存

- 这种方案最好

#### 如何进行限购

##### MySQL 数据校验(data verification)

- 缺陷就是大流量下对数据库的压力很大，这种方法不推荐

![](image/Pasted%20image%2020221006220311.png)

##### Redis 数据校验(data verification)

- 目前主流
- 使用 Redis 提供的集合数据结构，将扣减 Redis 库存的用户 ID 写入。

![](image/Pasted%20image%2020221006220410.png)

![](image/Pasted%20image%2020221006220438.png)

#### 付款和减库存的数据一致性

- 在进行订单生产和库存扣减的时候涉及到了多个服务，如何保证这三个服务的数据一致性，这就涉及到分布式事务了

![](image/Pasted%20image%2020221006220903.png)

##### 分布式事务(Distributed transaction)

- 保证多个存在于不同数据库的数据操作，要么同时成功，要么同时失败。主要用于强一致性的保证。

![](image/Pasted%20image%2020221006221317.png)

## Scale 拓展

- 如何优化系统
- 加分项

### 是否有遗漏什么功能

- Redis 库存扣减完毕后，是否后面的请求可以直接拒绝了？
	- 可能十万人抢购 100 台 iPhone，大部分请求是无效的。
	- Redis 能力高过 MySQL，但能力还是有限。

### 防止刷爆页面

#### 前端资源静态化

- CDN 的全称是 Content Delivery Network，即内容分发网络。  
- CDN 是依靠部署在各地的边缘服务器(Edge server)，通过中心平台
的负载均衡(load balance)、内容分发(dispatch)、调度等功能模块，使用户就
近获取所需内容，降低网络拥塞，提高用户访问响应 速度和命中率。

![](image/Pasted%20image%2020221006221853.png)

#### 前端限流(front-end current-limiting)

- 点击一次后，按钮短时间内置灰
- 部分请求直接跳转到「繁忙页」

#### 未开始抢购时，禁用抢购按钮

##### 如何计算倒计时?  

1. 打开页面获取活动开始时间，然后前端页面开始倒计时
2. 打开页面获取距离活动开始的时间差，然后前端页面开始倒计时
3. 前端轮询 (Poll) 服务器的时间，并获取距离活动开始的时间差

![](image/Pasted%20image%2020221006222427.png)

### 秒杀服务器挂掉，怎么办

- 尽量不要影响其他服务，尤其是非秒杀商品的正常购买。

#### 服务雪崩 (Avalanche)

- 多个微服务(Microservice)之间调用的时候，假设 微服务A 调用 微服务B 和 微服务C，微服务B 和微服务C 又 调用其他的微服务，这就是所谓的 ”扇出 (Fan-out)”，如扇出的链路上某个微服务的调用响应时间过长或者不可用，对 微服务A 的调用就会占用越来越多的系统资源，进而引起系统雪崩， 所谓的”雪崩效应”。
- 服务雪崩效应是一种因“服务提供者”的不可用导致 “服务消费者” 的不可用并将这种不可 用逐渐放大的过程。

![](image/Pasted%20image%2020221006222729.png)

##### 服务熔断 (Fuse or Circuit-breaker)

- 熔断机制是应对雪崩效应的一种微服务链路保护机制，当扇出链路的某个微服务不可用或者响应时间太长时，熔断该节点微服务的调用，快速返回”错误”的响应信息。当检测到该节点微服务响应 正常后恢复调用链路。
- Netflix Hystrix
- Alibaba Sentinel

### 防止恶意刷请求或者爬虫请求

#### 验证码机制(Verification Code Mechanism)

![](image/Pasted%20image%2020221006223003.png)

#### 限流机制(Ratelimit Mechanism)

- 思考题：如何设计限流器 Rate Limiter

![](image/Pasted%20image%2020221006223042.png)

#### 黑名单机制(Blacklist Mechanism)

1. 黑名单 IP 地址 
2. 黑名单用户ID

# 秒杀系统 vs 订票系统

- 在业务上，他们有哪些差异？
	- 本质上还是大流量下对库存的抢夺
	- 100 台 iPhone 没有区别
	- 但是 100 张同一车次的火车票，有座位的区别（暂时忽略一等座二等座等）

- 数据库的设计

![](image/Pasted%20image%2020221006223504.png)