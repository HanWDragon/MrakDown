# 前情提要

- 使用 4S 分析法分析用户系统
- 缓存是什么 Cache
- 缓存和数据库如何配合 Cache & Database
- 登陆系统如何做 Authentication Service
- 好友关系的存储与查询 Friendship Service
- 关系型与非关系型数据库的适用场景比较 SQL vs NoSQL
- 以 Cassandra 为例了解 NoSQL 型数据库
- 拓展真题
	- NoSQL单向好友关系  
	- 如何按照 email / username / phone / id 同时检索 User
	- 共同好友查询  
	- Linkedin六度好友关系

# Design User System

- 实现功能包括
	- 注册
	- 登录
	- 用户信息查询
	- 好友关系存储

## 4S - Scenario Service Storage Scale

### Scenario场景

- 注册、登录、查询、用户信息修改
	- 哪个需求量最大?
	- 肯定是查询了，你的好友要看你的用户信息，你也要看你的信息，每天会产生大量的查询
	- 但是注册、登陆、和用户信息修改需求量就没那么大了
- 支持 100M DAU  
- 注册，登录，信息修改 QPS 约
	- 100M * 0.1 / 86400 ~ 100
	- 0.1 = 平均每个用户每天登录 + 注册 + 信息修改
	- Peak = 100 * 3 = 300
- 查询的QPS约
	- 100M * 100 / 86400 ~ 100k
	- 100 = 平均每个用户每天与查询用户信息相关的操作次数(查看好友，发信息，更新消息主页)
	- Peak=100k * 3 = 300k

### Service服务  

- 一个 AuthenticationService 负责登录注册  
- 一个 UserService 负责用户信息存储与查询
- 一个 FriendshipService 负责好友关系存储

#### Authentication Service

- 登录系统

##### Session 会话

- 用户 Login 以后，为他创建一个 session 对象
- 并把 session_key 返回给浏览器，让浏览器存储起来
- 浏览器将该值记录在浏览器的 cookie 中
- **用户每次向服务器发送的访问，都会自动带上该网站所有的 cookie**
- 此时服务器拿到 cookie 中的 session_key，在 Session Table 中检测是否存在，是否过期
- Cookie
	- HTTP协议中浏览器和服务器的沟通机制，服务器把一些用于标记用户身份的信息，传递给浏览器，浏览器每次访问任何网页链接的时候，都会在 HTTP 请求中带上所有的该网站相关的 Cookie 信息。
	- Cookie 可以理解为一个 Client 端的 hash table。

###### Session 记录过期以后，服务器会主动删除么

- 不会，有TTL，过期了之后再来删除

###### 只支持在一台机器登陆和在多台机器同时登陆的区别是什么

- 在 Session 多放点信息，用来确定用的什么设备登陆，如果其他的设备要登陆，就把其他的 Session 过期就行了
- 多台登陆就改变规则就好了

###### Session 适合存在什么数据存储系统中

- 用户不多的情况，存在 Cache 里面没啥问题，大不了都重新登陆，又不是重要数据
- 但是大网站，都会放在数据库中的，和 Cache 相互配合

#### Friendship Service

- 好友关系的存储与查询

##### 单向好友关系

- 你关注他，他不要同意
- 例子
	- Twitter、Instagram、微博
- 存在 SQL 数据库时
    - 查询x所有的关注对象: 
    - `select * from friendship where from_user_id=x`
    - 查询x所有的粉丝
    - `select * from friendship where to_user_id=x`
- 存在 NoSQL 数据库时
	- [03 从用户系统设计中学习数据库与缓存](#NoSQL%20存单向好友关系)

![](image/Pasted%20image%2020221007203750.png)

##### 双向好友关系

- 例子
	- 微信，Facebook，WhatsApp
- 方案 1
	- 存储为一条数据，数字较小的存在 `smaller_user_id` ，数字较大的存在 `bigger_user_id`
	- `select * from friendship where smaller_user_id = x or bigger_user_id=x`
	- 为什么需要区分 smaller / bigger?
		- 如果我们不区分，你要查询 A 和 B 是否互为好友，你要如何查询，你要查询两次（因为有 (A,B) 和 (B,A) 两种情况），因为没有人为制定顺序，会造成数据冗余和查询变慢。
	- SQL 可以按照这种方案
	- NoSQL 很多不支持 Multi-index 不能使用这种方案
- 方案 2
	- 存储为两条数据
	- `select * from friendship where from_user_id=x`
	- NoSQL 和 SQL 都可以按照这种方案
- 两种方案哪种更好?
	- 方案一省空间，但是SQL语句中有 or 操作，查询速度比方案二慢
	- 方案二空间换时间，查询快，在线服务通常都很在乎用户的体验
		- 但是有个问题，就是每次插入都要插入两条数据，都要同时成功或失败，可以使用事务
		- 如果是分布式数据库，使用事务很麻烦，那就让用户多试几次，或者排查日志解决就好了
		- 其实也不是什么大问题，这种情况太少见了。

![](image/Pasted%20image%2020221007204258.png)

### Storage存储

#### QPS 与系统设计的关系

- 为什么要分析 QPS
	- QPS 的大小决定了数据存储系统的选择

- MySQL/PosgreSQL等SQL数据库的性能
	- 约 1k QPS 这个级别  
- MongoDB/Cassandra等硬盘型NoSQL数据库的性能
	- 约 10k QPS 这个级别  
- Redis/Memcached等内存型NoSQL数据库的性能
	100k~1mQPS这个级别  
- 以上数据根据机器性能和硬盘数量及硬盘读写速度会有区别

#### 思考  

- 注册、登录、信息修改，300 QPS，适合什么数据存储系统
	- 传统的关系型数据库就行了，能扛下压力

- 用户信息查询适合什么数据存储系统
	- 用户系统特点
	- 读非常多，写非常少
	- 一个读多写少的系统，一定要使用 Cache 进行优化

#### Cache

- Cache是什么?
	- 缓存，把之后可能要查询的东西先存一下  
	- 下次要的时候，直接从这里拿，无需重新计算和存取数据库等
	- 可以理解为一个Java中的HashMap • key-value的结构
- 有哪些常用的 Cache 系统/软件?  
	- Memcached(不支持数据持久化)
	- Redis(支持数据持久化)
- Cache一定是存在内存中么?
	- 不是
	- Cache这个概念，并没有指定存在什么样的存储介质中
	- FileSystem也可以做Cache
	- CPU也有Cache
- Cache一定指ServerCache么?  
	- 不是，Frontend / Client / Browser 也可能有客户端的 Cache

#### Memcached

- 一款负责帮你 Cache 在内存里的“软件”
- 非常广泛使用的数据存储系统

##### 使用例子

![](image/Pasted%20image%2020221007103325.png)

##### 如何优化 DB 的查询

- getUser 很像记忆化搜索
- 为什么 setUser 先把 cache 进行了 delete，再去数据库进行修改，而不是两边都修改呢？
- 给你看几个例子，下面哪些写法是不对的？

 1. database.set(user); cache.set(key, user);
 2. database.set(user); cache.delete(key);
 3. cache.set(key, user); database.set(user);
 4. cache.delete(key); database.set(user);

- 其实上面这四种写法全都不对！
- 因为 Cache 和 Database 的操作都不保证一定成功
- 在工程代码中，你要注意的地方和你写算法设计不太一样，你所访问的数据或者是远端的系统，它并不会保证你每一次操作都成功，可能会因为各种原因而导致操作失败。

![](image/Pasted%20image%2020221007103459.png)

##### Cache 和 Database 的操作都不保证一定成功

1. database.set(user); cache.set(key, user); 
2. database.set(user); cache.delete(key);
3. cache.set(key, user); database.set(user);

- 以上三个选项，如果第一个操作成功了，第二个操作失败了，都会导致数据库和缓存中的数据不一致 (inconsistent)。我们称之为“脏数据”(Dirty Data)
- 我们也不需要考虑第一个失败了，第二个成功了
	- 因为在程序是顺序执行，第一个操作失败了，抛出了异常，不会去执行后面的代码了，整个操作就失败了，没必要执行后面的操作了，执行了也不是你想要的结果
	- 不用担心你失败了是个很可怕的事情，你就告诉用户，你的操作失败了。
	- 你作为程序员更需要担心的是因为这个失败，而导致的数据不一致！

4. cache.delete(key); database.set(user);

- 4 选项中，不会因为第一个操作成功，而第二个操作不成功造成数据不一致。
- 因为 cache.delete 是删除缓存中的数据，而不是修改缓存中的数据，第二个操作失败以后，信息相当于没有被修改，虽然操作失败了，但是没有造成缓存与数据库的数据不一致。
- 我们以为数据库中的信息，是信息唯一的真实来源。
- 但是 4 这个选项仍然存在问题，请问在什么情况下会造成数据不一致？
	- 多线程多进程下的数据不一致

##### 多线程多进程下的数据不一致

- 在 setUser 执行到14行和15行之间的时候
- 另外一个进程执行了 getUser  
- 此时 cache 里的数据是旧数据
- 数据库却是新数据
- 导致了数据不一致

![](image/Pasted%20image%2020221007105853.png)

##### 解决方法（不推荐）

- 可以给数据库和缓存的两个操作加锁么?

**不行，数据库和缓存是两台机器，两套系统，并不支持加锁 如果是用一些第三方分布式锁，会导致存取效率降低，得不偿失**

1. 这个可不是单机系统那么简单，在微服务场景下，很多都是多机系统，都是跨机器通讯，你所想的上锁可没那么简单
2. 你原本的目的是为了优化，上了分布式锁，性能比原来还差，你这有什么意义

##### 业界最常用的方法

- Best practice
	- **database.set(key, user); cache.delete(key)**

- 问题 1
	- 在多线程多进程的情况下依旧会出问题 在getUser执行到第9行和第10行之间时 另外一个进程执行了 setUser()，cache 里会放入旧数据 
- 问题 2
	- db set 成功，cache delete 失败
- 好处
	- 上面这两种情况发生概率都远低于 cache.delete + db.set 为什么
	- 因为这个系统是一个读多写少的系统，据统计在真实系统中缓存的命中概率

![](image/Pasted%20image%2020221007172936.png)

##### 如何“解决”一致性问题

- 巧妙利用 cache 的 ttl（time to live / timeout） 机制
- 任何一个 cache 中的 key 都不要永久有效，设置一个短暂的有效时间，如 7 天
- 那么即便在极低概率下出现了数据不一致，也就最多不一致 7 天
- 即，我们允许数据库和缓存有“短时间”内的不一致，但最终会一致。

#### 如果写很多怎么办

- 在每次数据修改的时候，我们会在 cache 中 delete 这个数据
- 如果写很多，甚至写多读少，那么此时 cache 是没有任何优化效果的
- 没办法，只能堆机器(Sharding)

##### Cache Aside

- 服务器分别与 DB 和 Cache 进行沟通
- DB 和 Cache之间不直接沟通
- 业界典型代表
	- Memcached + MySQL

![](image/Pasted%20image%2020221007180612.png)

##### Cache Through

- 服务器只和 Cache 沟通 
- Cache 负责 DB 去沟通，把数据持久化
- 业界典型代表
	- Redis(可以理解为 Redis 里包含了一个 Cache 和一个 DB)
- 缺点
	- Redis 支持单纯的 key-value 存储结构，无法适应复杂的应用场景
- 所以通常业界使用 Cache Aside 的方式较多，Cache 和 DB 都可以自由的搭配组合

![](image/Pasted%20image%2020221007180633.png)

#### 以 Cassandra 为例剖析典型的 NoSQL 数据结构

- Cassandra是一个三层结构的NoSQL数据库
	- 第一层:row_key  
	- 第二层:column_key  
	- 第三层:value
- Cassandra 的 Key = row_key + column_key  
	- 同一个 row_key + column_key 只对应一个 value
- 结构化信息如何存储?
	- 将其他需要同时存储的数据，序列化(Serialize)到 value 里进行存储  
	- 什么是Serialization:把一个object /hash序列化为一个string，比如把一棵二叉树序列化

##### Row Key

- 又称为 Hash Key, Partition Key
- Cassandra 会根据这个 key 算一个 hash 值
- 然后决定整条数据存储在哪儿 
- 无法进行 Range Query
- 常用
	- user_id

##### Column Key

- insert(row_key, column_key, value)
- 任何一条数据，都包含上面三个部分
- 你可以指定 column_key 按照什么排序
- Cassandra 支持这样的“范围查询”
	- query(row_key, column_start, column_end)
	- 可以是复合值，如：timestamp + user_id
	- 这种NoSQL和以满足一些传统 KV 型 NOSQL 无法解决的问题
	- 想要查询我一段时间的历史记录，这种就很好用

##### SQL vs NoSQL

- SQL的column是在Schema中预先指定好的，不能随意添加
- 一条数据一般以 row 为单位(取出整个row作为一条数据)

![](image/Pasted%20image%2020221008002501.png)

- NoSQL的column是动态的，无限大，可以随意添加  
- 一条数据一般以 grid 为单位，row_key + column_key + value = 一条数据  
- 只需要提前定义好 column_key 本身的格式(是一个 int 还是一个 int+string)

![](image/Pasted%20image%2020221008002705.png)

- 数据库选择原则 1
	- 大部分的情况，用SQL也好，用NoSQL也好，都是可以的
- 数据库选择原则2
	- 需要支持 Transaction 的话不能选 NoSQL
- 数据库选择原则 3
	- 你想在什么地方偷懒很大程度决定了选什么数据库
	- SQL 结构化数据，自由创建索引 
	- NoSQL 分布式，Auto-scale，Replica
- 数据库选择原则 4
	- 一般一个系统会同时用多种数据库系统

- User Table 存在哪儿? 
	- 大部分公司选择了 SQL
	- 原因：信任度，Multi-Index
- Friendship 存在哪儿?
	- 大部分公司选择了 NoSQL 
	- 原因：数据结构简单，都是 key-value 的查询 / 存储需求
	- NoSQL效率更高

 不同的表单放在不同的数据库里

##### 以 Cassandra 为例看看 Friendship Table 如何存储

- 如果要查询最近1天关注的好友怎么办?

将时间戳放在column_key中，这样就可以查到最近一天关注的好友了，但是你就无法查找 A 和 B 是否为好友了，你只能去新建一张表去查询了，如果最近关注使用不多，也可以使用数据库查询

![](image/Pasted%20image%2020221008002803.png)

##### Cassandra 如何存储 NewsFeed

- 通常 Value 是不放值的，推文会有其他的缓存系统进行存储，我只是需要推文的信息就好了。

![](image/Pasted%20image%2020221008003747.png)

# 扩展

## NoSQL 存单向好友关系

- 使用 Cassandra 存储单向好友关系，支持如下操作：
	1. 查询某个人的关注列表
	2. 查询某个人的粉丝列表
	3. 查询A 是否关注了 B
- 请设计出需要哪些表单和对应的表单结构

- 需要两张表单，一张存粉丝，一张存关注


### Redis

- `key = user id`
- `value = set of friend_user_id`
- 粉丝表里就是粉丝id，关注表里就是关注的用户id
- 查 A 是否关注了B
- 使用 Redis 的 SISMEMBER 操作查询 A 关注的人里有没有B


### Cassandra

- `row key = user id`
- `column key =friend_ user id`
- 粉丝表里就是粉丝 id，关注表里就是关注的用户 id
- value = 其他你想同时存储的东西，如关注时间
- 查 A 是否关注了 B
- 在关注表中查询 row_ key = A, column key = B 的数据是否存在

## NoSQL 存储 User

- 如果使用不支持 Multir-index 的 NoSQL 存储 User
- 如何同时支持按照 email, username, phone, id 来检索用户

- User 相关的所有数据都存在 UserTable 里
	- Redis
		- key = user id, value = 用户信息
	- Cassandra
		- row key = user id
		- column key=任何你想放的信息
		- value = 其他用户信息
- 其他再同时创建多张表单，用作 index
	- Redis
		- key = email / phone / username, value = user id
	- Cassandra:
		- row key = email / phone / username
		- column key =任何你想放的信息
		- value =其他用户信息

## 共同好友

- 共同好友(Mutual Friends) 是社交网站上常见的功能
- 请设计这个功能
	- 列出 A 和B之间的共同好友

- 基本流程：
	1. 获得A的好友列表
	2. 获得 B 的好友列表
	3. 求交集
- 总共两次数据库的 key-value 查询
- 优化
	- 使用缓存存储用户的好友列表 -> 两次数据库查询变两次缓存

## Linkedln 六度关系
- Linkedln 上有一个功能是显示你和某人之间的几度关系
- 通过多少个朋友能认识
- 请设计这个功能
- 可以使用宽度优先搜索(BFS)算法么？

#### 细化场景 Scenario

- 查询你和某些人(不超过10个）之间的六度关系
- 用户数量级＞100M
- 平均好友数 1000 个
- 期望的DB Query 次数为常数级（<20次 Query)
- A<->B A和B之间是一度关系
- A<->B<->C A和C之间是两度关系
- A<->B<->C<->D A和D之间是三度关系

- 我们就看看一下，在这样的需求分析之后，看一下宽度有限搜索算法，能不能满足我的需求呢？
- 先将问题简化，我们求 A 和 B 之间是几度关系，我们使用宽度优先搜索算法，找到了 A 的所有好友，估计是 1K 个，这个时候就只花费了一次数据库查询的时间，但是再往下就遇到问题了，你要对每一个好友再进行宽度有限搜索算法，这个可是在实际业务中，不是你写算法题，读取数据库也不是一个 $O(1)$ 的操作，这个时候，发现我们查了两层之后，数据库的请求次数已经到 K 这个级别了，这在工程中是不可行的
- 我们也可以使用双向宽度优先搜索算法，我们也可以查一下 B 有哪些好友，同时都得到了这 1K 个好友之后，在内存中我去求一下这两个人数据的交集，就知道了他们之间是不是一个二度关系，这样就花费了 2 次数据库查询，就是想单独找他们两个人之间的共同好友，有一个就是 2 度好友
- 但是后面的几度关系，我该如何解决呢？
- 这个时候我们就要做一些权衡了
- 切入点
	- 3度关系是没有现实意义的，对于超过三度的关系，直接显示 3度+
	- 在线去算出我的二度好友是很耗时，而且是会带来用户体验不好的方案，但是我们可以离线来做这些事情，就算数据量有点大，但是还是也可算出来的，就是慢点，但是不会影响正常业务，一般也就花个几天的时间，而且大公司肯定都是有机器的储备的。
- 方法
	- 提前算好所有的一度和二度关系井存储在 NoSQL 里
		- 一度表  key=user_id. value = 所有一度关系(直接好友）
		- 二度表  key=user_ id. value = 所有二度关系（间接好友）
	- 查询我的所有一度和二度关系得到我的直接和间接好友集合 set1（两次key-value Query)
	- 对于给定的不超过 10 个需要查询关系距离的用户列表查询他们的一度关系，得到 set2(10次 Query)
	- 在set1 和 set2 中求交集，根据交集结果推导这 10 个人和我的关系距离
- 这个面试的重点就是看你是否了解离线计算

## 阅读

• Dynamo DB - 理解分布式数据库(NoSQL)的原理
	- http://bit.ly/1mDs0Yh \[Hard]\ \[Paper]

- Scaling Memcache at Facebook - 妈妈再也不担心我的 Memcache
	- http://bit.ly/1UlpbGE \[Hard]\ \[Paper]

- Coach Base Architecture  
	- http://horicky.blogspot.in/2012/07/couchbase-architecture.html

- Least Frequently Used Cache (LFU)
	- http://dhruvbird.com/lfu.pdf

## NoSQL，也就是所谓的分布式数据库

### 分布式数据库解决的问题

- Scalability

### 分布式数据库还没解决很好的问题

- Query language  
- Secondary index  
- ACID transactions
- Trust and confidence

## Storage, Network

![](image/Pasted%20image%2020221009102728.png)

![](image/Pasted%20image%2020221009102740.png)