## 软件虚拟化

- 超虚拟化
- 完全虚拟化（全虚拟化）
	- VMWare Workstation
	- Hyper-V
	- QEMU
- 部分虚拟化（半虚拟化）
	- 早期XEN（需要对操作系统进行修改）
- 硬件虚拟化
	- KVM
	- XEN
	- VMWare Fusion
- 操作系统虚拟化
	- 容器（Containers）最早出现在Unix上
		- chroot（Unix）
		- LXC
		- Lmctfy（Google开源容器）
		- LXD（2014年以前）
		- Docker（最早Ubuntu上开发出来）
			- 早期是基于LXC
			- 后期是基于Google的Go语言开发
			- 2015年Lmctfy在Linux的开源容器LibContainer影响了Docker也影响了Kubernetes
		- CoreOS
		- Windows Container
		- Podman
		- Buidah

### 为什么要使用容器

- 与传统的软件开发相比可以高效的构建应用，方便维护和管理
- 在开发过程中（方便测试环境）
- 方便软件迁移

#### 技术优势

1. 更快速的交付和部署
	- 一次创建和配置，可以在任意地方运行
	- 可以使用标准镜像来构建开发容器
	- 方便运维部署
	- 快速迭代应用
	- 让其他人更容易理解程序构建发生了啥
	- Docker跑的很快
2. 更加高效的虚拟化
	- 内核级别的虚拟化
3. 更加轻松的迁移和扩展
	- 几乎所有主流的平台
		- 物理机
		- 虚拟机
		- 云
		- 个人电脑
4. 更简单的管理
	- 很小的修改就可以完成以前大量的工作
	- 所有的修改都会以增量的方式被分发和更新
	- 实现了自动且高效的管理

## 硬件虚拟化

- cpu
	- Intel-VT
	- AMD-V
- 内存
- IO

## Docker架构

- CS架构
- 5个基本概念
	- Docker daemon 
		- 守护进程，运行在宿主机，用户通过Docker Client客户端使用Docker命令与Docker daemon交互
	- Docker Client
		- 命令行工具，是用户使用Docker的主要方法
	- Docker Image
		- 简单来说就是root文件系统
	- Docker Container
		- 容器就是镜像的一个实例
			- 容器创建
			- 容器启动
			- 容器停止
			- 容器删除
			- 容器暂停
	- Docker Repository
		- 仓库保存镜像
## Docker扩展架构

- 容器的编排
- 容器的安全
- 容器的集群
- 容器的监控
- 容器与系统
	- CoreOS
	- 其他定制化操作系统
- Docker和devops

### 容器的网络架构

#### 外部访问容器

- 宿主机访问容器常见有 5 种方式

1. 宿主机随机端口映射容器所有端口
2. 宿主机随机端口映射容器指定端口
3. 宿主机指定端口映射容器指定端口
	- `docker run -itd -p 80:80 nginx /bin/bash`
4. 宿主机随机端口映射容器指定IP、指定端口
5. 宿主机指定端口映射容器指定IP、指定端口
##### 端口映射

```shell
-p, --publish list  Publish a container's port(s) to the host
指定端口映射 主机端口:容器端口（多用于生产环境）
-P, --publish-all   Publish all exposed ports to random ports
容器内部的端口随机映射到主机的高端口（测试用）
```

##### 端口的暴露

- Dockerfile 中的 `EXPOSE`

### 容器访问容器

- 容器互连
##### 创建桥接方式的自定网络

1. `docker network create -d bridge network_name`
2. `docker run -itd -p 172.0.0.1::80:80 --name alpine-01 --network bridge`
3. `docker run -itd -p 172.0.0.1::8080:8080 --name alpine-02 --network bridge`

### 容器网络的几种模式

- host模式
	- `--net=host` 指定
- container模式
- none模式
- bridge模式（默认）
- 自定义网络

## Docker Client

- Docker 命令

- 非交互式操作
	`docker run ubuntu /bin/echo "Hello Docker"`
- 交互式操作
	` docker run -i -t ubuntu /bin/bash`
### run 命令

- 通过镜像创建并启动容器
- -i 标准输入缓冲区（流）
- -t 终端或者模拟终端
- -d 以守护进程的方式创建容器
- -itd简写
- --name 创建别名
- 相当于 docker create ID/Name + docker start ID/Name = docker run ID/Name

### create 命令

- dorker create ID
- 创建容器并不启动

### exit 命令

- 从交互模式退出

### ps 命令

- 查看容器的状态
- -a 详细参数

### start 命令

- dorker start ID

### stop 命令

- dorker stop ID

### restart 命令

- dorker restart ID

### pause 命令

- dorker pause ID

### unpause 命令

- dorker unpause ID
- 从暂停中恢复

### exec 命令

- dorker exec -i -t ID /bin/bash 进入后台执行的容器
- 使用这个命令 exit 退出操作，容器不会退出

### attach 命令

- 不推荐，在退出时会终止容器，而且没有彩色字符

### rm 命令

- -f 强制删除一个正在运行的容器
- 后面可以接多个参数来删除多个

```bash
docker rm -f test test1
docker rm -f $(docker ps -aq)
```
### kill 命令

- 强行停止一个运行中的容器
- -s 发送对应的信号
- `docker kill -s kill ID/Name`

### ps 命令

- -a 显示全部容器
	- CONTAINER ID
	- IMAGE
	- COMMAND
	- CREATED
	- STATUS
		- Created
		- Up
		- Pause
		- Exited
	- PORTS
	- NAMES
- 直接用就是显示正在运行的容器
- -q 只显示ID
	- -n 列出最近多少个容器

### log 命令

- 查看当前容器的日志
### inspect 命令

- 查看容器的详细信息，是JSON格式的

### top 命令

- 查看容器中的进程信息

### rename 命令

- 重命名容器

### diff命令

- 检查容器文件系统变动

### status  命令

- 实时监控容器的资源使用情况

## 镜像仓库

### 镜像

#### 查找镜像

- `docker search httpd`

#### 拉取镜像

- `docker pull httpd:version`
- 不指定版本号默认最新

#### 镜像列表

- `docker images`
- `docker image ls`
	- REPOSITORY 仓库源
	- TAG 标签，版本号
	- IMAGE ID 镜像ID
	- CREATED 创建时间
	- SIZE 大小

#### 镜像导出

- `docker export image_id`
- `docker save ubuntu -o ubuntu-docker-latest.tar`

#### 镜像导入

- `docker import image_id`
- `docker load -i ubuntu-docker-latest.tar`

#### 删除镜像

- `docker rmi`
- `docker image rm`
- -f 强制删除

#### 镜像标签

- `docker tag image_id repo/image_id:tag`
- `docker tag nginx han/nginx:dev

#### 镜像提交

- `docker push`

#### 镜像创建

- 可以通过 `docker inspect ID/Name` 来查看

```JSON
[
    {
        "Id": "sha256:a8758716bb6aa4d90071160d27028fe4eaee7ce8166221a97d30440c8eac2be6",
        "RepoTags": [
            "nginx:latest"
        ],
        "RepoDigests": [
            "nginx@sha256:985224176778a8939b3869d3b9b9624ea9b3fe4eb1e9002c5f444d99ef034a9b"
        ],
        "Parent": "",
        "Comment": "buildkit.dockerfile.v0",
        "Created": "2023-10-24T22:44:45Z",
        "Container": "",
        "ContainerConfig": {
            "Hostname": "",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": false,
            "AttachStderr": false,
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": null,
            "Cmd": null,
            "Image": "",
            "Volumes": null,
            "WorkingDir": "",
            "Entrypoint": null,
            "OnBuild": null,
            "Labels": null
        },
        "DockerVersion": "",
        "Author": "",
        "Config": {
            "Hostname": "",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": false,
            "AttachStderr": false,
            "ExposedPorts": {
                "80/tcp": {}
            },
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
                "NGINX_VERSION=1.25.3",
                "NJS_VERSION=0.8.2",
                "PKG_RELEASE=1~bookworm"
            ],
            "Cmd": [
                "nginx",
                "-g",
                "daemon off;"
            ],
            "ArgsEscaped": true,
            "Image": "",
            "Volumes": null,
            "WorkingDir": "",
            "Entrypoint": [
                "/docker-entrypoint.sh"
            ],
            "OnBuild": null,
            "Labels": {
                "maintainer": "NGINX Docker Maintainers <docker-maint@nginx.com>"
            },
            "StopSignal": "SIGQUIT"
        },
        "Architecture": "amd64",
        "Os": "linux",
        "Size": 186728317,
        "VirtualSize": 186728317,
        "GraphDriver": {
            "Data": {
                "LowerDir": "/var/lib/docker/overlay2/cf40be31a40448356ef6953c86c07108bc4cdf94c1dcba073b534878951d984b/diff:/var/lib/docker/overlay2/bbe5e0d27f8ec76b097413dc5ef036f853e57fbb0c4d861f6a8e39acbda236f3/diff:/var/lib/docker/overlay2/9e6677dc215a66a8d23f5e8db1b66c285f8cbb955a31871088ab09565e22a7e6/diff:/var/lib/docker/overlay2/fefafaf95a4ea5ec1de8c74471efa7da769f0ec24d1edff6ee618f2953699fc9/diff:/var/lib/docker/overlay2/bd1a1e998ab7634a7a3b3536f9c393a74ccc6cb8c4be9581852bd8cc2ea387b2/diff:/var/lib/docker/overlay2/be25edc3879f993290a3df3a67e954eecdd87442276fbc886ec8a02f95b08b34/diff",
                "MergedDir": "/var/lib/docker/overlay2/af6d2f98076209577625414903f4218a06ab7c787099421a06ad2bba222c1b92/merged",
                "UpperDir": "/var/lib/docker/overlay2/af6d2f98076209577625414903f4218a06ab7c787099421a06ad2bba222c1b92/diff",
                "WorkDir": "/var/lib/docker/overlay2/af6d2f98076209577625414903f4218a06ab7c787099421a06ad2bba222c1b92/work"
            },
            "Name": "overlay2"
        },
        "RootFS": {
            "Type": "layers",
            "Layers": [
                "sha256:571ade696b261f0ff46e3cdac4635afc009c4ed3429950cb95cd7e5f70ba0a07",
                "sha256:b6c2a8d6f0ac89ef77e161532f3d9d0dc5dfe0a5f20042e0afc0ad14288405eb",
                "sha256:b61d4b2cd2daf06047984c5876a35338c2beb5ae3f6bef479d25f05772a6a482",
                "sha256:eddcd06e5ef9b91677526f6c55fa01a7d6963c435d5cf2bfb488d91aaa72d4a8",
                "sha256:b4ad478450363f0a8020bb5552641fe6077e78fca48da4d77a979724a3ad2a72",
                "sha256:fbcc9bc44d3e165e7e4f56fb189a05ea5c562a733985ec00d5e3fad309eb63cc",
                "sha256:009507b8560964795eab5126f6363cb2b7403596adf370c9e95d4648c43e771f"
            ]
        },
        "Metadata": {
            "LastTagTime": "2024-02-01T13:39:26.7262051Z"
        }
    }
]
```

- 镜像提交
	- `docker commit`
	- 可以把容器打包成一个镜像
	- 也可以将容器中的数据打包到镜像
	- 运行了一个 ubuntu 镜像，对数据进行了修改，我们可以将这些修改的数据保存下来
	- `docker commit -m="new version" -a="han" image_id han/ubuntu:new`
	- -m 信息
	- -a 作者
- 镜像构建
	- `docker build` 根据自己的需求来自定义一个镜像
	- `dockerfile` 

```dockerfile
# 从什么基础镜像构建
FROM centos

# 定义作者的信息 
MAINTAINER 'han'

# 定义变量
ENV temp_path /tmp

# 设置登录后的工作路径（落脚点）
WORKDIR $temp_path

# 执行要干的操作
RUN curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-8.repo
RUN sed -i -e"s|mirrors.cloud.aliyuncs.com|mirrors.aliyun.com|g " /etc/yum.repos.d/CentOS-*
RUN sed -i -e "s|releasever|releasever-stream|g" /etc/yum.repos.d/CentOS-*
RUN yum clean all && yum makecache
RUN yum install -y vim
RUN yum install -y net-tools

# 开放指定的端口
EXPOSE 80
EXPOSE 22

# 执行命令
CMD echo $temp_path
CMD echo "success-----OK"
CMD /bin/bash


VOLUME

USER

ADD

COPY

ONBUILD

```

- 步骤
	1. 编写docker file 文件
	2. 使用 `docker build` 命令
	3. 可以使用 `docker history 来查看构建历史`
	4. 使用 `docker run` 命令
- 镜像结构 = 数据 + 元数据 就像千层饼
	- 
	- 数据
		- 4个Layer层
	- 元数据
		- JSON文件
- 对于这个千层饼结构是通过**联合挂载**来实现的
- 对内
	- 也就是多个镜像层通过联合挂载变成一个可以运行的容器
	- 也就是将多个目录挂载到同一个目录上，甚至可以是不同的文件系统
- 对外
	- 显示这些目录的整合形态
- docker 使用了 AUFS 来实现这个

#### 奖项


### 仓库

- 存储镜像
- 使用镜像首选官方
- 登录仓库 
	- `docker login ip_addr`
- 标记镜像 
	- `docker tag local_image:tag remote_ip_repo/project/image_name:tag`
	- `docker tag nginx:latest 192.168.0.1/dev/nginx:v1`
- 上传镜像（要先登录）
	- `docker push 192.168.0.1/dev/nginx:v1`
- 下载镜像
	- `docker pull 192.168.0.1/dev/nginx:v1``

#### 公用仓库

#### 私有仓库

#### 三方仓库
