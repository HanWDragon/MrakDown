# Java日志框架

## 日志简介

### 日志概述

只要程序员投身在实际的学习和生产环境中，就会对日志的重要性有着充分的认知，尤其是对于Web以及更高级的应用。在很多情况下，日志可能是我们了解应用如何执行的唯一方式。

但是现实是很多程序员对于日志的记录的认知比较肤浅，认为日志的记录输出是一件很简单而且会自动发生的事情，所以会经常忽略和日志相关的问题。

所以本课程主要就是针对于对于日志概念以及日志的框架不太熟悉的这类开发人群，更加详细且真实的体会日志为我们在开发和生产环境当中所带来的好处。

Java语言的强大之处就是因为它强大而且成熟的生态体系。其中包括日志框架，就有很多成熟的开源资源可以直接使用。

### 日志文件

日志文件是用于记录系统操作事件的文件集合。

日志文件它具有处理历史数据、诊断问题的追踪以及理解系统的活动等重要的作用。

### 调试日志

在软件开发中，我们要去经常的调试程序，或者做一些状态的输出，便于我们查询程序的运行状况。为了让我们能够更加灵活且方便的控制这些调试信息，我们肯定是需要更加专业的日志技术。我们平时在调试程序的过程中所使用的肯定就是专业开发工具自带的debug功能，可以实时查看程序运行情况，不能够有效保存运行情况的信息。调试日志是能够更加方便的去“重现”这些问题。

### 系统日志

系统日志是用来记录系统中硬件、软件和系统相关问题的信息。同时还可以监视系统中发生的事件。用户可以通过它来检查错误发生的原因，或者寻找收到攻击是留下的痕迹。

系统日志包括系统日志、应用日志和安全日志这几种分类。

## 日志框架

### 日志框架的作用

1. 控制日志输出的内容和格式。

2. 控制日志输出的位置。

3. 日志文件相关的优化，如异步操作、归档、压缩..

4. 日志系统的维护

5. 面向接口开发 – 日志的门面

### 日志框架的价值

因为软件系统发展到了今天非常的复杂，特别是服务器的软件，涉及到的知识和内容问题非常的多。对于日志记录来讲，在某些方面使用别人研发好的成熟的框架，这就相当于让别人帮你完成一些基础的工作。你只需要集中精力去完成业务逻辑就可以了。

比如事务处理，日志记录等一些安全性的问题，我们使用框架去做，不会影响业务的开发效率。

同时框架也是在不断升级的，我们可以不断的享受框架为我们带来的好处。

### 市面流行的日志框架

UL  java util logging

​    Java原生日志框架，亲儿子

Log4j

​    Apache的一个开源项目

Logback

​    由Log4j之父做的另一个开源项目

​    业界中称作log4j后浪

​    一个可靠、通用且灵活的java日志框架

Log4j2

​    Log4j官方的第二个版本，各个方面都是与Logback及其相似

​    具有插件式结构、配置文件优化等特征

​    Spring Boot1.4版本以后就不再支持log4j，所以第二个版本营运而生

JCL

SLF4j

### 日志门面和日志框架的区别

日志框架技术 JUL、Logback、Log4j、Log4j2

用来方便有效地记录日志信息

日志门面技术 JCL、SLF4j

为什么要使用日志门面技术：

每一种日志框架都有自己单独的API，要使用对应的框架就要使用对应的API，这就大大的增加了应用程序代码对于日志框架的耦合性。

我们使用了日志门面技术之后，对于应用程序来说，无论底层的日志框架如何改变，应用程序不需要修改任意一行代码，就可以直接上线了。

## JUL

### JUL简介

JUL全程 Java Util Logging，它是java原生的日志框架，使用时不需要另外引用第三方的类库，相对其他的框架使用方便，学习简单，主要是使用在小型应用中。

### JUL组件介绍

<img src="/Users/hwl/Documents/Markdown/%E6%80%BB%E7%BB%93/%E5%90%8E%E7%AB%AF/%E6%A1%86%E6%9E%B6/Java%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/image/image-20210726210600433.png" alt="image-20210726210600433"  />

Logger：被称为记录器，应用程序通过获取Logger对象，抵用其API来发布日志信息。Logger通常被认为是访问日志系统的入口程序。

Handler：处理器，每个Logger都会关联一个或者是一组Handler，Logger会将日志交给关联的Handler去做处理，由Handler负责将日志做记录。Handler具体实现了日志的输出位置，比如可以输出到控制台或者是文件中等等。

Filter：过滤器，根据需要定制哪些信息会被记录，哪些信息会被略过。

Formatter：格式化组件，它负责对日志中的数据和信息进行转换和格式化，所以它决定了我们输出日志最终的形式。

Level：日志的输出级别，每条日志消息都有一个关联的级别。我们根据输出级别的设置，用来展现最终所呈现的日志信息。根据不同的需求，去设置不同的级别。

### 实战案例

```java
package com.bjpowernode.jcl.test;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.junit.Test;

public class JCLTest01 {

    @Test
    public void test01() {

        /*

            我们暂时没有导入第三方的日志框架，例如log4j

            默认的情况下，会使用JUL日志框架做日志的记录操作

            JCL使用原则：
                如果有log4j，优先使用log4j
                如果没有任何第三方日志框架的时候，我们使用的就是JUL

         */
        Log log = LogFactory.getLog(JCLTest01.class);

        log.info("info信息");

    }

    @Test
    public void test02() {

        /*

            导入log4j依赖，继续测试原有程序

            总结：
                我们上一个案例，使用的是JUL，但是在集成了log4j环境后，使用的又是log4j
                通过测试观察，虽然日志框架发生了变化，但是代码完全没有改变

            日志门面技术的好处：
                门面技术是面向接口的开发，不再依赖具体的实现类，减少代码的耦合性
                可以根据实际需求，灵活的切换日志框架
                统一的API，方便开发者学习和使用
                统一的配置管理便于项目日志的维护工作

            查看源码：
                Log接口的4个实现类
                JDk13
                JDK14 正常java.util.logging
                Log4j 我们集成的log4j
                Simple JCL自带实现类

                （1）查看Jdk14Logger证明里面使用的是JUL日志框架
                （2）查看Log4JLogger证明里面使用的是Log4j日志框架

                （3）观察LogFactory，看看如何加载的Logger对象
                     这是一个抽象类，无法实例化
                     需要观察其实现类LogFactoryImpl

                （4）观察LogFactoryImpl
                    真正加载日志实现使用的就是这个实现类LogFactoryImpl

                （5）进入getLog

                    进入getInstance

                    找到instance = this.newInstance(name);，继续进入

                    找到instance = this.discoverLogImplementation(name); 表示发现一个日志的实现

                    for(int i = 0; i < classesToDiscover.length && result == null; ++i) {
                        result = this.createLogFromClass(classesToDiscover[i], logCategory, true);
                    }
                    遍历我们拥有的日志实现框架
                    遍历的是一个数组，这个数组是按照
                    log4j
                    jdk14
                    jdk13
                    SimpleLogger
                    的顺序依次遍历
                    表示的是，第一个要遍历的就是log4j，如果有log4j则执行该日志框架
                    如果没有，则遍历出来第二个，使用jdk14的JUL日志框架
                    以此类推

                    result = this.createLogFromClass(classesToDiscover[i], logCategory, true);
                    表示帮我们创建Logger对象
                    在这个方法中，我们看到了
                    c = Class.forName(logAdapterClassName, true, currentCL);
                    是取得该类型的反射类型对象

                    使用反射的形式帮我们创建logger对象
                    constructor = c.getConstructor(this.logConstructorSignature);



         */
        Log log = LogFactory.getLog(JCLTest01.class);

        log.info("info信息");

    }

}

```

