# 调试的概念

![](image/Pasted%20image%2020241213221733.png)
# 哪些适合调试

![](image/Pasted%20image%2020241213224338.png)
# 使用断点调试代码

## 理解断点含义和分类

![](image/Pasted%20image%2020241213224502.png)
## 代码

```java
/**
 * <h1>使用断点追踪代码执行过程</h1>
 * */
@SuppressWarnings("all")
public class UseBreakPoint {

    /**
     * <h2>第一种断点: 行断点</h2>
     * */
    private static void lineBreakPoint(String name) {
        // 行断点
        System.out.println(name);
    }

    // 第二种是临时断点, 与行断点几乎是一样的, 只需要勾选 Remove once hit 即可

    /**
     * <h2>第三种断点: 属性断点</h2>
     * */
    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    private static class FieldWatchPoint {

        // 属性断点
        private String name;

        /**
         * <h2>第四种断点: 方法断点</h2>
         * */
        public void printImoocPrefix() {
            System.out.println("imooc-" + this.name);
        }
    }

    private static class CustomException extends RuntimeException {}

    /**
     * <h2>第五种断点: 异常断点, 只能手动配置</h2>
     * */
    private static void exceptionBreakPoint() {

        try {
            throw new CustomException();
        } catch (CustomException ex) {
            ex.printStackTrace();
        }
    }

    public static void main(String[] args) {

        // 行断点
        lineBreakPoint("qinyi");

        // 属性断点
//        FieldWatchPoint watchPoint = new FieldWatchPoint();
//        watchPoint.setName("qinyi");
//        System.out.println(watchPoint);

        // 方法断点
//        FieldWatchPoint watchPoint = new FieldWatchPoint("qinyi");
//        watchPoint.printImoocPrefix();

        // 异常断点
//        exceptionBreakPoint();
    }
}
```

## 通过 Debug跟踪、计算、修改变量的值

![](image/Pasted%20image%2020241213230222.png)
# 远程 Debug Spring 工程

![](image/Pasted%20image%2020241213231043.png)

# 代码调试要注意的点

![](image/Pasted%20image%2020241213231445.png)

## 代码

```java
/**
 * <h1>代码调试要注意的点</h1>
 * */
@SuppressWarnings("all")
public class CodeDebugAttention {

    public static void main(String[] args) {

        // -------------------------------------------------------------------------------------------------------------
        // 1. 不要把复杂的逻辑写在一行代码中，分开去写
        String x = "qinyi";
        String y = "imooc";
        String z = "imooc-qinyi";

        // 这就是分开去写多个判断条件, 而不是把 three 写在一行里面
        boolean one = x.startsWith("qinyi") && y.startsWith("imooc");
        boolean two = x.endsWith("yi") && y.endsWith("ooc");
        boolean three = one && two && z.equalsIgnoreCase("imooc-qinyi");

        boolean result = one && two && three;
        // -------------------------------------------------------------------------------------------------------------
    }
}
```

# 学会解决显性问题

## 业务系统运维过程

![](image/Pasted%20image%2020241213231936.png)

# Java 线程堆栈

## 什么是线程堆栈

![](image/Pasted%20image%2020241214010303.png)

![](image/Pasted%20image%2020241214150132.png)

## 能解决什么问题

![](image/Pasted%20image%2020241214012154.png)

## 堆栈日志

![](image/Pasted%20image%2020241214150234.png)

## 获取运行时线程堆栈

```java
/**
 * <h1>获取运行时线程堆栈</h1>
 * */
public class GetThreadStack {

    public static void main(String[] args) {

        StringBuilder sb = new StringBuilder();
        Map<Thread, StackTraceElement[]> ts = Thread.getAllStackTraces();

        ts.keySet().forEach(thread -> {

            sb.append(thread.getName()).append(":").append(thread.getId()).append("\n");
            for (StackTraceElement ste : ts.get(thread)) {
                sb.append(ste).append("\n");
            }
            // 隔离开每一个线程
            sb.append("---------------------------------------------").append("\n");
        });

        System.out.println(sb.toString());
    }
}

```

## 线程状态分析

### JDK 定义的 6 中线程状态

![](image/Pasted%20image%2020241214013247.png)

### 线程状态转换

![](image/Pasted%20image%2020241214014646.png)

### 代码

```java
/**
 * <h1>打印线程状态</h1>
 * */
public class PrintThreadState {

    /**
     * <h2>New</h2>
     * */
    public static void newState() {

        System.out.println(new Thread().getState());
    }

    /**
     * <h2>RUNNABLE</h2>
     * (1) READY
     * (2) RUNNING
     * */
    public static void runnableState() throws Exception {

        Thread thread = new Thread(()-> {
            while (true){
            }
        });

        thread.start();
        System.out.println(thread.getState());
    }

    /**
     * <h2>BLOCKED</h2>
     * */
    public static void blockedState() throws Exception {

        Object MONITOR = new Object();

        Thread thread1 = new Thread(()-> {
            synchronized (MONITOR) {
                try {
                    Thread.sleep(Integer.MAX_VALUE);
                } catch (InterruptedException e) {
                }
            }
        });

        Thread thread2 = new Thread(()-> {
            synchronized (MONITOR) {}
        });

        thread1.start();
        Thread.sleep(100);

        thread2.start();
        Thread.sleep(100);

        System.out.println(thread2.getState());
    }

    /**
     * <h2>WAITING</h2>
     * */
    public static void waitingState() throws Exception {

        Thread thread = new Thread(()-> {
            LockSupport.park();
            while (true) {
            }
        });

        thread.start();
        Thread.sleep(100);
        System.out.println(thread.getState());  // 这里输出 WAITING

        LockSupport.unpark(thread);
        Thread.sleep(100);
        System.out.println(thread.getState());  // 这里输出 RUNNABLE
    }

    /**
     * <h2>TIMED_WAITING</h2>
     * */
    public static void timedwaitingState() throws Exception {

        Thread thread = new Thread(()-> {
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
            }
        });

        thread.start();
        Thread.sleep(100);
        System.out.println(thread.getState());
    }

    /**
     * <h2>TERMINATED</h2>
     * */
    public static void terminatedState() throws Exception {

        Thread thread = new Thread(() -> {});
        thread.start();

        Thread.sleep(100);
        System.out.println(thread.getState());
    }

    public static void main(String[] args) throws Exception {

//        newState();
//        runnableState();
//        blockedState();
        waitingState();
//        timedwaitingState();
//        terminatedState();
    }
}

```

## 通过分析堆栈解决死锁

### 死锁的定义和形成

![](image/Pasted%20image%2020241214130416.png)

### 死锁满足的四个条件

![](image/Pasted%20image%2020241214131549.png)

### 如何避免死锁

![](image/Pasted%20image%2020241214132505.png)

### 代码

```java
/**
 * <h1>通过线程堆栈日志定位并解决死锁问题</h1>
 * */
public class DeadLock {

    private static final Object obj1 = new Object();
    private static final Object obj2 = new Object();

    /**
     * <h2>死锁案例</h2>
     * */
    private static void deadLockExample() {

        final Object o1 = new Object();
        final Object o2 = new Object();

        Runnable r1 = () -> {

            synchronized (o1) {
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException ex) {
                    ex.printStackTrace();
                }
                synchronized (o2) {
                    System.out.println("R1 Done!");
                }
            }
        };

        Runnable r2 = () -> {

            synchronized (o2) {
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException ex) {
                    ex.printStackTrace();
                }
                synchronized (o1) {
                    System.out.println("R2 Done!");
                }
            }
        };

        new Thread(r1, "Thread1").start();
        new Thread(r2, "Thread2").start();
    }

    /**
     * <h2>以固定的顺序去获取锁</h2>
     * */
    private static void fixedOrderGetLock() {

        synchronized (obj1) {
            System.out.println(Thread.currentThread().getName() + " get lock obj1 success!");

            try {
                Thread.sleep(2000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }

            synchronized (obj2) {
                System.out.println(Thread.currentThread().getName() + " get lock obj2 cuccess!");
            }
        }
    }

    private static void hasNotDeadLockExample() {

        Runnable r1 = DeadLock::fixedOrderGetLock;
        Runnable r2 = DeadLock::fixedOrderGetLock;

        new Thread(r1, "Thread1").start();
        new Thread(r2, "Thread2").start();
    }

    public static void main(String[] args) {

//        deadLockExample();

        hasNotDeadLockExample();
    }
}

```

### 分析

```bash
jps 找到死锁的进程ID
jstack 分析线程状态
```

![](image/Pasted%20image%2020241214131259.png)

## 通过堆栈日志定位资源不足问题

### 资源不足造成的问题

![](image/Pasted%20image%2020241214133304.png) 

### 代码

```java
/**
 * <h1>使用线程堆栈日志定位资源不足问题</h1>
 * */
@Slf4j
@RestController
@RequestMapping("/insufficient")
public class InsufficientResourceController {

    /** 自定义线程池, 最好使能够给线程有意义的名字 */
    private final ExecutorService es = Executors.newCachedThreadPool(
            new BasicThreadFactory.Builder().namingPattern("Imooc-Qinyi-%d").build()
    );

    private final StringRedisTemplate redisTemplate;

    public InsufficientResourceController(StringRedisTemplate redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    @GetMapping("/{batch}")
    public DeferredResult<String> resource(@PathVariable int batch) {

        DeferredResult<String> result = new DeferredResult<>(10 * 1000L,
                "timeout");
        CompletableFuture[] futures = new CompletableFuture[batch];

        for (int i = 0; i != batch; ++i) {
            futures[i] = CompletableFuture.supplyAsync(this::getValue, es);
        }

        CompletableFuture.allOf(futures).thenRun(() -> result.setResult("success"));

        return result;
    }

    private String getValue() {

        try {
            return redisTemplate.execute((RedisCallback<String>) connection -> {
                sleep(5000);
                return "qinyi-" + connection;
            });
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        return "error";
    }

    private void sleep(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException ex) {
            ex.printStackTrace();
        }
    }
}

```

### 分析

- 通过分析线程状态，找到为什么资源不足，然后分析函数调用栈，确定原因就行

```bash
jps 查询到线程ID
jstack 线程ID > /tmp/java.log 因为数据太大了，转储成文件来分析
grep java.lang.Thread.State /tmp/java.log | awk '{print $2$3$4$5}' | sort | uniq -c 

```

![](image/Pasted%20image%2020241214142224.png)

### 如何解决资源不足

- 可以一次传输大量操作

![](image/Pasted%20image%2020241214141721.png)

## 通过堆栈日志分析存在大量 WAITING 线程

### 为什么线程会处于 WAITING

![](image/Pasted%20image%2020241214143312.png)

### 为什么会大量线程处于WAITING

![](image/Pasted%20image%2020241214145733.png)

### 代码

```java
/**
 * <h1>通过线程堆栈定位大量 Waiting 状态的线程</h1>
 * */
@SuppressWarnings("all")
public class VastWaitingThreads {

    private static List<Thread> createAndParkThreads(int threadCount) {

        List<Thread> threads = new ArrayList<>(threadCount);

        for (int i = 0; i != threadCount; ++i) {
            Thread thread = new Thread(() -> {
                while (true) {
                    // 挂起线程
                    LockSupport.park();
                    System.out.println(Thread.currentThread() + " was park!");
                }
            });

            thread.setName("QinyiThread-" + i);
            threads.add(thread);
            thread.start();
        }

        return threads;
    }

    /**
     * <h2>随机的 unpark 某个线程</h2>
     * */
    private static void randomUnparkThread(List<Thread> threads) {

        while (true) {

            Thread t = threads.get(new Random().nextInt(threads.size()));
            if (null != t) {
                LockSupport.unpark(t);
                System.out.println(t.getName() + " unpark!");
            }

            try {
                Thread.sleep(1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {

        randomUnparkThread(createAndParkThreads(500));
    }
}

```

### 分析

```bash
jps 查询到线程ID
jstack 线程ID > /tmp/java.log 因为数据太大了，转储成文件来分析
grep java.lang.Thread.State /tmp/java.log | awk '{print $2$3$4$5}' | sort | uniq -c 

```

![](image/Pasted%20image%2020241214145530.png)

# JVM 调优

## 什么是 JVM 调优

- 一般是其他的都优化好了再来 JVM 调优，代码优化不好调 JVM 也没用

![](image/Pasted%20image%2020241214150414.png)

## 什么时候做 JVM 调优

- 代码没办法继续做优化了
- 绝大部分工程基本都不需要

![](image/Pasted%20image%2020241214150559.png)

## 原则

![](image/Pasted%20image%2020241214150815.png)

## 目标

![](image/Pasted%20image%2020241214151002.png)

## 需要知道的 GC 算法和常用的垃圾收集器

### 对象存活分析

#### 引用计数法

![](image/Pasted%20image%2020241214151329.png)

#### 可达性分析

![](image/Pasted%20image%2020241214151436.png)
### GC 算法

#### 标记清除

![](image/Pasted%20image%2020241214151701.png)

#### 标记复制

![](image/Pasted%20image%2020241214151837.png)

#### 标记整理

![](image/Pasted%20image%2020241214151955.png)

### 常用的垃圾收集器

![](image/Pasted%20image%2020241214152148.png)

## JDK 工具

### jinfo

![](image/Pasted%20image%2020241214152346.png)

#### 代码

```java
/**
 * <h1>Java 系统属性</h1>
 * */
public class JavaSystemProperties {

    public static void main(String[] args) {

        // 打印所有的 Java 系统属性
        Properties pros = System.getProperties();
        pros.list(System.out);

        System.out.println("//////////////////////////////////////////////////////////////////");

        // 获取特定的 Java 系统属性, key 不存在则返回 null
        System.out.println(System.getProperty("java.home"));        // JRE 主目录
        System.out.println(System.getProperty("java.library.path"));        // 用于搜索本机库的 JRE 库搜索路径
        System.out.println(System.getProperty("java.ext.dirs"));        // JRE扩展库路径
        System.out.println(System.getProperty("java.class.path"));      // JRE类路径
        System.out.println(System.getProperty("java.version"));     // Java 版本
        System.out.println(System.getProperty("imooc-qinyi"));
    }
}
```

#### 使用

![](image/Pasted%20image%2020241214153949.png)

![](image/Pasted%20image%2020241214154104.png)

![](image/Pasted%20image%2020241214154141.png)

### jmap

![](image/Pasted%20image%2020241214154822.png)

### jstat

![](image/Pasted%20image%2020241214155844.png)

## 获取并分析 GC 日志

![](image/Pasted%20image%2020241214162232.png)

### 堆结构

![](image/Pasted%20image%2020241214162331.png)

 ### 代码

```java
/**
 * <h1>打印 GC 日志</h1>
 * -XX:NewSize=5M -XX:MaxNewSize=5M -XX:InitialHeapSize=10M -XX:MaxHeapSize=10M -XX:SurvivorRatio=8 -XX:PretenureSizeThreshold=10M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps
 * */
@SuppressWarnings("all")
public class PrintGCLog {

    private static void gc01() {

        byte[] x = new byte[1024 * 1024]; // 1024 * 1024 分配 1MB 空间
        x = new byte[1024 * 1024];
        x = new byte[1024 * 1024];
        x = null;

        byte[] y = new byte[2 * 1024 * 1024]; // 2 * 1024 * 1024 分配 2MB 空间
    }

    public static void main(String[] args) {

        gc01();
    }
}

```

# 调优实战

## 频繁的 Minor GC 和 Major GC

### 什么是 Minor GC 和 Major GC

![](image/Pasted%20image%2020241216184746.png)

### 会造成什么影响

![](image/Pasted%20image%2020241216185816.png)

### 代码

```java
/**
 * <h1>频繁的 Minor GC 和 Major GC</h1>
 * -XX:NewSize=5M -XX:MaxNewSize=5M -XX:InitialHeapSize=10M -XX:MaxHeapSize=10M -XX:SurvivorRatio=8 -XX:PretenureSizeThreshold=10M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps
 * -XX:NewSize=50M -XX:MaxNewSize=50M -XX:InitialHeapSize=100M -XX:MaxHeapSize=100M -XX:SurvivorRatio=8 -XX:PretenureSizeThreshold=10M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps
 *
 * 年轻代 = Eden + 2 Sur(From + To)
 * Eden 4MB
 * 2Sur 0.5 + 0.5 = 1MB
 * */
@SuppressWarnings("all")
public class MoreMinorGC {

    private static void minorGC() throws InterruptedException {

        byte[] x = new byte[1024 * 1024];   // 在 Eden 区域放入一个 1MB 的对象
        x = new byte[1024 * 1024];
        x = new byte[1024 * 1024];  // 会导致前两个 1MB 的对象成为垃圾对象
        x = null;   // 将之前的三个 1MB 的对象都变成垃圾对象

        // 这句代码就会触发年轻代的 Young GC
        byte[] y = new byte[2 * 1024 * 1024];   // 在 Eden 区中分配一个 2MB 的对象

        Thread.sleep(1000);
    }

    public static void main(String[] args) throws InterruptedException {

        while (true) {
            minorGC();
        }
    }
}

```

### 扩容年轻代的思考

![](image/Pasted%20image%2020241216191211.png)

## 频繁的 Full GC

### 造成的影响和出现的原因

![](image/Pasted%20image%2020241216192844.png)

### 代码

```java
/**
 * <h1>频繁的 Full GC</h1>
 * -Xms20M -Xmx20M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps
 * */
@SuppressWarnings("all")
public class MoreFullGC {

    @Data
    private static class Imoocer {

        private String name = "qinyi";
        private int age = 19;
        private String gender = "male";
        private LocalDate birthday = LocalDate.MAX;

        public void func() {
            //
        }
    }

    /** 线程池 */
    private static final ScheduledThreadPoolExecutor executor =
            new ScheduledThreadPoolExecutor(50,
                    new ThreadPoolExecutor.DiscardOldestPolicy());

    private static void processImoocers(List<Imoocer> imoocers) {
        imoocers.forEach(i -> executor.scheduleWithFixedDelay(
                i::func, 2, 3, TimeUnit.SECONDS
        ));
    }

    private static List<Imoocer> getAllImoocer(int count) {

        List<Imoocer> imoocers = new ArrayList<>(count);

        for (int i = 0; i != count; ++i) {
            imoocers.add(new Imoocer());
        }

        return imoocers;
    }

    public static void main(String[] args) throws InterruptedException {

        executor.setMaximumPoolSize(50);

        while (true) {
            processImoocers(getAllImoocer(100));
            Thread.sleep(100);
        }
    }
}

```

### 读懂 Full GC 的日志

![](image/Pasted%20image%2020241216211724.png)

#### Full GC Phase 1 : Initial Mark(CMS)

![](image/Pasted%20image%2020241216211432.png)
#### Full GC Phase 2 : Concurrent Mark(CMS)

![](image/Pasted%20image%2020241216212127.png)

#### Full GC Phase 3 : Concurrent Preclean(CMS)

![](image/Pasted%20image%2020241216212210.png)

#### Full GC Phase 4 : Abortable Preclean(CMS)

![](image/Pasted%20image%2020241216212348.png)

#### Full GC Phase 5 : Final ReMark(CMS)

![](image/Pasted%20image%2020241216212453.png)

#### Full GC Phase 6 : Concurrent Sweep(CMS)

![](image/Pasted%20image%2020241216212747.png)

#### Full GC Phase 7 : Concurrent Reset(CMS)

![](image/Pasted%20image%2020241216212841.png)

### 如何优化

![](image/Pasted%20image%2020241216212954.png)

# 学会解决隐性问题

## 学会分析 Java 线程堆栈

![](image/Pasted%20image%2020241216213205.png)

![](image/Pasted%20image%2020241216213237.png)
## 解决那些问题

![](image/Pasted%20image%2020241216213304.png)

![](image/Pasted%20image%2020241216213312.png)

![](image/Pasted%20image%2020241216213325.png)

## 理解并学会JVM调优

![](image/Pasted%20image%2020241216213550.png)

![](image/Pasted%20image%2020241216213654.png)

![](image/Pasted%20image%2020241216213712.png)

![](image/Pasted%20image%2020241216213722.png)