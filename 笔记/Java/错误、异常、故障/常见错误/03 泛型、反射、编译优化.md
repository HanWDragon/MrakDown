# 实现 Serializable 报错

## 序列化和反序列化

![](image/Pasted%20image%2020241211030342.png)

### 需要考虑的问题

1. 反序列化需要调用父类的无参构造，如果提供无参，可以序列化
2. 所有的属性可序列化，这个类才可序列化
3. 属性更新，不会重新序列化，不会重复序列化已序列化对象

![](image/Pasted%20image%2020241211030936.png)

## 代码

```java
/**
 * <h1>Java Object</h1>
 * */
@Setter
@Getter
@ToString
public class People implements Serializable {

    private Long id;

    public People() {}

    public People(Long id) {
        this.id = id;
    }
}

```

```java
/**
 * <h1>Java Object</h1>
 * */
@ToString
public class Worker extends People implements Serializable {

    private String name;
    private Integer age;

    public Worker(Long id, String name, Integer age) {
        super(id);
        this.name = name;
        this.age = age;
    }
}

```

```java
/**
 * <h1>类中存在引用对象</h1>
 * */
@Getter
@Setter
public class Combo implements Serializable {

    private int id;
    private People people;

    public Combo(int id, People people) {
        this.id = id;
        this.people = people;
    }
}

```

```java
/**
 * <h1>序列化和反序列化</h1>
 * */
@SuppressWarnings("all")
public class Main {

    /**
     * <h1>序列化和反序列化 People 对象</h1>
     * */
    private static void testSerializablePeople() throws Exception {

        // 序列化的步骤

        // 用于存储序列化的文件
        File file = new File("/tmp/people_10.java_");
        People p = new People(10L);

        // 创建一个输出流
        ObjectOutputStream oos = new ObjectOutputStream(
                new FileOutputStream(file)
        );
        // 输出可序列化对象
        oos.writeObject(p);
        // 关闭输出流
        oos.close();

        // 反序列化的步骤

        // 创建一个输入流
        ObjectInputStream ois = new ObjectInputStream(
                new FileInputStream(file)
        );
        // 得到反序列化的对象
        Object newPerson = ois.readObject();
        // 关闭输入流
        ois.close();

        System.out.println(newPerson);
    }

    /**
     * <h2>子类实现序列化, 父类不实现序列化</h2>
     * */
    private static void testSerizableWorker() throws Exception {

        File file = new File("/tmp/worker_10.java_");
        Worker p = new Worker(10L, "qinyi", 19);

        // 创建一个输出流
        ObjectOutputStream oos = new ObjectOutputStream(
                new FileOutputStream(file)
        );
        // 输出可序列化对象
        oos.writeObject(p);
        // 关闭输出流
        oos.close();

        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file));
        Object newWorker = ois.readObject();
        ois.close();
        System.out.println(newWorker);
    }

    private static void testSerializableCombo() throws Exception {

        File file = new File("/tmp/combo_10.java_");
        Combo p = new Combo(1, new People(10L));

        // 创建一个输出流
        ObjectOutputStream oos = new ObjectOutputStream(
                new FileOutputStream(file)
        );
        // 输出可序列化对象
        oos.writeObject(p);
        // 关闭输出流
        oos.close();

        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file));
        Object newCombo = ois.readObject();
        ois.close();
        System.out.println(newCombo);
    }

    /**
     * <h2>同一个对象多次序列化的问题, 坑</h2>
     * */
    private static void sameObjectRepeatedSerialization() throws Exception {

        File file = new File("/tmp/peopele_more.java_");
        People p = new People(10L);
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file));

        oos.writeObject(p);
        oos.writeObject(p);

        p.setId(20L);
        oos.writeObject(p);
        oos.close();

        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file));
        Object people1 = ois.readObject();
        Object people2 = ois.readObject();
        Object people3 = ois.readObject();
        ois.close();

        System.out.println(((People) people1).getId());
        System.out.println(((People) people2).getId());
        System.out.println(((People) people3).getId());
    }

    public static void main(String[] args) throws Exception {

//        testSerializablePeople();

//        testSerizableWorker();

//        testSerializableCombo();

        sameObjectRepeatedSerialization();
    }
}

```

# 泛型

- 不仅仅是规定集合中的类型那么简单

## 概念

![](image/Pasted%20image%2020241211032636.png)

## 特性

![](image/Pasted%20image%2020241211034238.png)

## 代码

```java
/**
 * <h1>理解泛型</h1>
 * */
@SuppressWarnings("all")
public class Genericity {

    /**
     * <h2>简单使用泛型</h2>
     * */
    private static void easyUse() throws Exception {

        List<String> left = new ArrayList<>();
        List<Integer> right = new ArrayList<>();

//        System.out.println(left.getClass());
//        System.out.println(left.getClass() == right.getClass());

//        if (left instanceof ArrayList<Double>) {}
//        if (left instanceof ArrayList) {
//
//        }
//
//        if (left instanceof ArrayList<?>) {}

        List<Integer> list = new ArrayList<>();
        list.add(1);
        list.getClass().getMethod("add", Object.class).invoke(list, "abcd");
        list.getClass().getMethod("add", Object.class).invoke(list, 1.2);

        for (int i = 0; i != list.size(); ++i) {
            System.out.println(list.get(i));
        }
    }

    /**
     * <h2>泛型是先检查再编译</h2>
     * */
    private static void checkAndCompile() {

        ArrayList<String> list = new ArrayList<>();
        list.add("1234");
//        list.add(123);
    }

    /**
     * <h2>泛型不支持继承</h2>
     * */
    private static void genericityCanNotExtend() {

        // 第一类错误
//        ArrayList<String> first = new ArrayList<Object>();
//
//        ArrayList<Object> list1 = new ArrayList<>();
//        list1.add(new Object());
//        ArrayList<String> list2 = list1;

        // 第二类错误
//        ArrayList<Object> second = new ArrayList<String>();
//
//        ArrayList<String> list1 = new ArrayList<>();
//        list1.add(new String());
//        ArrayList<Object> list2 = list1;
    }

    /**
     * <h2>泛型类型变量不能是基本数据类型</h2>
     * */
    private static void baseTypeCanNotUseGenericity() {

//        List<int> invalid = new ArrayList<>();
    }

    /**
     * <h2>泛型的类型参数只能是类类型, 不能是简单类型</h2>
     * */
    private static <T> void doSomething(T... values) {
        for (T value : values) {
            System.out.println(value);
        }
    }

    public static void main(String[] args) throws Exception {

//        easyUse();

        Integer[] ints1 = new Integer[]{1, 2, 3};
        int[] ints2 = new int[]{1, 2, 3};

        doSomething(ints1);
        System.out.println("----------------");
        doSomething(ints2);
    }
}

```

# 原始类型

## 可用场景和坑

![](image/Pasted%20image%2020241211035442.png)

## 优化建议

![](image/Pasted%20image%2020241211042827.png)

## 代码

```java
/**
 * <h1>不要使用原始类型</h1>
 * */
@SuppressWarnings("all")
public class DoNotUseRawType {

    /**
     * <h2>简单使用原始类型</h2>
     * */
    private static void simpleExample() {

        List data = new ArrayList();
        data.add("qinyi");
        data.add(19);
        data.add("Hello Imooc");

//        data.forEach(System.out::println);
//
//        data.forEach(d -> {
//
//            if (((String) d).equals("Hello Imooc")) {
//                System.out.println(data.indexOf(d));
//            }
//
//        });

        data.forEach(d -> {

            if (d instanceof String && ((String) d).equals("Hello Imooc")) {
                System.out.println(data.indexOf(d));
            }

        });
    }

    /**
     * <h2>优化使用原始类型</h2>
     * */
    private static void optimizeUse() {

//        List<Object> data = new ArrayList();
//        data.add("qinyi");
//        data.add(19);
//        data.add("Hello Imooc");
//
//        data.forEach(System.out::println);

        List<People> data = new ArrayList<>();
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    private static class People {

        private String name;
        private Integer age;
        private String signature;
    }

    public static void main(String[] args) {

        simpleExample();
    }
}

```

# 反射

## 介绍

![](image/Pasted%20image%2020241211043128.png)

## 类加载过程

![](image/Pasted%20image%2020241211043453.png)

## Method 类

![](image/Pasted%20image%2020241211043927.png)
## 什么场景获取不到 Method

![](image/Pasted%20image%2020241211044122.png)

## 代码

```java
/**
 * <h1>People 对象</h1>
 * */
public class People {

    public String people(String hello) {
        return People.class.getName() + ": " + hello;
    }
}
```

```java
/**
 * <h1>继承自 People 的 Worker 对象</h1>
 * */
public class Worker extends People {

    public String worker(String hello) {
        return Worker.class.getName() + ": " + hello;
    }
}

```

```java
/**
 * <h1>继承自 Worker 的 Boss 对象</h1>
 * */
public class Boss extends Worker {

    public String boss(String hello) {
        return Boss.class.getName() + ": " + hello;
    }

    public String numeric(int age) {
        return Boss.class.getName() + ": " + age;
    }
}

```

```java
/**
 * <h1>Java 中的反射机制</h1>
 * */
public class Main {

    /**
     * <h2>方法的参数是基本类型，反射获取 Method 参数类型必须一致</h2>
     * */
    private static void reflectDeclaredMethod() throws Exception {

        Class<Boss> clz = Boss.class;
        Method[] methods = clz.getDeclaredMethods();

//        Method method = clz.getDeclaredMethod("numeric", int.class);
        Method method = clz.getDeclaredMethod("numeric", Integer.TYPE);
        System.out.println(method.invoke(clz.newInstance(), 19));
    }

    /**
     * <h2>调用的方法属于对象的父类, getDeclaredMethod 会抛出异常</h2>
     * */
    private static void reflectAcquireClassMethod() throws Exception {

        Class<Boss> clz = Boss.class;
//        Method method = clz.getDeclaredMethod("boss", String.class);
//        Method method = clz.getDeclaredMethod("worker", String.class);

        Method superMethod = getMethod(clz, "worker",
                new Class[]{String.class});
        if (superMethod != null) {
            System.out.println(superMethod.invoke(clz.newInstance(), "boss"));
        }
    }

    private static Method getMethod(Class<?> target, String methodName,
                                    Class<?>[] argTypes) {

        Method method = null;

        try {
            method = target.getDeclaredMethod(methodName, argTypes);
            method.setAccessible(true);
        } catch (NoSuchMethodException ex) {
            System.out.println("can not get method: " + methodName + " from "
                    + target.getName());
        }
        if (method == null && target != Object.class) {
            return getMethod(target.getSuperclass(), methodName, argTypes);
        }

        return method;
    }

    public static void main(String[] args) throws Exception {

//        reflectDeclaredMethod();

        reflectAcquireClassMethod();
    }
}

```

# StringBuilder

## 使用 + 会有性能损失？

- 大多数情况下，基本都会有编译器优化
- 但是大多数只会有简单的编译优化在 implicitUseStringBuilder 方法中，通过反编译就看到每一次 for 循环，都创建了 StringBuilder 对象

![](image/Pasted%20image%2020241211051458.png)

## StringBuffer and StringBuilder

![](image/Pasted%20image%2020241211052121.png)
## 代码

```java
/**
 * <h1>字符串拼接</h1>
 * */
public class StringContact {

    private static void easyContact() {

        String userName = "Qinyi";
        String age = "19";
        String job = "Developer";

        String info = userName + age + job;
        System.out.println(info);
    }

    private static void implicitUseStringBuilder(String[] values) {
        String result = "";

        for (int i = 0; i < values.length; ++i) {
            result += values[i];
        }

        System.out.println(result);
    }

    private static void explicitUseStringBuilder(String[] values) {

        StringBuilder result = new StringBuilder();
        for (int i = 0; i < values.length; ++i) {
            result.append(values[i]);
        }

        System.out.println(result.toString());
    }

    public static void main(String[] args) {

        easyContact();
    }
}

```

# 深浅拷贝

## 介绍

![](image/Pasted%20image%2020241211052323.png)

## Cloneable 接口

![](image/Pasted%20image%2020241211052447.png)

## 如何实现深拷贝

1. 修改 clone 方法，重新 new 对象
2. 修改 clone 方法，将所有的引用对象都调用 clone 方法，这样也可以深拷贝
3. 序列化的方式，深拷贝

## 代码

```java
/**
 * <h1>教育信息</h1>
 * */
@Data
@AllArgsConstructor
public class EducationInfo implements /*Cloneable*/ Serializable {

    private String school;

    private String time;

    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}

```

```java
/**
 * <h1>员工</h1>
 * */
@Data
public class Worker implements /*Cloneable*/ Serializable {

    private String name;
    private Integer age;
    private String gender;

    private EducationInfo educationInfo;

    public Worker(String name, Integer age, String gender, String school, String time) {
        this.name = name;
        this.age = age;
        this.gender = gender;
        this.educationInfo = new EducationInfo(school, time);
    }

//    @Override
//    public Object clone() {
//
//        try {
//            return super.clone();
//        } catch (CloneNotSupportedException e) {
//            return null;
//        }
//    }

//    @Override
//    public Object clone() {
//
//        // 第一种方式
////        Worker worker = new Worker(
////                name, age, gender, educationInfo.getSchool(), educationInfo.getTime()
////        );
////        return worker;
//
//        // 第二种方式
//        try {
//            Worker worker = (Worker) super.clone();
//            worker.educationInfo = (EducationInfo) educationInfo.clone();
//            return worker;
//        } catch (CloneNotSupportedException ex) {
//            return null;
//        }
//    }

    public Worker clone() {

        Worker worker = null;

        try {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(baos);
            oos.writeObject(this);

            // 将流序列化成对象
            ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
            ObjectInputStream ois = new ObjectInputStream(bais);
            worker = (Worker) ois.readObject();
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }

        return worker;
    }
}
```

```java
/**
 * <h1>理解深拷贝和浅拷贝</h1>
 * */
@SuppressWarnings("all")
public class Main {

    private static void canNotClone() throws CloneNotSupportedException {

        Main main = new Main();
        Object cloned = main.clone();
    }

    private static void copyTest() {

        Worker worker1 = new Worker(
                "qinyi", 19, "m", "大连理工大学", "2000"
        );
        System.out.println("原始对象: " + worker1.getEducationInfo().getSchool());

        Worker worker2 = (Worker) worker1.clone();
        System.out.println("拷贝对象: " + worker2.getEducationInfo().getSchool());

        worker2.getEducationInfo().setSchool("同济大学");

        System.out.println("原始对象: " + worker1.getEducationInfo().getSchool());
        System.out.println("拷贝对象: " + worker2.getEducationInfo().getSchool());
    }

    public static void main(String[] args) throws CloneNotSupportedException {

//        canNotClone();

        copyTest();
    }
}

```