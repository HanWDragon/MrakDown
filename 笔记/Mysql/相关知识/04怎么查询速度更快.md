# 示例数据的安装

## Sakila-db

![](image/Pasted%20image%2020220303205829.png)

# WHERE查询太慢，如何解决

## 覆盖索引

 ![](image/Pasted%20image%2020220303210759.png)

 ![](image/Pasted%20image%2020220303210851.png)

```mysql
CREATE TABLE `inventory` (
  `inventory_id` mediumint unsigned NOT NULL AUTO_INCREMENT,
  `film_id` smallint unsigned NOT NULL,
  `store_id` tinyint unsigned NOT NULL,
  `last_update` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`inventory_id`),
  KEY `idx_fk_film_id` (`film_id`),
  KEY `idx_store_id_film_id` (`store_id`,`film_id`), # <- 干掉这个联合索引 
  CONSTRAINT `fk_inventory_film` FOREIGN KEY (`film_id`) REFERENCES `film` (`film_id`) ON DELETE RESTRICT ON UPDATE CASCADE,
  CONSTRAINT `fk_inventory_store` FOREIGN KEY (`store_id`) REFERENCES `store` (`store_id`) ON DELETE RESTRICT ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=4582 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
```

```mysql
CREATE TABLE `inventory_1` (
  `inventory_id` mediumint unsigned NOT NULL AUTO_INCREMENT,
  `film_id` smallint unsigned NOT NULL,
  `store_id` tinyint unsigned NOT NULL,
  `last_update` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`inventory_id`),
  KEY `idx_fk_film_id` (`film_id`),
) ENGINE=InnoDB AUTO_INCREMENT=4582 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
```

使用的语句

```mysql
INSERT INTO inventory_1 SELECT * FROM inventory;
```

这样就得到了两者数据一模一样的表，但是新建的表没有联合索引

### 查询以下数据

![](image/Pasted%20image%2020220303212141.png)
#### 分析结果

对于第一个查询，我们通过执行 `explain` 来查看使用到的索引，得到以下结果，我们发现没有使用到任何索引

![](image/Pasted%20image%2020220303212359.png)

对于第二个查询，我们通过执行 `explain` 来查看使用到的索引，得到以下结果，我们发现使用到了索引，`Using index` 在查询计划中就叫**索引覆盖**，这样就避免了数据回表

![](image/Pasted%20image%2020220303212544.png)

我们来分别查看两张表的索引，因此在进行刚刚的查找的时候，有联合索引的 `inventory`，在执行刚刚的SQL语句就不需要回表，这就叫索引覆盖。

![](image/Pasted%20image%2020220303213024.png)

![](image/Pasted%20image%2020220303213046.png)

### 查询以下语句

![](image/Pasted%20image%2020220303214427.png)

#### 分析结果

通过 Using index 我们可以知道得到结果不用回表查询，走了索引覆盖。

```mysql
EXPLAIN
SELECT
	inventory_id,
	store_id,
	film_id
FROM
	sakila.inventory
WHERE
	store_id = 1;
```

![](image/Pasted%20image%2020220303214758.png)

我们看到 `Extra` 是 `NULL` ，进行了回表操作，但是在联合索引中没有  `last_update` 的信息，所以需要回表，在主索引中找到 `last_update` 的信息，完成查询，这条语句很浪费时间，所以不需要 `last_update` 这个信息，就避免使用。

```mysql
EXPLAIN
SELECT
	inventory_id,
	store_id,
	film_id,
	last_update
FROM
	sakila.inventory
WHERE
	store_id = 1;
```

![](image/Pasted%20image%2020220303215622.png)

## 总结

![](image/Pasted%20image%2020220303220550.png)


# 有更合适的索引不走，如何解决

## 如何确定用哪条索引

![](image/Pasted%20image%2020220304182036.png)

## 基数的应用

- 使用以下SQL建立测试表
```mysql
CREATE TABLE sakila.city_1 ( city VARCHAR ( 50 ) NOT NULL );
INSERT INTO sakila.city_1 SELECT
city 
FROM
	sakila.city;
INSERT INTO sakila.city_1 SELECT
city 
FROM
	sakila.city;
INSERT INTO sakila.city_1 SELECT
city 
FROM
	sakila.city;
INSERT INTO sakila.city_1 SELECT
city 
FROM
	sakila.city;
INSERT INTO sakila.city_1 SELECT
city 
FROM
	sakila.city;
UPDATE sakila.city_1 
SET city = ( SELECT city FROM sakila.city ORDER BY RAND() LIMIT 1 );
```

- 增加以下前缀索引
```mysql
ALTER TABLE sakila.city_1 ADD KEY (
city ( 1 ));
ALTER TABLE sakila.city_1 ADD KEY (
city ( 2 ));
ALTER TABLE sakila.city_1 ADD KEY (
city ( 3 ));
ALTER TABLE sakila.city_1 ADD KEY (
city ( 4 ));
ALTER TABLE sakila.city_1 ADD KEY (
city ( 5 ));
ALTER TABLE sakila.city_1 ADD KEY (
city ( 6 ));
ALTER TABLE sakila.city_1 ADD KEY (
city ( 7 ));
ALTER TABLE sakila.city_1 ADD KEY (
city ( 8 ));
```

-  查看各索引的基数
```mysql
SHOW INDEX FROM city_1; 
```

![](image/Pasted%20image%2020220304185201.png)

我们可以看到下面的区分度，意思就是说：按城市名的第一个字母去搜索，我们能有 26 种可能，以此类推。

![](image/Pasted%20image%2020220304185235.png)

MySQL选择索引的时候会可能选择区分度尽可能大的索引，但是MySQL是随机抽样来评估基数，所以可能会不常准。

## 强制使用索引

![](image/Pasted%20image%2020220304185846.png)

## 优化索引

![](image/Pasted%20image%2020220304185913.png)

## 总结 

![](image/Pasted%20image%2020220304190100.png)

# COUNT这么慢，如何解决

## COUNT() 函数

![](image/Pasted%20image%2020220304192908.png)

### COUNT（非索引字段）

![](image/Pasted%20image%2020220304194219.png)

```mysql
SHOW INDEX
FROM
	customer;
```

![](image/Pasted%20image%2020220304193250.png)

- 执行下面的语句
```mysql
SELECT
	COUNT(first_name)
FROM
	customer;
```

我们可以看到 `possible_keys` 和 `Extra` 都为空，所以进行的是全表扫描，所以效率有问题

![](image/Pasted%20image%2020220304193805.png)

### COUNT（索引字段）

![](image/Pasted%20image%2020220304194828.png)

```mysql
EXPLAIN
SELECT
	COUNT(last_name)
FROM
	customer;
```

我么可以看到走了索引，进行了索引覆盖

![](image/Pasted%20image%2020220304194543.png)

### COUNT（1）

![](image/Pasted%20image%2020220304203537.png)

```mysql
EXPLAIN
SELECT
	COUNT(1)
FROM
	customer;
```

![](image/Pasted%20image%2020220304203449.png)

### COUNT（ * ）

![](image/Pasted%20image%2020220304204451.png)

## 总结

![](image/Pasted%20image%2020220304204643.png)

# ORDER BY 这么慢，如何解决

## ORDER BY 步骤原理

我们看下面的SQL

```mysql
SELECT
	*
FROM
	'film'
WHERE
	film_id > 80
ORDER BY
	title;
```

![](image/Pasted%20image%2020220304205850.png)

### 条件查询

![](image/Pasted%20image%2020220304210112.png)

### 中间结果集

![](image/Pasted%20image%2020220304210341.png)

### 回表生成完整结果集

![](image/Pasted%20image%2020220304210623.png)

### 最高效-索引覆盖

![](image/Pasted%20image%2020220304213437.png)

## 总结

![](image/Pasted%20image%2020220304213923.png)

# 随机选取慢，如何解决

## ORDER BY RAND() 原理

看下面的SQL语句

```mysql
SELECT
	title,
	description
FROM
	film
ORDER BY
	RAND()
LIMIT 1;
```

![](image/Pasted%20image%2020220304220134.png)

![](image/Pasted%20image%2020220304220309.png)

![](image/Pasted%20image%2020220304220347.png)

![](image/Pasted%20image%2020220304220755.png)

![](image/Pasted%20image%2020220305085337.png)

## 为什么慢

![](image/Pasted%20image%2020220305085747.png)

## 解决方法

### 临时方法

在我们不想修改业务逻辑的情况下，就修改SQL语句，但是这个SQL语句有点复杂，不利于排查，和查找Bug

```mysql
SELECT MAX(film_id),min(film_id) INTO @m , @n from film;
set @x = FLOOR((@m - @n + 1)* RAND() + @n);
SELECT
	title,
	description
FROM
	film
WHERE
	film_id >= @x
LIMIT 1; 
```

### 业务方法

![](image/Pasted%20image%2020220305091134.png)

```mysql
SELECT
	title,
	descriptio n
FROM
	film
LIMIT r,
1;
```

## 总结

![](image/Pasted%20image%2020220305093542.png)

# 带头大哥丢了，如何解决

## 索引下推

- 用下列方式建表
```mysql
CREATE TABLE `inventory_2` (
  `inventory_id` mediumint unsigned NOT NULL AUTO_INCREMENT,
  `film_id` smallint unsigned NOT NULL,
  `store_id` tinyint unsigned NOT NULL,
  `last_update` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`inventory_id`),
  KEY `idx_store_id_film_id` (`store_id`,`film_id`)
  ) ENGINE=InnoDB AUTO_INCREMENT=4582 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
```

```mysql
INSERT INTO inventory_2
SELECT
	*
FROM
	inventory;
```

- 查看下面的SQL语句
```mysql
SELECT
	*
FROM
	inventory_2
WHERE
	store_id IN(1, 2)
	AND film_id = 3;
```

我们可以发现，这个语句在没有联合索引情况下，就像在下图中因为我们在SQL中我们使用了 in 在这种情况下，是需要回表查询的，我的 `store_id IN(1, 2)` 把前四条选出来了，但是并不知道对应的 `film_id` 但是,通过找到主键，再去回表查询，所以需要回表 4 次，但是之前建表使用的联合索引包括 `store_id 和 file_id` 所以不需要只需要在当前的辅助索查找，得到对应的主键，回表解析全部数据，只需要回表 1 次就行，这就叫索引下推。 

![](image/Pasted%20image%2020220305102245.png)

```mysql
EXPLAIN
SELECT
	*
FROM
	inventory_2
WHERE
	store_id IN(1, 2)
	AND film_id = 3;
```

看到 `rows` 就只有 5 行，`Extra` 使用的是 `Using index condition`

![](image/Pasted%20image%2020220305123104.png)

![](image/Pasted%20image%2020220305122617.png)

## 松散索引扫描

- 查看下面的SQL语句
```mysql
SELECT
	film_id
FROM
	inventory_2
WHERE
	film_id = 3;
```

我们发现，查询的 `film_id` 在辅助索引的第二个位置，并不是老大 `store_id` ,我们看看查询了多少行

```mysql
EXPLAIN
SELECT
	film_id
FROM
	inventory_2
WHERE
	film_id = 3;
```

![](image/Pasted%20image%2020220305123945.png)

![](image/Pasted%20image%2020220305125826.png)

```mysql
SELECT COUNT(*) from inventory_2;
```

![](image/Pasted%20image%2020220305124030.png)

我们可以通过上面的第一个图片看到这个进行了全表扫描，这个效率十分低下，但是第二张图执行的是同一个SQL语句，那为什么有这么大的差异这个就是MySQL的新特性，松散索引扫描，或者是跳跃索引扫描，这样就能减少扫描行数。

![](image/Pasted%20image%2020220305124334.png)

同样的SQL语句，但是耗时不一样，用下面的图片举例子，下面的表，索引是经过排序的，就可以在查找的过程中，跳过一些数据，过程大概是这样的，首先在 `store_id` 中找到相同的，再去查找 `film_id` 如果查询到某个数值大于 3 ，就代表后面不用查询了，可以到下一个 `store_id` 来查询，这样就让全表扫描变成了部份扫描。

![](image/Pasted%20image%2020220305125043.png)

## 总结

![](image/Pasted%20image%2020220305125751.png)

# 有索引不走，如何解决

## 尝试一下这个SQL
```mysql
SELECT
	film_id
FROM
	film
WHERE
	film_id + 1 = 100;
```

```mysql
EXPLAIN
SELECT
	film_id
FROM
	film
WHERE
	film_id + 1 = 100;
```

![](image/Pasted%20image%2020220305165116.png)

![](image/Pasted%20image%2020220305165148.png)

这些图片说明了为了执行这个SQL语句，执行的是全表扫描，效率低下，虽然 `film_id` 是主键，但是我们对主键进行了函数操作，所以没走索引。

![](image/Pasted%20image%2020220305165542.png)

## 时间函数

```mysql
SELECT
	*
FROM
	rental
WHERE
	MONTH(rental_date) = 5;
```

```mysql
SHOW INDEX
FROM
	rental
```

![](image/Pasted%20image%2020220305165936.png)

我们可以看到一个联合索引，说明 `rental_data` 可以当成索引

```mysql
EXPLAIN
SELECT
	*
FROM
	rental
WHERE
	MONTH(rental_date) = 5;
```

![](image/Pasted%20image%2020220305170112.png)

但是我们查看这个语句如何执行的时候，却发现索引失效了，进行的是全表扫描，也就是使用了函数，没有办法使用索引

![](image/Pasted%20image%2020220305170332.png)

解决方法就是不使用函数，虽然这样会让SQL语句变长，但是想提高效率，因为走了索引。

```mysql
SELECT
	*
FROM
	rental
WHERE
	rental_date BETWEEN '2005-5-1'
	AND '2005-6-1'
	OR rental_date BETWEEN '2006-5-1'
	AND '2006-6-1';
```

我们查看背后如何执行的，发现进行了索引覆盖，提高了效率，涉及到时间的SQL语句就是很难优化

![](image/Pasted%20image%2020220305174428.png)

## 字符串与数字比较

![](image/Pasted%20image%2020220305184310.png)

![](image/Pasted%20image%2020220305184336.png)

```mysql
CREATE TABLE t1 (
	f1 VARCHAR(32) NOT NULL,
	f2 int NOT NULL,
	KEY idx_f1 (f1),
	KEY idx_f2 (f2)) ENGINE = innoDB DEFAULT CHARSET = utf8mb4;
```

## 隐式字符编码转换

![](image/Pasted%20image%2020220305184920.png)

```mysql
CREATE TABLE t2 (
	f1 VARCHAR(32) NOT NULL,
	f2 int NOT NULL,
	KEY idx_f1 (f1),
	KEY idx_f2 (f2)) ENGINE = innoDB DEFAULT CHARSET = utf8;
```

```mysql
SELECT
	t2.*
FROM
	t1,
	t2
WHERE
	t1.f1 = t2.f1
	AND t1.f2 = 6;
```

![](image/Pasted%20image%2020220305190912.png)

```mysql
EXPLAIN
SELECT
	t2.*
FROM
	t1,
	t2
WHERE
	t1.f1 = t2.f1
	AND t1.f2 = 6;
```

![](image/Pasted%20image%2020220305191057.png)

我们发现在 `t2` 这张表进行的是全表扫描，那为什么没有走索引呢，很疑惑，原来是我们在建表的时候这两张表的字符编码不一样

![](image/Pasted%20image%2020220305191807.png)

```mysql
SELECT
	t2.*
FROM
	t1,
	t2
WHERE
	t1.f1 = CONVERT(t2.f1 USING utf8mb4)
	AND t1.f2 = 6;
```

![](image/Pasted%20image%2020220305191937.png)

```mysql
SELECT
	t2.*
FROM
	t1,
	t2
WHERE
	CONVERT(t1.f1
		USING utf8) = t2.f1
	AND t1.f2 = 6;
```

![](image/Pasted%20image%2020220305192133.png)

对应的数据

![](image/Pasted%20image%2020220305190820.png)

## 总结

![](image/Pasted%20image%2020220305192312.png)

# 分页查询慢，如何解决

## 偏移量大时，效率低

```mysql
SELECT
	film_id,
	title,
	description
FROM
	film
ORDER BY
	title
LIMIT 900,
10;
```

## 优化思路

![](image/Pasted%20image%2020220305224710.png)

我们先来看看索引情况

![](image/Pasted%20image%2020220305223938%201.png)

也就是我们可以使用 `title` 来辅助我们查询，也就是说我们现在已经有了 `film_id` 和 `title` 的信息有下面几种思路

1. 我们可以修改辅助索引，变成 `title` 和 `description` 的聚合索引，这样就避免了回表，进行了索引覆盖，但是在公司通常一个表设计好了基本就不会改变结构了。
2. 我们知道索引都是预排序好的，那么知道对应位置的 `title` 很简单，到时候在回表合并数据就完成了。

## 优化SQL语句

- 得到所需数据的主键
```mysql
SELECT
	film_id
FROM
	film
ORDER BY
	title
LIMIT 900,
10;
```

查看查询的过程

![](image/Pasted%20image%2020220305225452.png)

- 原表与上面的结果联表，获取最终结果
```mysql
SELECT
	f.film_id,
	f.title,
	f.description
FROM
	film AS f
	INNER JOIN (
		SELECT
			film_id
		FROM
			film
		ORDER BY
			title
		LIMIT 900,
		10) AS m ON f.film_id = m.film_id;
```

查看查询结果

![](image/Pasted%20image%2020220305230314.png)

## 总结

![](image/Pasted%20image%2020220305230421.png)

# 本章小节

## 慢查询的怀疑方向

![](image/Pasted%20image%2020220305235757.png)

## 覆盖索引

![](image/Pasted%20image%2020220306000049.png)

## 索引基数

![](image/Pasted%20image%2020220306000131.png)

## COUNT() 函数

![](image/Pasted%20image%2020220306000223.png)

## ORDER BY

![](image/Pasted%20image%2020220306000256.png)

## 随机选取

![](image/Pasted%20image%2020220306000425.png)

## 索引下推

![](image/Pasted%20image%2020220306000504.png)

## 松散索引扫描

 ![](image/Pasted%20image%2020220306000557.png)

 ## 字段做函数操作

 ![](image/Pasted%20image%2020220306000620.png)

 ## 分页查询

 ![](image/Pasted%20image%2020220306000647.png)