# 数值计算

## 用于精确计算 BigDecimal

![](image/Pasted%20image%2020241210060736.png)

## 代码

```java
/**
 * <h1>数值计算</h1>
 * */
@SuppressWarnings("all")
public class NumberAndTime {

    /**
     * <h2>scale 需要与小数位匹配</h2>
     * */
    private static void scaleProblem() {

        BigDecimal decimal = new BigDecimal("12.222");
//        BigDecimal result = decimal.setScale(12);
//        System.out.println(result);

        BigDecimal result = decimal.setScale(2, BigDecimal.ROUND_HALF_UP);
        System.out.println(result);
    }

    /**
     * <h2>BigDecimal 做除法时出现除不尽的情况</h2>
     * */
    private static void divideProblem() {

//        System.out.println(new BigDecimal(30).divide(new BigDecimal(7)));
        System.out.println(
                new BigDecimal(30).divide(new BigDecimal(7), 2,
                        BigDecimal.ROUND_HALF_UP)
        );
    }

    /**
     * <h2>精度问题导致比较结果和预期的不一致</h2>
     * */
    private static void equalProblem() {

        BigDecimal bd1 = new BigDecimal("0");
        BigDecimal bd2 = new BigDecimal("0.0");

        System.out.println(bd1.equals(bd2));
        System.out.println(bd1.compareTo(bd2) == 0);
    }

    public static void main(String[] args) throws Exception {

//        scaleProblem();
//        divideProblem();
        equalProblem();

    }
}

```

# 日期计算

## SimpleDateFormat 常见坑

![](image/Pasted%20image%2020241210062042.png)

## 代码

```java
/**
 * <h1>时间计算</h1>
 * */
@SuppressWarnings("all")
public class NumberAndTime {
    /**
     * <h2>SimpleDateFormat 可以解析大于/等于它定义的时间精度</h2>
     * */
    private static void formatPrecision() throws Exception {

        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");

        String time_x = "2020-03-01 10:00:00";
        String time = "2020-03";

        System.out.println(sdf.parse(time_x));
        System.out.println(sdf.parse(time));
    }

    /**
     * <h2>SimplleDateFormat 存在线程安全问题</h2>
     * */
    private static void threadSafety() {

        SimpleDateFormat sdf = new SimpleDateFormat(
                "yyyy-MM-dd HH:mm:ss");

        ThreadPoolExecutor threadPoolExecutor =
                new ThreadPoolExecutor(
                10, 100, 1, TimeUnit.MINUTES,
                new LinkedBlockingDeque<>(1000)
        );

        while (true) {

            threadPoolExecutor.execute(() -> {
                String dateString = "2020-03-01 10:00:00";
                try {
                    Date parseDate = sdf.parse(dateString);
                    String dateString2 = sdf.format(parseDate);
                    System.out.println(dateString.equals(dateString2));
                } catch (ParseException ex) {
                    ex.printStackTrace();
                }
            });

        }
    }

    public static void main(String[] args) throws Exception {

//        formatPrecision();
        threadSafety();
    }
}

```

# For 循环和集合

## 传统的 For 循环

![](image/Pasted%20image%2020241211000747.png)

## 存在哪些问题

![](image/Pasted%20image%2020241211000741.png)

## 使用 Foreach 优于 for

![](image/Pasted%20image%2020241211002252.png)

## 代码

```java
/**
 * <h1>小小 for 循环, 沾上集合出大问题</h1>
 * */
@SuppressWarnings("all")
public class ForeachOptimize {

    private static Collection<Integer> left =
            Arrays.asList(1, 2, 3, 4, 5, 6, 7);
    private static Collection<Integer> right =
            Arrays.asList(1, 2, 3, 4, 5);

    /**
     * <h2>集合迭代经常犯的错误</h2>
     * */
    private static void wrongIterator() {

//        // 传统方式 - 使用索引
//        int[] xyz = new int[]{1, 2, 3, 4, 5};
//        for (int i = 0; i != xyz.length; ++i) {
//            System.out.println(xyz[i]);
//        }
//
//        // 传统方式 - 迭代器
//        for (Iterator<Integer> i = left.iterator(); i.hasNext(); ) {
//            System.out.println(i.next());
//        }

        // 嵌套迭代容易出现问题
//        for (Iterator<Integer> l = left.iterator(); l.hasNext(); ) {
//            for (Iterator<Integer> r = right.iterator(); r.hasNext(); ) {
//                System.out.println(l.next() * r.next());
//            }
//        }

        // 正确的用法, 嵌套迭代
//        for (Iterator<Integer> l = left.iterator(); l.hasNext(); ) {
//            Integer tmp = l.next();
//            for (Iterator<Integer> r = right.iterator(); r.hasNext(); ) {
//                System.out.println(tmp * r.next());
//            }
//        }

        for (Integer l : left) {
            for (Integer r : right) {
                System.out.println(l * r);
            }
        }
    }

    private static void square(int value) {
        System.out.println(value * value);
    }

    public static void main(String[] args) {

        wrongIterator();

        // Java8 Iterable.forEach vs for-each
        for (Integer l : left) {
            square(l);
        }

        left.forEach(l -> square(l));
        left.forEach(ForeachOptimize::square);
    }
}

```

# 集合判等

## Object 的 Equals 和 hashcode 方法

![](image/Pasted%20image%2020241211004449.png)

## 集合中元素的索引与 equals 有关

![](image/Pasted%20image%2020241211004530.png)

## 代码

```java
/**
 * <h1>如果不好好判等, 集合存储就会乱套</h1>
 * */
public class EqualOrElse {

    public static class User implements Comparable<User> {

        private String name;
        private Integer age;

        public User() {}

        public User(String name, Integer age) {
            this.name = name;
            this.age = age;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public Integer getAge() {
            return age;
        }

        public void setAge(Integer age) {
            this.age = age;
        }

        @Override
        public boolean equals(Object obj) {

            if (obj instanceof User) {
                User user = (User) obj;
                return this.name.equals(user.name) && this.age == user.age;
            }

            return false;
        }

        @Override
        public int hashCode() {

            int result = name.hashCode();
            result = 31 * result + age;

            return result;
        }

        @Override
        public int compareTo(User o) {
            return (this.age - o.age) + this.name.compareTo(o.name);
        }
    }

    /**
     * <h2>实现/不实现 equals 方法和 hashcode 对于判等的影响</h2>
     * */
    private static void equalsAndHashcode() {

        User user1 = new User("qinyi", 19);
        User user2 = new User("qinyi", 19);

//        System.out.println(user1.equals(user2));

        Set<User> userSet = new HashSet<>();
        userSet.add(user1);
        userSet.add(user2);

        Map<User, Integer> userIntegerMap = new HashMap<>();
        userIntegerMap.put(user1, 0);
        userIntegerMap.put(user2, 0);

        System.out.println(userSet.size());
        System.out.println(userIntegerMap.size());
    }

    /**
     * <h2>集合元素索引与 equals 方法相关</h2>
     * */
    private static void compareToAndEquals() {

        List<User> users = new ArrayList<>();
        users.add(new User("qinyi", 10));
        users.add(new User("qinyi", 20));

        User user = new User("qinyi", 20);

		// 使用 equals
        int index1 = users.indexOf(user);
        // 使用 compareTo
        int index2 = Collections.binarySearch(users, user);

        System.out.println(index1);
        System.out.println(index2);
    }

    public static void main(String[] args) {

//        equalsAndHashcode();
        compareToAndEquals();
    }
}
```

# Lombok

## 常用注解

![](image/Pasted%20image%2020241211010802.png)

## 原理

![](image/Pasted%20image%2020241211010951.png)

## 代码

- 第一个坑是

```java
/**
 * <h1>Java Object</h1>
 * */
@Data
public class Personal {

    private String iPhone;
    private String name;
    private String userName;
}

```

```java
/**
 * <h1>lombok 工具的使用以及需要避免的坑</h1>
 * */
public class Main {

    /**
     * <h1>lombok 第一个坑,单字母驼峰会全部变小写 iPhone -> iphone</h1>
     * */
    private static void singleAlphabetHump() throws Exception {

        ObjectMapper mapper = new ObjectMapper();

        Personal personal = new Personal();
        personal.setIPhone("8.1");

        // {"name":null,"userName":null,"iphone":"8.1"}
//        System.out.println(mapper.writeValueAsString(personal));

        String json = "{\"name\": \"qinyi\"," +
                "\"userName\": \"qinyi-imooc\",\"iphone\":\"8.1\"}";
		// 这样会报错，序列化是iphone，反序列化是iPhone，lombok 将 iPhoen -> iphone
		// Java 规范也是推荐这种单字母驼峰全小写
        Personal personal1 = mapper.readValue(json, Personal.class);
        System.out.println(personal1);
    }

    /**
     * <h2>lombok 的第二个坑，子类不会判断父类属性</h2>
     * */
    private static void equalsAndHashCodeBug() {

        AppleComputer computer1 = new AppleComputer(
                1, "Mac Pro", 1L, "yellow"
        );
        AppleComputer computer2 = new AppleComputer(
                2, "Mac Air", 1L, "yellow"
        );

        System.out.println(computer1.equals(computer2));
    }

    public static void main(String[] args) throws Exception {

//        singleAlphabetHump();

        equalsAndHashCodeBug();
    }
}
```

```java
@EqualsAndHashCode(callSuper = true)
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AppleComputer extends Computer {

    private long price;
    private String color;

    public AppleComputer(Integer id, String name, long price, String color) {

        super(id, name);
        this.price = price;
        this.color = color;
    }
}

```

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Computer {

    private Integer id;
    private String name;
}

```

# 抽象类和接口选择失误

## 实现一个 worker

- 共同有状态的使用抽象类，起床上下班
- 特有独立的使用接口

![](image/Pasted%20image%2020241211012246.png)

## 抽象类、接口含义和特性

![](image/Pasted%20image%2020241211012921.png)

## 抽象类、接口相同点

![](image/Pasted%20image%2020241211012929.png)

## 抽象类、接口不同点

![](image/Pasted%20image%2020241211013253.png)

## 代码

```java
/**
 * <h1>每一个 Worker 最基本的属性</h1>
 * */
public abstract class BaseWork {

    /** 起床时间 */
    protected int wakeupTime = 8;

    /** 上班打卡 */
    protected abstract void clockIn();

    /** 下班打卡 */
    protected abstract void clockOut();
}

```

```java
/**
 * <h1>程序员的基本工作</h1>
 * */
public interface IBaseWorking {

    void baseCoding();

    void baseTesting();

    default void config() {
        System.out.println("BaseWorking For Config");
    }

    static void time() {
        System.out.println(
                LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_TIME)
        );
    }
}

```

```java
/**
 * <h1>部分程序员的工作</h1>
 * */
public interface IExtraWorking {

    void extraCoding();

    void extraTesting();

    default void config() {
        System.out.println("ExtraWorking For Config");
    }

    static void time() {
        System.out.println(
                LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_TIME)
        );
    }
}

```

```java
/**
 * <h1>部分员工的兴趣</h1>
 * */
public interface Interest {

    void playBall();
}
```

```java
/**
 * <h1>员工类</h1>
 * */
public class Worker extends BaseWork implements IBaseWorking, IExtraWorking {

    @Override
    protected void clockIn() {

    }

    @Override
    protected void clockOut() {

    }

    @Override
    public void baseCoding() {

    }

    @Override
    public void baseTesting() {

    }

    @Override
    public void config() {
        // 定义自己的 config
    }

    @Override
    public void extraCoding() {

    }

    @Override
    public void extraTesting() {

    }
}

```

```java
public abstract class WorkAndInterest extends BaseWork {

    protected abstract void playBall();
}

```

# 接口默认方法和静态方法

![](image/Pasted%20image%2020241211014513.png)

- 避免了修改接口导致实现了这个接口的所有类都会报错
- 在实现类实现
- 本质还是接口

## 代码

```java
/**
 * <h1>Java8 新增的静态方法和默认方法</h1>
 * */
public class Main {

    public static void main(String[] args) {

        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);

        int min = list.stream().min(Comparator.comparing(value -> value)).get();
        int max = list.stream().max(Comparator.comparing(value -> value)).get();

        System.out.println(min);
        System.out.println(max);

        IBaseWorking.time();
        IExtraWorking.time();
    }
}
```

# 函数式接口和Lambda表达式

- Lambda表达式能替换部分匿名内部类

## 匿名内部类使用Lambda替代

![](image/Pasted%20image%2020241211015423.png)

## 不熟悉中间和结束操作引发语法错误

![](image/Pasted%20image%2020241211020650.png)

## 代码

```java
@FunctionalInterface
public interface IFindWorker {

    Worker findWorkerById(Long id);
}

```

```java
/**
 * <h1>函数式接口的使用</h1>
 * */
@SuppressWarnings("all")
public class Main {

    private static final Map<Long, Worker> id2WorkerMap = new HashMap<>();

    static {
        id2WorkerMap.put(1L, new Worker(1L, "qinyi", 19));
    }

    public static void main(String[] args) {

//        IFindWorker findWorker = id -> id2WorkerMap.get(id);

        IFindWorker findWorker = id2WorkerMap::get;

        System.out.println(findWorker.findWorkerById(1L));
    }
}

```

```java
/**
 * <h1>Lambda 表达式的使用</h1>
 * */
public class StudyLambda {

    /**
     * <h2>Java 1.8 之前创建线程</h2>
     * */
    private static void baseUse() {

        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("Anonymous Class Thread run()");
            }
        }).start();
    }

    /**
     * <h2>Java8 创建线程</h2>
     * */
    private static void easyUseLambda() {

        new Thread(() -> System.out.println("Anonymous Class Thread run()")).start();
    }

    /**
     * <h2>按照字符串长度进行排序</h2>
     * */
    private static void myCompare() {

        // java8 之前
        List<String> list = Arrays.asList("z", "y", "x", "a");
        Collections.sort(list, new Comparator<String>() {
            @Override
            public int compare(String s1, String s2) {

                if (s1 == null)
                    return -1;
                if (s2 == null)
                    return 1;
                return s1.length() - s2.length();
            }
        });

        // java8 使用 lambda 表达式去实现
        Collections.sort(list, (s1, s2) -> {
            if (s1 == null)
                return -1;
            if (s2 == null)
                return 1;
            return s1.length() - s2.length();
        });
    }

    /**
     * <h2>要理解 stream 的中间操作和结束操作</h2>
     * */
    private static void howToUseLambda() {

        List<String> names = Arrays.asList("qinyi", "imooc");

        List<String> newNames =
                names.stream().filter(n -> n.startsWith("q"))
                .map(n -> n.toUpperCase())
                .collect(Collectors.toList());
        System.out.println(newNames);
    }

    /**
     * <h2>Stream 和 lambda 可能导致计算低效</h2>
     * */
    private static void badUseLambda() {

        List<String> names = Arrays.asList("qinyi", "imooc");

        int longestNameSize =
                names.stream()
                .filter(s -> s.startsWith("q"))
                .mapToInt(String::length)
                .max()
                .getAsInt();

        int longest = 0;
        for (String str : names) {
            if (str.startsWith("q")) {
                int len = str.length();
                longest = Math.max(len, longest);
            }
        }

        System.out.println(longest);
    }
}

```

```java
/**
 * <h1>Java Object</h1>
 * */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Worker {

    private Long id;
    private String name;
    private Integer age;
}

```