# Synchronized

## 多线程操作变量

![](image/Pasted%20image%2020241211054933.png)

## 代码

```java
/**
 * <h1>对 value 进行减法操作</h1>
 * */
public class Active implements Runnable {

    private int value = 1000;

    @Override
    public void run() {

        String name = Thread.currentThread().getName();

        while (true) {

            if (value > 0) {
                System.out.println(name + " start :" + value);
                value--;
                System.out.println(name + " done :" + value);
            } else {
                break;
            }
        }
    }
}

```

```java
public class MainActive implements Runnable {

    private int value = 0;

    @Override
    public synchronized void run() {

        String name = Thread.currentThread().getName();

        while (true) {

            if (value < 1000) {
                System.out.println(name + " start : " + value);
                value++;
                System.out.println(name + " done : " + value);
            } else {
                break;
            }
        }
    }
}

```

```java
public class SubActive extends MainActive {

    private int value = 1000;

    @Override
    public synchronized void run() {

        String name = Thread.currentThread().getName();

        while (true) {

            if (value > 0) {
                System.out.println(name + " start :" + value);
                value--;
                System.out.println(name + " done :" + value);
            } else {
                break;
            }
        }
    }
}

```

```java
/**
 * <h1>多线程操作下的线程安全问题</h1>
 * */
public class Main {

    public static void main(String[] args) {

//        Active active = new Active();

//        MainActive active = new MainActive();

//        SubActive active = new SubActive();
//
//        Thread thread1 = new Thread(active, "thread1");
//        Thread thread2 = new Thread(active, "thread2");
//        Thread thread3 = new Thread(active, "thread3");
//        Thread thread4 = new Thread(active, "thread4");
//        Thread thread5 = new Thread(active, "thread5");
//
//        thread1.start();
//        thread2.start();
//        thread3.start();
//        thread4.start();
//        thread5.start();

        synchronized (Main.class) {
            System.out.println("synchronized");
        }
    }
}

```
## 使用前需要知道

- 实现就去看反编译

![](image/Pasted%20image%2020241211055925.png)

# 更新变量

## 多线程 i++ 得不到满意结果

![](image/Pasted%20image%2020241211061523.png)

## 常用的原子类

- Atomic就是典型的乐观锁

![](image/Pasted%20image%2020241211062703.png)

## ABA 问题

![](image/Pasted%20image%2020241211063336.png)

## 代码

```java
/**
 * <h1>多线程下的变量值更新</h1>
 * */
public class Atomic_ {

    private static int count = 0;
    private static AtomicInteger atomicCount = new AtomicInteger(0);

    /**
     * <h2>线程不安全的累加</h2>
     * */
    private static void accumulator(int acc) throws Exception {

        CountDownLatch cd1 = new CountDownLatch(2);

        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {

                for (int j = 0; j < acc; ++j) {
                    count++;
                }
                cd1.countDown();
            }
        });
        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {

                for (int j = 0; j < acc; ++j) {
                    count++;
                }
                cd1.countDown();
            }
        });

        t1.start();
        t2.start();

        cd1.await();

        System.out.println("result: " + count);
    }

    private static void atomicAccumulator(int acc) throws Exception {

        CountDownLatch cd1 = new CountDownLatch(2);

        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {

                for (int j = 0; j < acc; ++j) {
                    atomicCount.incrementAndGet();
                }
                cd1.countDown();
            }
        });
        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {

                for (int j = 0; j < acc; ++j) {
                    atomicCount.incrementAndGet();;
                }
                cd1.countDown();
            }
        });

        t1.start();
        t2.start();

        cd1.await();

        System.out.println("result: " + atomicCount.get());
    }

    public static void main(String[] args) throws Exception {

        accumulator(20000);

//        atomicAccumulator(10000);
    }
}

```

# 阻塞队列

- 用对api

![](image/Pasted%20image%2020241211074720.png)

## 代码

```java
/**
 * <h1>消费者</h1>
 * */
public class Consumer implements Runnable {

    private final BlockingQueue<Integer> blockingQueue;

    public Consumer(BlockingQueue<Integer> blockingQueue) {
        this.blockingQueue = blockingQueue;
    }

    @Override
    public void run() {

        try {
            while (true) {
                int value = blockingQueue.take();
                System.out.println("Consume: " + value);
                if (value >= 99) {
                    break;
                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Consumer Done!");
    }
}

```

```java
/**
 * <h1>生产者</h1>
 * */
public class Producer implements Runnable {

    private final BlockingQueue<Integer> blockingQueue;
    private static int element = 0;

    public Producer(BlockingQueue<Integer> blockingQueue) {
        this.blockingQueue = blockingQueue;
    }

//    @Override
//    public void run() {
//
//        while (element < 100) {
//            System.out.println("Produce: " + element);
//            blockingQueue.offer(element++);
//        }
//
//        System.out.println("Produce Done!");
//    }

    @Override
    public void run() {

        try {
            while (element < 100) {
                System.out.println("Produce: " + element);
                blockingQueue.put(element++);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Produce Done!");
    }
}

```

```java
/**
 * <h1>阻塞队列的应用</h1>
 * */
public class Main {

    public static void main(String[] args) {

        BlockingQueue<Integer> blockingQueue = new ArrayBlockingQueue<>(
                3, true
        );

        Producer producer = new Producer(blockingQueue);
        Consumer consumer = new Consumer(blockingQueue);

        new Thread(producer).start();
        new Thread(consumer).start();
    }
}
```

# Copy On Write

## 对同一个集合并发读写会抛异常

![](image/Pasted%20image%2020241211081328.png)

## 使用 CopyOnWrite解决

![](image/Pasted%20image%2020241211081919.png)

## 优缺点

- 保证最终一致性

![](image/Pasted%20image%2020241211082919.png)

## 对比Collections.synchronizedList

![](image/Pasted%20image%2020241211083714.png)

## 代码

```java
/**
 * <h1>并发读写会抛出异常</h1>
 * */
public class TaskPoolProblem {

    private static final List<String> tasks = new ArrayList<>();

    public static void main(String[] args) throws Exception {

        for (int i = 0; i != 10; ++i) {
            tasks.add("task-" + i);
        }

        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    tasks.add("task-x");
                }
            }
        });
        thread.setDaemon(true);
        thread.start();

        Thread.sleep(1000L);

        for (String task : tasks) {
            System.out.println(task);
        }
    }
}

```

```java
/**
 * <h1>使用 CopyOnWrite 并发读写不会抛出异常</h1>
 * */
public class TaskPoolNoProblem {

    private static final List<String> tasks = new CopyOnWriteArrayList<>();

    public static void main(String[] args) throws Exception {

        for (int i = 0; i != 10; ++i) {
            tasks.add("task-" + i);
        }

        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    tasks.add("task-x");
                }
            }
        });
        thread.setDaemon(true);
        thread.start();

        Thread.sleep(1000L);

        for (String task : tasks) {
            System.out.println(task);
        }
    }
}

```

```java
@SuppressWarnings("all")
public class GoodListService {

    private static final List<String> goods = new CopyOnWriteArrayList<>();

    public static boolean contains(String good) {
        return goods.contains(good);
    }

    public static void addGood(String good) {
        goods.add(good);
    }

    public static void addGoods(List<String> gds) {
        goods.addAll(gds);
    }
}
```

# 线程池

![](image/Pasted%20image%2020241211083902.png)
## 运行状态

![](image/Pasted%20image%2020241211084037.png)

## 状态转换

![](image/Pasted%20image%2020241211084056.png)

## 错误用法

![](image/Pasted%20image%2020241211084219.png)

## 如何监控线程池运行状态

![](image/Pasted%20image%2020241211202302.png)

## 思考

![](image/Pasted%20image%2020241211202325.png)

 1. 可以使用线程池来执行需要返回结果的异步任务。
	- 使用`ExecutorService`接口，其方法`submit(Callable<T> task)`可以提交一个实现`Callable`接口的任务，并返回一个`Future<T>`对象。
    - `Future<T>`对象可以用于检查任务是否完成、等待任务完成并获取返回结果。

2. 可以动态调整线程池的大小。
	- 使用`ThreadPoolExecutor`类，可以调用`setCorePoolSize(int corePoolSize)`和`setMaximumPoolSize(int maximumPoolSize)`方法来动态调整线程池大小。

## 代码

```java
/**
 * <h1>读书的任务</h1>
 * */
public class Reading implements Runnable {

    private int count;
    private String name;

    public Reading(int count, String name) {
        this.count = count;
        this.name = name;
    }

    @Override
    public void run() {

        while (count > 0) {

            System.out.println(Thread.currentThread().getName() + " reading " + name);

            try {
                Thread.sleep(1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }

            --count;
        }
    }
}
```

```java
/**
 * <h1>可监控的线程池</h1>
 * */
public class Main {

    public static void main(String[] args) {

        ExecutorService executorService = ExecutorsUtil.newFixedThreadPool(
                10, "imooc-qinyi-"
        );

        Runnable runnable01 = new Reading(3, "Java 编程思想");
        Runnable runnable02 = new Reading(2, "Spring 实战");
        Runnable runnable03 = new Reading(3, "SpringBoot 实战");
        Runnable runnable04 = new Reading(1, "MySQL 权威指南");
        Runnable runnable05 = new Reading(2, "SpringCloud 实战");

        executorService.execute(runnable01);
        executorService.execute(runnable02);
        executorService.execute(runnable03);
        executorService.execute(runnable04);
        executorService.execute(runnable05);

        executorService.shutdown();
    }
}
```

```java
/**
 * <h1>简单使用线程池</h1>
 * */
public class EasyUseThreadPool {

    private static void useFixedThreadPool(int threadCount) {

        ExecutorService executor = Executors.newFixedThreadPool(threadCount);

        Runnable runnable01 = new Reading(3, "Java 编程思想");
        Runnable runnable02 = new Reading(2, "Spring 实战");
        Runnable runnable03 = new Reading(3, "SpringBoot 实战");
        Runnable runnable04 = new Reading(1, "MySQL 权威指南");
        Runnable runnable05 = new Reading(2, "SpringCloud 实战");

        executor.execute(runnable01);
        executor.execute(runnable02);
        executor.execute(runnable03);
        executor.execute(runnable04);
        executor.execute(runnable05);

        executor.shutdown();
    }

    /**
     * <h2>自定义线程池</h2>
     * */
    private static void customThreadPool() {

        ThreadPoolExecutor custom1 = new ThreadPoolExecutor(
                1, 1, 30, TimeUnit.MINUTES,
                new ArrayBlockingQueue<Runnable>(2)
        );
        ThreadPoolExecutor custom2 = new ThreadPoolExecutor(
                1, 1, 30, TimeUnit.MINUTES,
                new ArrayBlockingQueue<Runnable>(2),
                new CustomRejectHandler()
        );

        for (int i = 0; i != 5; ++i) {
            custom2.execute(new Reading(3, "Java 编程思想"));
        }

        custom2.shutdown();
    }

    private static class CustomRejectHandler implements RejectedExecutionHandler {

        @Override
        public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {

            try {
                executor.getQueue().put(r);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {

//        useFixedThreadPool(3);
        customThreadPool();
    }
}

```

```java
/**
 * <h1>自定义线程池工厂, 带有监控功能</h1>
 * */
public class ExecutorsUtil extends ThreadPoolExecutor {

    @Override
    public void shutdown() {
        System.out.println(
                String.format(this.poolName +
                                "Going to shutdown. Executed tasks: %d," +
                        "Running tasks: %d, Pending tasks: %d",
                        this.getCompletedTaskCount(),
                        this.getActiveCount(), this.getQueue().size())
        );
        super.shutdown();
    }

    @Override
    public List<Runnable> shutdownNow() {
        System.out.println(
                String.format(this.poolName +
                                "Going to shutdownNow. Executed tasks: %d," +
                                "Running tasks: %d, Pending tasks: %d",
                        this.getCompletedTaskCount(),
                        this.getActiveCount(), this.getQueue().size())
        );
        return super.shutdownNow();
    }

    @Override
    protected void beforeExecute(Thread t, Runnable r) {
        startTimes.put(String.valueOf(r.hashCode()), new Date());
    }

    @Override
    protected void afterExecute(Runnable r, Throwable t) {

        Date startDate = startTimes.remove(String.valueOf(r.hashCode()));
        Date finishDate = new Date();
        long diff = finishDate.getTime() - startDate.getTime();

        System.out.println(String.format("task running time: %d", diff));
    }

    public static ExecutorService newFixedThreadPool(int nThreads, String poolName) {

        return new ExecutorsUtil(
                nThreads, nThreads, 0L, TimeUnit.MILLISECONDS,
                new LinkedBlockingDeque<>(), poolName
        );
    }

    private ConcurrentHashMap<String, Date> startTimes;
    private String poolName;

    public ExecutorsUtil(int corePoolSize, int maximumPoolSize, long keepAliveTime,
                         TimeUnit unit, BlockingQueue<Runnable> workQueue,
                         String poolName) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit,
                workQueue, new ExecutorsUtil.EventThreadFactory(poolName));
        this.startTimes = new ConcurrentHashMap<>();
        this.poolName = poolName;
    }

    static class EventThreadFactory implements ThreadFactory {

        private static final AtomicInteger poolNumber =
                new AtomicInteger(1);
        private final ThreadGroup group;
        private final AtomicInteger threadNumber =
                new AtomicInteger(1);
        private final String namePrefix;

        EventThreadFactory(String poolName) {
            SecurityManager s = System.getSecurityManager();
            group = (s != null) ? s.getThreadGroup()
                    : Thread.currentThread().getThreadGroup();
            namePrefix = poolName + "-pool-" + poolNumber.getAndIncrement()
                    + "-thread";
        }

        @Override
        public Thread newThread(Runnable r) {

            Thread t = new Thread(
                    group, r, namePrefix + threadNumber.getAndIncrement(),
                    0
            );
            if (t.isDaemon()) {
                t.setDaemon(false);
            }
            if (t.getPriority() != Thread.NORM_PRIORITY) {
                t.setPriority(Thread.NORM_PRIORITY);
            }

            return t;
        }
    }
}

```

# ThreadLocal

## 不恰当的理解

![](image/Pasted%20image%2020241211210811.png)

## 基本原理

![](image/Pasted%20image%2020241211210833.png)

## 使用误区

![](image/Pasted%20image%2020241211211712.png)

## 实现方式

![](image/Pasted%20image%2020241211213008.png)

![](image/Pasted%20image%2020241211213020.png)

## 代码

```java
public class Competition {

    public static ThreadLocal<Material> material = ThreadLocal.withInitial(
            () -> new Material("初始代码", "初始配置")
    );

    public static class Material {

        private String code;
        private String config;

        public Material(String code, String config) {
            this.code = code;
            this.config = config;
        }

        public String getCode() {
            return code;
        }

        public void setCode(String code) {
            this.code = code;
        }

        public String getConfig() {
            return config;
        }

        public void setConfig(String config) {
            this.config = config;
        }
    }
}

```

```java
public class DoCompetition {

    public void code() {

        Competition.Material material = Competition.material.get();
        material.setCode(Thread.currentThread().getName());
        Competition.material.set(material);
    }

    public void config() {

        Competition.Material material = Competition.material.get();
        material.setConfig(Thread.currentThread().getName());
        Competition.material.set(material);
    }

    public void print() {

        System.out.println(
                String.format(
                        "Thread name: %s, ThreadLocal hashcode: %s, Instance hashcode: %s," +
                                "Value: %s",
                        Thread.currentThread().getName(),
                        Competition.material.hashCode(),
                        Competition.material.get().hashCode(),
                        Competition.material.get().toString()
                )
        );
    }
}

```

```java
/**
 * <h1>ThreadLocal 的使用和对它的理解</h1>
 * */
public class Main {

    /**
     * <h2>ThreadLocal 不支持继承</h2>
     * */
    private static void threadLocalCanNotInherit() {

        ThreadLocal<String> name = new ThreadLocal<>();
        name.set("qinyi");

        Thread sub = new Thread(() -> System.out.println("Name In Sub: " + name.get()));
        sub.start();

        System.out.println("Name In Main: " + name.get());
    }

    public static void main(String[] args) {

//        for (int i = 0; i != 3; ++i) {
//
//            new Thread(
//                    () -> {
//                        DoCompetition competition = new DoCompetition();
//                        competition.code();
//                        competition.config();
//                        competition.print();
//                    }, "Thread-" + (i + 1)
//            ).start();
//        }

        threadLocalCanNotInherit();
    }
}

```

```java
/**
 * <h1>在线程池中使用 ThreadLocal</h1>
 * */
public class ThreadLocalValueHolder {

    private static final ThreadLocal<Integer> holder = ThreadLocal.withInitial(
            () -> 0
    );

    public static int getValue() {
        return holder.get();
    }

    public static void remove() {
        holder.remove();
    }

    public static void increment() {
        holder.set(holder.get() + 1);
    }

    public static void main(String[] args) {

        ExecutorService executor = Executors.newFixedThreadPool(3);

        for (int i = 0; i != 15; ++i) {

            executor.execute(
                    () -> {
                        try {
                            long threadId = Thread.currentThread().getId();
                            int before = getValue();
                            increment();
                            int after = getValue();

//                        System.out.println("before: " + before + ", after: " + after);
                            System.out.println("threadId: " + threadId +
                                    ", before: " + before + ", after: " + after);
                        } finally {
                            remove();
                        }
                    }
            );
        }

        executor.shutdown();
    }
}
```