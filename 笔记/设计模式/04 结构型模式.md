# 外观（门面）模式

## 定义

![](image/Pasted%20image%2020241227215801.png)

## 适用场景

![](image/Pasted%20image%2020241227215822.png)

## 优点

![](image/Pasted%20image%2020241227215907.png)

## 缺点

![](image/Pasted%20image%2020241227215918.png)

## 扩展

- 外观模式关注的是外界和子系统交互
- 中介者模式是子系统内部的交互
- 将外观对象做成单例
- 通过抽象工厂将子系统对外界屏蔽

![](image/Pasted%20image%2020241227215956.png)

## 代码

- 在乎的就是业务代码是否和子系统进行交互，如果有门面模式就算比较失败了

![](image/Pasted%20image%2020241227221739.png)

```java
public class Test {
    public static void main(String[] args) {
        PointsGift pointsGift = new PointsGift("T恤");
        GiftExchangeService giftExchangeService = new GiftExchangeService();
        giftExchangeService.giftExchange(pointsGift);
    }
}


public class PointsGift {
    private String name;

    public PointsGift(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}

public class GiftExchangeService {
    private QualifyService qualifyService = new QualifyService();
    private PointsPaymentService pointsPaymentService = new PointsPaymentService();
    private ShippingService shippingService = new ShippingService();

    public void giftExchange(PointsGift pointsGift){
        if(qualifyService.isAvailable(pointsGift)){
            //资格校验通过
            if(pointsPaymentService.pay(pointsGift)){
                //如果支付积分成功
                String shippingOrderNo = shippingService.shipGift(pointsGift);
                System.out.println("物流系统下单成功,订单号是:"+shippingOrderNo);
            }
        }
    }

}

public class PointsPaymentService {
    public boolean pay(PointsGift pointsGift){
        //扣减积分
        System.out.println("支付"+pointsGift.getName()+" 积分成功");
        return true;
    }

}


public class QualifyService {
    public boolean isAvailable(PointsGift pointsGift){
        System.out.println("校验"+pointsGift.getName()+" 积分资格通过,库存通过");
        return true;
    }
}


public class ShippingService {
    public String shipGift(PointsGift pointsGift){
        //物流系统的对接逻辑
        System.out.println(pointsGift.getName()+"进入物流系统");
        String shippingOrderNo = "666";
        return shippingOrderNo;
    }
}

```

## 源码

- 在 SpringJDBC 中 JdbcUtils 对原生的 JDBC 进行封装
- 在 Mybatis 中 Configuration  new 开头的方法也使用了外观模式
- Tomcat 中的 RequestFacade ResponseFacade 之类以 Facade 结尾的类，基本都是使用外观模式，对外感觉就是操作原生 api

# 装饰者模式

##  定义

![](image/Pasted%20image%2020241228110008.png)

## 适用场景

![](image/Pasted%20image%2020241228110047.png)

## 优点

![](image/Pasted%20image%2020241228110309.png)

## 缺点

![](image/Pasted%20image%2020241228110413.png)

## 相关设计模式

- 装饰者关注在对象上动态的添加方法，原对象作为参数
- 代理模式关注对对象的控制和访问，代理类创建实例

![](image/Pasted%20image%2020241228112308.png)

## 代码

- v1 没有使用设计模式，每次有新的需求都需要添加新的类

![](image/Pasted%20image%2020241228113441.png)

```java
public class Test {
    public static void main(String[] args) {
        Battercake battercake = new Battercake();
        System.out.println(battercake.getDesc()+" 销售价格:"+battercake.cost());

        Battercake battercakeWithEgg = new BattercakeWithEgg();
        System.out.println(battercakeWithEgg.getDesc()+" 销售价格:"+battercakeWithEgg.cost());


        Battercake battercakeWithEggSausage = new BattercakeWithEggSausage();
        System.out.println(battercakeWithEggSausage.getDesc()+" 销售价格:"+battercakeWithEggSausage.cost());


    }
}

public class Battercake {
    protected String getDesc(){
        return "煎饼";
    }
    protected int cost(){
        return 8;
    }

}

public class BattercakeWithEgg extends Battercake {
    @Override
    public String getDesc() {
        return super.getDesc()+" 加一个鸡蛋";
    }

    @Override
    public int cost() {
        return super.cost()+1;
    }
}

public class BattercakeWithEggSausage extends BattercakeWithEgg {
    @Override
    public String getDesc() {
        return super.getDesc()+ " 加一根香肠";
    }

    @Override
    public int cost() {
        return super.cost()+2;
    }
}

```

- v2 使用了设计模式，被装饰是煎饼，装饰者是鸡蛋和香肠

![](image/Pasted%20image%2020241228114358.png)

```java
public abstract class ABattercake {
    protected abstract String getDesc();
    protected abstract int cost();

}

public class Battercake extends ABattercake {
    @Override
    protected String getDesc() {
        return "煎饼";
    }

    @Override
    protected int cost() {
        return 8;
    }
}


public abstract class AbstractDecorator extends ABattercake {
    private ABattercake aBattercake;

    public AbstractDecorator(ABattercake aBattercake) {
        this.aBattercake = aBattercake;
    }

    protected abstract void doSomething();

    @Override
    protected String getDesc() {
        return this.aBattercake.getDesc();
    }

    @Override
    protected int cost() {
        return this.aBattercake.cost();
    }
}

public class EggDecorator extends AbstractDecorator {
    public EggDecorator(ABattercake aBattercake) {
        super(aBattercake);
    }

    @Override
    protected void doSomething() {

    }

    @Override
    protected String getDesc() {
        return super.getDesc()+" 加一个鸡蛋";
    }

    @Override
    protected int cost() {
        return super.cost()+1;
    }
}

public class SausageDecorator extends AbstractDecorator{
    public SausageDecorator(ABattercake aBattercake) {
        super(aBattercake);
    }

    @Override
    protected void doSomething() {

    }

    @Override
    protected String getDesc() {
        return super.getDesc()+" 加一根香肠";
    }

    @Override
    protected int cost() {
        return super.cost()+2;
    }
}

public class Test {
    public static void main(String[] args) {
        ABattercake aBattercake;
        aBattercake = new Battercake();
        aBattercake = new EggDecorator(aBattercake);
        aBattercake = new EggDecorator(aBattercake);
        aBattercake = new SausageDecorator(aBattercake);

        System.out.println(aBattercake.getDesc()+" 销售价格:"+aBattercake.cost());

    }
}
```

## 源码

- 体现最明显的就是 Java IO 方面的类，类似于 BufferedReader 将 Reader 组合到自己的成员变量，就和上面都是针对抽象的煎饼来开发，我们可以无限次的装饰转换，得到自己想要的流对象
- FileInputStream 就是被装饰者，继承 FilterInputStream 就是装饰者

![](image/Pasted%20image%2020241228123956.png)

```java
public abstract class Reader implements Readable, Closeable {}

public class BufferedReader extends Reader {
	private Reader in
}
```

- TransactionAwareCacheDecorator 这个类是处理缓存和同步事务的类，实现了相同的接口，又组合在了一起

```java
public class TransactionAwareCacheDecorator implements Cache {  
    private final Cache targetCache;  
  
    public TransactionAwareCacheDecorator(Cache targetCache) {  
        Assert.notNull(targetCache, "Target Cache must not be null");  
        this.targetCache = targetCache;  
    }  
  
    public Cache getTargetCache() {  
        return this.targetCache;  
    }  
  
    public String getName() {  
        return this.targetCache.getName();  
    }  
  
    public Object getNativeCache() {  
        return this.targetCache.getNativeCache();  
    }  
  
    @Nullable  
    public Cache.ValueWrapper get(Object key) {  
        return this.targetCache.get(key);  
    }  
  
    public <T> T get(Object key, @Nullable Class<T> type) {  
        return this.targetCache.get(key, type);  
    }  
  
    @Nullable  
    public <T> T get(Object key, Callable<T> valueLoader) {  
        return this.targetCache.get(key, valueLoader);  
    }  
  
    public void put(final Object key, @Nullable final Object value) {  
        if (TransactionSynchronizationManager.isSynchronizationActive()) {  
            TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronization() {  
                public void afterCommit() {  
                    TransactionAwareCacheDecorator.this.targetCache.put(key, value);  
                }  
            });  
        } else {  
            this.targetCache.put(key, value);  
        }  
  
    }  
  
    @Nullable  
    public Cache.ValueWrapper putIfAbsent(Object key, @Nullable Object value) {  
        return this.targetCache.putIfAbsent(key, value);  
    }  
  
    public void evict(final Object key) {  
        if (TransactionSynchronizationManager.isSynchronizationActive()) {  
            TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronization() {  
                public void afterCommit() {  
                    TransactionAwareCacheDecorator.this.targetCache.evict(key);  
                }  
            });  
        } else {  
            this.targetCache.evict(key);  
        }  
  
    }  
  
    public boolean evictIfPresent(Object key) {  
        return this.targetCache.evictIfPresent(key);  
    }  
  
    public void clear() {  
        if (TransactionSynchronizationManager.isSynchronizationActive()) {  
            TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronization() {  
                public void afterCommit() {  
                    TransactionAwareCacheDecorator.this.targetCache.clear();  
                }  
            });  
        } else {  
            this.targetCache.clear();  
        }  
  
    }  
  
    public boolean invalidate() {  
        return this.targetCache.invalidate();  
    }  
}
```

- 装饰者和适配器都可以叫 wrapper

![](image/Pasted%20image%2020241228133924.png)

- Mybatis

![](image/Pasted%20image%2020241228134216.png)

```java
public interface Cache {  
    String getId();  
  
    void putObject(Object var1, Object var2);  
  
    Object getObject(Object var1);  
  
    Object removeObject(Object var1);  
  
    void clear();  
  
    int getSize();  
  
    default ReadWriteLock getReadWriteLock() {  
        return null;  
    }  
}

public class FifoCache implements Cache {  
    private final Cache delegate;  
    private final Deque<Object> keyList;  
    private int size;  
  
    public FifoCache(Cache delegate) {  
        this.delegate = delegate;  
        this.keyList = new LinkedList();  
        this.size = 1024;  
    }  
  
    public String getId() {  
        return this.delegate.getId();  
    }  
  
    public int getSize() {  
        return this.delegate.getSize();  
    }  
  
    public void setSize(int size) {  
        this.size = size;  
    }  
  
    public void putObject(Object key, Object value) {  
        this.cycleKeyList(key);  
        this.delegate.putObject(key, value);  
    }  
  
    public Object getObject(Object key) {  
        return this.delegate.getObject(key);  
    }  
  
    public Object removeObject(Object key) {  
        return this.delegate.removeObject(key);  
    }  
  
    public void clear() {  
        this.delegate.clear();  
        this.keyList.clear();  
    }  
  
    private void cycleKeyList(Object key) {  
        this.keyList.addLast(key);  
        if (this.keyList.size() > this.size) {  
            Object oldestKey = this.keyList.removeFirst();  
            this.delegate.removeObject(oldestKey);  
        }  
  
    }  
}
```

# 适配器

## 定义

![](image/Pasted%20image%2020241228134803.png)

## 适用场景

![](image/Pasted%20image%2020241228134903.png)

## 优点

![](image/Pasted%20image%2020241228135046.png)

## 缺点

![](image/Pasted%20image%2020241228135109.png)

## 扩展

![](image/Pasted%20image%2020241228135125.png)

## 相关设计模式

![](image/Pasted%20image%2020241228135216.png)

## 代码

- 通过组合的方式实现
![](image/Pasted%20image%2020241228152319.png)

```java
public class Adaptee {
    public void adapteeRequest(){
        System.out.println("被适配者的方法");
    }

}

public interface Target {
    void request();
}

public class Adapter implements Target{
    private Adaptee adaptee = new Adaptee();

    @Override
    public void request() {
        //...
        adaptee.adapteeRequest();
        //...
    }
}

public class ConcreteTarget implements Target {
    @Override
    public void request() {
        System.out.println("concreteTarget目标方法");
    }

}

public class Test {
    public static void main(String[] args) {
        Target target = new ConcreteTarget();
        target.request();

        Target adapterTarget = new Adapter();
        adapterTarget.request();

    }
}
```

- 通过继承的方式实现

![](image/Pasted%20image%2020241228152241.png)

```java
public class Adaptee {
    public void adapteeRequest(){
        System.out.println("被适配者的方法");
    }

}

public interface Target {
    void request();
}


public class Adapter extends Adaptee implements Target{
    @Override
    public void request() {
        //...
        super.adapteeRequest();
        //...
    }
}

public class ConcreteTarget implements Target {
    @Override
    public void request() {
        System.out.println("concreteTarget目标方法");
    }

}

public class Test {
    public static void main(String[] args) {
        Target target = new ConcreteTarget();
        target.request();

        Target adapterTarget = new Adapter();
        adapterTarget.request();

    }
}
```

- 举例

```java
public class AC220 {
    public int outputAC220V(){
        int output = 220;
        System.out.println("输出交流电"+output+"V");
        return output;
    }
}

public interface DC5 {
    int outputDC5V();
}

public class PowerAdapter implements DC5{
    private AC220 ac220 = new AC220();

    @Override
    public int outputDC5V() {
        int adapterInput = ac220.outputAC220V();
        //变压器...
        int adapterOutput = adapterInput/44;

        System.out.println("使用PowerAdapter输入AC:"+adapterInput+"V"+"输出DC:"+adapterOutput+"V");
        return adapterOutput;
    }
}


public class Test {
    public static void main(String[] args) {
        DC5 dc5 = new PowerAdapter();
        dc5.outputDC5V();

    }
}
```

## 源码

- XmlAdapter
- Spring aop 中的 AdvisorAdapter
- Spring MVC 中的 HandlerAdapter，有很多种类的 Controller，里面有各种不同的实现，但是 DispatcherServlet 进行操作需要 instanceof 来判断，所以加入了适配器，统一操作

```java

class MethodBeforeAdviceAdapter implements AdvisorAdapter, Serializable {  
    MethodBeforeAdviceAdapter() {  
    }  
  
    public boolean supportsAdvice(Advice advice) {  
        return advice instanceof MethodBeforeAdvice;  
    }  
  
    public MethodInterceptor getInterceptor(Advisor advisor) {  
        MethodBeforeAdvice advice = (MethodBeforeAdvice)advisor.getAdvice();  
        return new MethodBeforeAdviceInterceptor(advice);  
    }  
}
```

# 享元模式

## 定义

![](image/Pasted%20image%2020241228152622.png)

## 适用场景

![](image/Pasted%20image%2020241228153721.png)

## 优点

![](image/Pasted%20image%2020241228153818.png)

## 缺点

![](image/Pasted%20image%2020241228153858.png)

## 扩展

- 内部状态是属性，不会随着外部环境变化而变化
- 外部状态，通常是外部传入

![](image/Pasted%20image%2020241228153925.png)

## 相关设计模式

![](image/Pasted%20image%2020241228154104.png)

## 代码

- 一定要注意线程安全问题

```java
public interface Employee {
    void report();
}

public class Manager implements Employee {
    @Override
    public void report() {
        System.out.println(reportContent);
    }
    private String title = "部门经理";
    private String department;
    private String reportContent;

    public void setReportContent(String reportContent) {
        this.reportContent = reportContent;
    }

    public Manager(String department) {
        this.department = department;
    }


}

public class EmployeeFactory {
    private static final Map<String,Employee> EMPLOYEE_MAP = new HashMap<String,Employee>();

    public static Employee getManager(String department){
        Manager manager = (Manager) EMPLOYEE_MAP.get(department);

        if(manager == null){
            manager = new Manager(department);
            System.out.print("创建部门经理:"+department);
            String reportContent = department+"部门汇报:此次报告的主要内容是......";
            manager.setReportContent(reportContent);
            System.out.println(" 创建报告:"+reportContent);
            EMPLOYEE_MAP.put(department,manager);

        }
        return manager;
    }

}

public class Test {
    private static final String departments[] = {"RD","QA","PM","BD"};

    public static void main(String[] args) {
        for(int i=0; i<10; i++){
            String department = departments[(int)(Math.random() * departments.length)];
            Manager manager = (Manager) EmployeeFactory.getManager(department);
            manager.report();
        }
        
    }
}

```

## 源码

- Integer 

```java
@IntrinsicCandidate  
public static Integer valueOf(int i) {  
    if (i >= IntegerCache.low && i <= IntegerCache.high)  
        return IntegerCache.cache[i + (-IntegerCache.low)];  
    return new Integer(i);  
}
```

```java

	Integer a = Integer.valueOf(100);
	Integer b = 100;

    Integer c = Integer.valueOf(1000);
    Integer d = 1000;

    System.out.println("a==b:"+(a==b));

    System.out.println("c==d:"+(c==d));

```

# 组合模式

- 如何识别，就是将相同接口或者抽象类组织成树状结构
- 在操作时储存自己的实现的接口或者抽象类

## 定义

![](image/Pasted%20image%2020241228175100.png)

![](image/Pasted%20image%2020241228175157.png)

## 适用场景

![](image/Pasted%20image%2020241228175216.png)

## 优点

![](image/Pasted%20image%2020241228175237.png)

## 缺点

![](image/Pasted%20image%2020241228175341.png)

## 代码

![](image/Pasted%20image%2020241228180813.png)

```java
public abstract class CatalogComponent {
    public void add(CatalogComponent catalogComponent){
        throw new UnsupportedOperationException("不支持添加操作");
    }

    public void remove(CatalogComponent catalogComponent){
        throw new UnsupportedOperationException("不支持删除操作");
    }


    public String getName(CatalogComponent catalogComponent){
        throw new UnsupportedOperationException("不支持获取名称操作");
    }


    public double getPrice(CatalogComponent catalogComponent){
        throw new UnsupportedOperationException("不支持获取价格操作");
    }


    public void print(){
        throw new UnsupportedOperationException("不支持打印操作");
    }


}

public class Course extends CatalogComponent {
    private String name;
    private double price;

    public Course(String name, double price) {
        this.name = name;
        this.price = price;
    }

    @Override
    public String getName(CatalogComponent catalogComponent) {
        return this.name;
    }

    @Override
    public double getPrice(CatalogComponent catalogComponent) {
        return this.price;
    }

    @Override
    public void print() {
        System.out.println("Course Name:"+name+" Price:"+price);
    }

}

public class CourseCatalog extends CatalogComponent {
    private List<CatalogComponent> items = new ArrayList<CatalogComponent>();
    private String name;
    private Integer level;


    public CourseCatalog(String name,Integer level) {
        this.name = name;
        this.level = level;
    }

    @Override
    public void add(CatalogComponent catalogComponent) {
        items.add(catalogComponent);
    }

    @Override
    public String getName(CatalogComponent catalogComponent) {
        return this.name;
    }

    @Override
    public void remove(CatalogComponent catalogComponent) {
        items.remove(catalogComponent);
    }

    @Override
    public void print() {
        System.out.println(this.name);
        for(CatalogComponent catalogComponent : items){
            if(this.level != null){
                for(int  i = 0; i < this.level; i++){
                    System.out.print("  ");
                }
            }
            catalogComponent.print();
        }
    }

}


public class Test {
    public static void main(String[] args) {
        CatalogComponent linuxCourse = new Course("Linux课程",11);
        CatalogComponent windowsCourse = new Course("Windows课程",11);

        CatalogComponent javaCourseCatalog = new CourseCatalog("Java课程目录",2);

        CatalogComponent mmallCourse1 = new Course("Java电商一期",55);
        CatalogComponent mmallCourse2 = new Course("Java电商二期",66);
        CatalogComponent designPattern = new Course("Java设计模式",77);

        javaCourseCatalog.add(mmallCourse1);
        javaCourseCatalog.add(mmallCourse2);
        javaCourseCatalog.add(designPattern);

        CatalogComponent imoocMainCourseCatalog = new CourseCatalog("慕课网课程主目录",1);
        imoocMainCourseCatalog.add(linuxCourse);
        imoocMainCourseCatalog.add(windowsCourse);
        imoocMainCourseCatalog.add(javaCourseCatalog);

        imoocMainCourseCatalog.print();



    }
}
```

## 源码

- java.awt.Container
- HashMap
- java.util.ArrayList
- Mybatis 中的 SqlNode

![](image/Pasted%20image%2020241228182601.png)

```java

public interface SqlNode {  
    boolean apply(DynamicContext var1);  
}

public class MixedSqlNode implements SqlNode {  
    private final List<SqlNode> contents;  
  
    public MixedSqlNode(List<SqlNode> contents) {  
        this.contents = contents;  
    }  
  
    public boolean apply(DynamicContext context) {  
        this.contents.forEach((node) -> {  
            node.apply(context);  
        });  
        return true;  
    }  
}
```

# 桥接模式

## 定义

![](image/Pasted%20image%2020241229124719.png)

## 适用场景

![](image/Pasted%20image%2020241229125048.png)

## 优点

![](image/Pasted%20image%2020241229125154.png)

## 缺点

![](image/Pasted%20image%2020241229125208.png)

## 相关设计模式

- 组合模式强调的是部分和整体间的组合，桥接是平行级别上不同类的组合
- 桥接和适配器都是让两个适配工作，适配器是改变已有的接口相互配合，也就是功能上相似接口不同的类适配，桥接是分离抽象和具体实现，目的是分离并组合

![](image/Pasted%20image%2020241229125524.png)

## 代码

![](image/Pasted%20image%2020241229133501.png)

```java

public class Test {
    public static void main(String[] args) {
        Bank icbcBank = new ICBCBank(new DepositAccount());
        Account icbcAccount = icbcBank.openAccount();
        icbcAccount.showAccountType();

        Bank icbcBank2 = new ICBCBank(new SavingAccount());
        Account icbcAccount2 = icbcBank2.openAccount();
        icbcAccount2.showAccountType();

        Bank abcBank = new ABCBank(new SavingAccount());
        Account abcAccount = abcBank.openAccount();
        abcAccount.showAccountType();
    }
}


public abstract class Bank {
    protected Account account;
    public Bank(Account account){
        this.account = account;
    }
    abstract Account openAccount();

}

public interface Account {
    Account openAccount();
    void showAccountType();

}

public class ABCBank extends Bank {
    public ABCBank(Account account) {
        super(account);
    }

    @Override
    Account openAccount() {
        System.out.println("打开中国农业银行账号");
        account.openAccount();
        return account;
    }
}

public class ICBCBank extends Bank {
    public ICBCBank(Account account) {
        super(account);
    }

    @Override
    Account openAccount() {
        System.out.println("打开中国工商银行账号");
        account.openAccount();
        return account;
    }
}


public class DepositAccount implements Account {
    @Override
    public Account openAccount() {
        System.out.println("打开定期账号");
        return new DepositAccount();
    }

    @Override
    public void showAccountType() {
        System.out.println("这是一个定期账号");
    }
}

public class SavingAccount implements Account {
    @Override
    public Account openAccount() {
        System.out.println("打开活期账号");
        //...
        return new SavingAccount();
    }

    @Override
    public void showAccountType() {
        System.out.println("这是一个活期账号");
    }
}
```

## 源码

- JDK 中的 JDBC，里面有很多接口，统一操作，操作都是接口，不在乎实现

![](image/Pasted%20image%2020241229145528.png)

# 代理模式

## 定义

![](image/Pasted%20image%2020241229145554.png)

## 适用场景

![](image/Pasted%20image%2020241229145712.png)

## 优点

![](image/Pasted%20image%2020241229145754.png)

## 缺点

![](image/Pasted%20image%2020241229145830.png)

## 扩展

使用 CGlib 关注 final

![](image/Pasted%20image%2020241229145942.png)

### Spring 代理选择

![](image/Pasted%20image%2020241229150121.png)

### 代理速度对比

![](image/Pasted%20image%2020241229150150.png)

## 相关设计模式

- 装饰者是为类加上行为，代理模式是控制访问和增强对象
- 适配器改变目标接口，代理无法给改变接口

![](image/Pasted%20image%2020241229150454.png)

## 代码

### 静态代理

![](image/Pasted%20image%2020241229194309.png)

```java
public class Order {
    private Object orderInfo;
    private Integer userId;

    public Object getOrderInfo() {
        return orderInfo;
    }

    public void setOrderInfo(Object orderInfo) {
        this.orderInfo = orderInfo;
    }

    public Integer getUserId() {
        return userId;
    }

    public void setUserId(Integer userId) {
        this.userId = userId;
    }
}

public interface IOrderService {
    int saveOrder(Order order);
}

public interface IOrderDao {
    int insert(Order order);

}

public class OrderServiceImpl implements IOrderService {
    private IOrderDao iOrderDao;


    @Override
    public int saveOrder(Order order) {
        //Spring会自己注入，我们课程中就直接new了
        iOrderDao = new OrderDaoImpl();
        System.out.println("Service层调用Dao层添加Order");
        return iOrderDao.insert(order);
    }

}

public class OrderDaoImpl implements IOrderDao {
    @Override
    public int insert(Order order) {
        System.out.println("Dao层添加Order成功");
        return 1;
    }
}

public class OrderServiceStaticProxy {
    private IOrderService iOrderService;

    public int saveOrder(Order order){
        beforeMethod(order);
        iOrderService = new OrderServiceImpl();
        int result = iOrderService.saveOrder(order);
        afterMethod();
        return result;
    }

    private void beforeMethod(Order order){
        int userId = order.getUserId();
        int dbRouter = userId % 2;
        System.out.println("静态代理分配到【db"+dbRouter+"】处理数据");

        //todo 设置dataSource;
        DataSourceContextHolder.setDBType("db"+String.valueOf(dbRouter));
        System.out.println("静态代理 before code");
    }
    private void afterMethod(){
        System.out.println("静态代理 after code");
    }
}

public class Test {
    public static void main(String[] args) {
        Order order = new Order();
        order.setUserId(2);

        OrderServiceStaticProxy orderServiceStaticProxy = new OrderServiceStaticProxy();
        orderServiceStaticProxy.saveOrder(order);
    }
}

```

### 动态代理

```java
public class OrderServiceDynamicProxy implements InvocationHandler {

    private Object target;

    public OrderServiceDynamicProxy(Object target) {
        this.target = target;
    }

    public Object bind(){
        Class cls = target.getClass();
        return Proxy.newProxyInstance(cls.getClassLoader(),cls.getInterfaces(),this);
    }




    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object argObject = args[0];
        beforeMethod(argObject);
        Object object = method.invoke(target,args);
        afterMethod();
        return object;
    }

    private void beforeMethod(Object obj){
        int userId = 0;
        System.out.println("动态代理 before code");
        if(obj instanceof Order){
            Order order = (Order)obj;
            userId = order.getUserId();
        }
        int dbRouter = userId % 2;
        System.out.println("动态代理分配到【db"+dbRouter+"】处理数据");

        //todo 设置dataSource;
        DataSourceContextHolder.setDBType("db"+String.valueOf(dbRouter));
    }

    private void afterMethod(){
        System.out.println("动态代理 after code");
    }
}


public class Test {
    public static void main(String[] args) {
        Order order = new Order();
//        order.setUserId(2);
        order.setUserId(1);
        IOrderService orderServiceDynamicProxy = (IOrderService) new OrderServiceDynamicProxy(new OrderServiceImpl()).bind();

        orderServiceDynamicProxy.saveOrder(order);
    }
}
```

## 源码

- java.lang.reflect.proxy
- ProxyFactoryBean
- JdkDynamicAopProxy
- CglibAopProxy
- MapperProxyFactory