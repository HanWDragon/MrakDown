# 内存单元内容与地址

![](image/Pasted%20image%2020220917001740.png)

![](image/Pasted%20image%2020220917003152.png)

# 指针的定义和间接访问

```cpp
#include <iostream>  
using namespace std;  
int main() {  
  int a = 112, b = -1;  
  float c = 3.14f;  
  int *d = &a;  
  float *e = &c;  
  cout << d << endl;  
  cout << e << endl;  
  cout << (*d) << endl;  
  cout << (*e) << endl;  
  return 0;  
}
```

# C++中的原始指针

![](image/Pasted%20image%2020220917120912.png)

```cpp
#include <iostream>  
using namespace std;  
int main() {  
  // T*:  注意*在定义和间接访问上的作用  
  //int i = 4;  int* iP = &i;   cout << (*iP) << endl;  
  //double d = 3.14; double* dP = &d; cout << (*dP) << endl;  
  //char c = 'a';  char* cP = &c; cout << (*cP) << endl;  
  // array of pointers和a pointer to an array  
  int c[4] = {0x80000000, 0xFFFFFFFF, 0x00000000, 0x7FFFFFFF};  
  int *a[4];                          // array of pointers       指针的数组  
  int(*b)[4];                         // a pointer to an array 数组的指针  
  b = &c;                            // 注意：这里数组个数得匹配  
  // 将数组c中元素赋给数组a  
  for (unsigned int i = 0; i < 4; i++) {  
    a[i] = &(c[i]);  
  }  
  // 输出看下结果  
  cout << *(a[0]) << endl;   // -2147483648  
  cout << (*b)[3] << endl;   // 2147483647  
  return 0;  
}
```

![](image/Pasted%20image%2020220917133140.png)

```cpp
#include <iostream>  
using namespace std;  
unsigned int MAX_LEN = 11;  
int main()  
{  
   char strHelloworld[] = { "helloworld" };  
   char const* pStr1 = "helloworld";             // const char*  
   char* const pStr2 = strHelloworld;            
char const* const pStr3 = "helloworld";  // const char* const  
   pStr1 = strHelloworld;  
   //pStr2 = strHelloworld;                            // pStr2不可改  
   //pStr3 = strHelloworld;                            // pStr3不可改  
   unsigned int len = strnlen_s(pStr2, MAX_LEN);  
   cout << len << endl;  
   for (unsigned int index = 0; index < len; ++index)  
   {      //pStr1[index] += 1;                               // pStr1里的值不可改  
      pStr2[index] += 1;  
      //pStr3[index] += 1;                               // pStr3里的值不可改  
   }  
  
   return 0;  
}
```

![](image/Pasted%20image%2020220917134611.png)

![](image/Pasted%20image%2020220917135328.png)
![](image/Pasted%20image%2020220917135617.png)

![](image/Pasted%20image%2020220917135838.png)

```cpp
#include <iostream>  
using namespace std;  
int main()  
{  
   // 指针的指针  
   int a = 123;  
   int* b = &a;  
   int** c = &b;  
  
   // NULL 的使用  
   int* pA = NULL;  
   pA = &a;  
   if (pA != NULL)  //  判断NULL指针  
   {  
      cout << (*pA) << endl;  
   }   pA = NULL;       //  pA不用时，置为NULL  
  
    return 0;  
}
```

![](image/Pasted%20image%2020220917140224.png)

# 原始指针的基本运算

![](image/Pasted%20image%2020220917142455.png)

![](image/Pasted%20image%2020220917153009.png)

```cpp
#include <iostream>  
using namespace std;  
int main()  
{  
   char ch = 'a';  
   // &操作符  
   //&ch = 97;                    // &ch左值不合法   
   char* cp = &ch;                // &ch右值  
   //&cp = 97;                    // &cp左值不合法   
   char** cpp = &cp;              // &cp右值  
  
   // *操作符   *cp = 'a';         // *cp左值取变量ch位置  
   char ch2 = *cp;                // *cp右值取变量ch存储的值  
   //*cp + 1 = 'a';               //  *cp+1左值不合法的位置   
   ch2 = *cp + 1;                 //  *cp+1右值取到的字符做ASCII码+1操作  
   *(cp + 1) = 'a';               //  *(cp+1)左值语法上合法，取ch后面位置  
   ch2 = *(cp + 1);               //  *(cp+1)右值语法上合法，取ch后面位置的值  
  
    return 0;  
}
```

![](image/Pasted%20image%2020220917153624.png)

![](image/Pasted%20image%2020220917155011.png)

![](image/Pasted%20image%2020220917155232.png)

![](image/Pasted%20image%2020220917161212.png)

```cpp
int main()  
{  
   char ch = 'a';  
   char* cp = &ch;  
   // ++,--操作符  
   char* cp2 = ++cp;  
   char* cp3 = cp++;  
   char* cp4 = --cp;  
   char* cp5 = cp--;  
  
   // ++ 左值  
   //++cp2 = 97;   
   //cp2++ = 97;
     
   // *++, ++*   
   *++cp2 = 98;  
   char ch3 = *++cp2;  
   *cp2++ = 98;  
   char ch4 = *cp2++;  
  
   // ++++, ----操作符等  
   int a = 1, b = 2, c, d;  
   //c = a++b;                  // error  
   c = a++ + b;  
   //d = a++++b;                // error  
   char ch5 = ++*++cp;  
  
    return 0;  
}
```

# 程序储存区域划分

![](image/Pasted%20image%2020220917170302.png)

![](image/Pasted%20image%2020220917162942.png)

```cpp
#include <string>  
  
int a = 0;                                    //(GVAR)全局初始化区 
int* p1;                                      //(bss)全局未初始化区 
int main()                                    //(text)代码区  
{  
   int b=1;                                   //(stack)栈区变量   
   char s[] = "abc";                          //(stack)栈区变量  
   int*p2=NULL;                               //(stack)栈区变量  
   char *p3 = "123456";                       //123456\0在常量区, p3在(stack)栈区  
   static int c = 0;                          //(GVAR)全局(静态)初始化区   
   p1 = new int(10);                          //(heap)堆区变量  
   p2 = new int(20);                          //(heap)堆区变量  
   char* p4 = new char[7];                    //(heap)堆区变量  
   strcpy_s(p4, 7, "123456");                 //(text)代码区  
  
   //(text)代码区  
   if (p1 != NULL)  
   {  delete p1;  
      p1 = NULL;  
   }   
   if (p2 != NULL)  
   {      
	  delete p2;  
      p2 = NULL;  
   }   
   if (p4 != NULL)  
   {      
	  delete[ ] p4;  
      p4 = NULL;  
   }   
   //(text)代码区  
   return 0;                                  //(text)代码区  
}
```

# 资源管理方案-RAII

![](image/Pasted%20image%2020220917171759.png)

# 变量的对比

![](image/Pasted%20image%2020220917181402.png)

![](image/Pasted%20image%2020220917181222.png)

# 内存泄漏（Memory Leak）问题

![](image/Pasted%20image%2020220917184046.png)

# 比指针更安全的解决方案（智能指针）

![](image/Pasted%20image%2020220917190142.png)

![](image/Pasted%20image%2020220917221405.png)

```cpp
#include <string>  
#include <iostream>  
#include <memory>  
using namespace std;  
int main() {  
  {
  
    // 确定auto_ptr失效的范围  
    // 对int使用  
    auto_ptr<int> pI(new int(10));  
    cout << *pI << endl;                // 10   
    
    // auto_ptr    C++ 17中移除  拥有严格对象所有权语义的智能指针
    // auto_ptr原理：在拷贝 / 赋值过程中，直接剥夺原对象对内存的控制权，转交给新对象
    // 然后再将原对象指针置为nullptr（早期：NULL）。这种做法也叫管理权转移
    // 他的缺点不言而喻，当我们再次去访问原对象时，程序就会报错，所以auto_ptr可以说实现的不好
    // 很多企业在其库内也是要求不准使用auto_ptr
    
	    auto_ptr<string> languages[5] = {  
        auto_ptr<string>(new string("C")),  
        auto_ptr<string>(new string("Java")),  
        auto_ptr<string>(new string("C++")),  
        auto_ptr<string>(new string("Python")),  
        auto_ptr<string>(new string("Rust"))  
    };    
    cout << "There are some computer languages here first time: \n";  
    for (int i = 0; i < 5; ++i) {  
      cout << *languages[i] << endl;  
    }    
    auto_ptr<string> pC;  
    pC = languages[2]; 
    // languges[2] loses ownership. 将所有权从languges[2]转让给pC
    //此时languges[2]不再引用该字符串从而变成空指针    
    cout << "There are some computer languages here second time: \n";  
    for (int i = 0; i < 2; ++i) {  
      cout << *languages[i] << endl;  
    }    
    cout << "The winner is " << *pC << endl;  
    //cout << "There are some computer languages here third time: \n";  
    //for (int i = 0; i < 5; ++i)    
    //{    
    // cout << *languages[i] << endl;    
    //}  
    }  
    return 0;  
}
```

![](image/Pasted%20image%2020220917223901.png)

```cpp
#include <memory>  
#include <iostream>  
using namespace std;  
int main() {  
  // 在这个范围之外，unique_ptr被释放  
  {  
    auto i = make_unique<int>(10);  
    cout << *i << endl;  
  }  
  // unique_ptr  
  auto w = make_unique<int>(10);  
  cout << *(w.get()) << endl;                             // 10  
  // auto w2 = w; // 编译错误如果想要把 w 复制给 w2, 是不可以的。  
  // 因为复制从语义上来说，两个对象将共享同一块内存。  
  // unique_ptr 只支持移动语义, 即如下  auto w2 = std::move(w); 
  // w2 获得内存所有权，w 此时等于 nullptr  
  cout << ((w != nullptr) ? (*w) : -1) << endl;       // -1  
  cout << ((w2 != nullptr) ? (*w2) : -1) << endl;   // 10  
  return 0;  
}
```

![](image/Pasted%20image%2020220918005812.png)

![](image/Pasted%20image%2020220918010122.png)

![](image/Pasted%20image%2020220918010410.png)

```cpp
#include <iostream>  
#include <memory>  
using namespace std;  
int main() {  
  // shared_ptr  
  {  
    //shared_ptr 代表的是共享所有权，即多个 shared_ptr 可以共享同一块内存。  
    auto wA = shared_ptr<int>(new int(20));  
    {      
      const auto& wA2 = wA;  
      cout << ((wA2 != nullptr) ? (*wA2) : -1) << endl;         // 20  
      cout << ((wA != nullptr) ? (*wA) : -1) << endl;           // 20  
      cout << wA2.use_count() << endl;                          // 2  
      cout << wA.use_count() << endl;                           // 2  
    }  
    //cout << wA2.use_count() << endl;  
    cout << wA.use_count() << endl;                             // 1  
    cout << ((wA != nullptr) ? (*wA) : -1) << endl;             // 20  
    //shared_ptr 内部是利用引用计数来实现内存的自动管理，每当复制一个 shared_ptr    
    // 引用计数会 + 1。当一个 shared_ptr 离开作用域时，引用计数会 - 1   
    // 当引用计数为 0 的时候，则 delete 内存。  
  }  
  
  // move 语法  
  auto wAA = std::make_shared<int>(30);  
  auto wAA2 = std::move(wAA); // 此时 wAA 等于 nullptr，wAA2.use_count() 等于 1  
  cout << ((wAA != nullptr) ? (*wAA) : -1) << endl;            // -1  
  cout << ((wAA2 != nullptr) ? (*wAA2) : -1) << endl;          // 30  
  cout << wAA.use_count() << endl;                             // 0  
  cout << wAA2.use_count() << endl;                            // 1  
  //将 wAA 对象 move 给 wAA2，意味着 wAA 放弃了对内存的所有权和管理，此时 wAA对象等于 nullptr。  
  //而 wAA2 获得了对象所有权，但因为此时 wAA 已不再持有对象，因此 wAA2 的引用计数为 1。  
  return 0;  
}
```

# 引用

![](image/Pasted%20image%2020220918123108.png)

![](image/Pasted%20image%2020220918123948.png)

![](image/Pasted%20image%2020220918124601.png)

![](image/Pasted%20image%2020220918124747.png)