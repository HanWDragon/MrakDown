# 岛问题

一个矩阵中只有0和1两种值，每个位置都可以和自己的上、下、左、右 四个位置相连，如果有一片1连在一起，这个部分叫做一个岛，求一个矩阵中有多少个岛?

**举例**

0  0  1  0  1  0 

1  1  1  0  1  0 

1  0  0  1  0  0 

0  0  0  0  0  0

这个矩阵中有三个岛。

**如何实现**

实现一个函数叫感染，从左向右遍历，找到 1 就执行这个函数

它会实现将一个小岛上的数全部变成 2 

这就相当于找到了一个岛，计数加一

最后查看计数就得到了岛的数量

**进阶**

如何设计一个并行算法解决这个问题

**使用查并集**

记录边界节点信息，合并时查并集，如果不在一个集合，岛数目减一

**代码实现**

```java
package class01;

public class Code03_Islands {

    public static int countIslands(int[][] m) {
        if (m == null || m[0] == null) {
            return 0;
        }
        int N = m.length;
        int M = m[0].length;
        int res = 0;
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                if (m[i][j] == 1) {
                    res++;
                    infect(m, i, j, N, M);
                }
            }
        }
        return res;
    }

    public static void infect(int[][] m, int i, int j, int N, int M) {
        if (i < 0 || i >= N || j < 0 || j >= M || m[i][j] != 1) {
            return;
        }
        m[i][j] = 2;
        infect(m, i + 1, j, N, M);
        infect(m, i - 1, j, N, M);
        infect(m, i, j + 1, N, M);
        infect(m, i, j - 1, N, M);
    }

    public static void main(String[] args) {
        int[][] m1 = {{0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 1, 1, 1, 0, 1, 1, 1, 0},
                {0, 1, 1, 1, 0, 0, 0, 1, 0},
                {0, 1, 1, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 1, 1, 0, 0},
                {0, 0, 0, 0, 1, 1, 1, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0},};
        System.out.println(countIslands(m1));

        int[][] m2 = {{0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 1, 1, 1, 1, 1, 1, 1, 0},
                {0, 1, 1, 1, 0, 0, 0, 1, 0},
                {0, 1, 1, 0, 0, 0, 1, 1, 0},
                {0, 0, 0, 0, 0, 1, 1, 0, 0},
                {0, 0, 0, 0, 1, 1, 1, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0},};
        System.out.println(countIslands(m2));

    }

}

```



# 认识并查集结构

向上指的一个图结构

# 并查集结构的详解和实现

有两个方法

- `boolean isSameSet(a,b)`
- `void union(a,b)`

在每次union的时候，进行优化

把查找的当前节点指向根节点，并把当前节点之后的元素也指向根节点

而且对于时间复杂度它不是一个定数

- 反正只要当前findHead调用次数接近样本数，则平均时间复杂度为 $O(1)$

**代码实现**

```java
package class01;

import java.util.HashMap;
import java.util.List;
import java.util.Stack;

public class Code04_UnionFind {

    public static class Element<V> {
        public V value;

        public Element(V value) {
            this.value = value;
        }

    }

    public static class UnionFindSet<V> {
        //纪录元素的哈希表
        public HashMap<V, Element<V>> elementMap;
        //纪录父节点的哈希表
        public HashMap<Element<V>, Element<V>> fatherMap;
        // key 代表当前的元素  value 代表该集合的大小
        public HashMap<Element<V>, Integer> rankMap;

        //初始化的时候要提供所有元素
        public UnionFindSet(List<V> list) {
            elementMap = new HashMap<>();
            fatherMap = new HashMap<>();
            rankMap = new HashMap<>();
            //装入元素
            for (V value : list) {
                Element<V> element = new Element<V>(value);
                elementMap.put(value, element);
                fatherMap.put(element, element);
                rankMap.put(element, 1);
            }
        }

        //在这个部分进行优化
        private Element<V> findHead(Element<V> element) {
            Stack<Element<V>> path = new Stack<>();
            //向上查找
            while (element != fatherMap.get(element)) {
                path.push(element);
                element = fatherMap.get(element);
            }
            //扁平化
            while (!path.isEmpty()) {
                fatherMap.put(path.pop(), element);
            }
            return element;
        }

        public boolean isSameSet(V a, V b) {
            //检查是否初始化
            if (elementMap.containsKey(a) && elementMap.containsKey(b)) {
                return findHead(elementMap.get(a)) == findHead(elementMap.get(b));
            }
            return false;
        }

        public void union(V a, V b) {
            //检查是否初始化
            if (elementMap.containsKey(a) && elementMap.containsKey(b)) {
                //找到父节点
                Element<V> aF = findHead(elementMap.get(a));
                Element<V> bF = findHead(elementMap.get(b));
                //不是同一个父节点
                if (aF != bF) {
                    //选出哪个节点数量较大
                    Element<V> big = rankMap.get(aF) >= rankMap.get(bF) ? aF : bF;
                    //选出较小元素
                    Element<V> small = big == aF ? bF : aF;
                    fatherMap.put(small, big);
                    rankMap.put(big, rankMap.get(aF) + rankMap.get(bF));
                    rankMap.remove(small);
                }
            }
        }

    }

}

```
