# 由一个代表题目，引出一种结构
 **题目**

有一个整型数组arr和一个大小为w的窗口从数组的最左边滑到最右边

窗口每次 向右边滑一个位置

窗口只能右边界或左边界向右滑的情况下，维持窗口内部最大值或者最小值快速更新的结构
**例如**

数组为`[4,3,5,4,3,3,6,7]`  窗口大小为 3 时

```java
//窗口中最大值为5 
[4 3 5]4 3 3 6 7 
//窗口中最大值为5 
4[3 5 4]3 3 6 7
//窗口中最大值为5 
4 3[5 4 3]3 6 7
//窗口中最大值为4
4 3 5[4 3 3]6 7
//窗口中最大值为6 
4 3 5 4[3 3 6]7
//窗口中最大值为7
4 3 5 4 3[3 6 7]
```


如果数组长度为 `n` ，窗口大小为w，则一共产生n-w+1个窗口的最大值。

请实现一个函数

**输入**

整型数组`arr`  窗口大小为`w`

**输出**

一个长度为 `n-w+1` 的数组 `res`   `res[i]`表示每一种窗口状态下的 

以本题为例，结果应该 返回`{5,5,5,4,6,7}`

**如何实现**

使用一个双端队列来完成

这个双端队列，头部大，尾部小，内部存放着数组的索引，严格维护单调性

就这样就完成了这个结构

分为两种情况

- 窗口左侧向右

	判断那个移出的节点，在双端队列头部吗

	如果在移出双端队列，不在则不动

- 窗口右侧向右

	从尾部进去，严格维护单调性

**代码实现**

```java
package class04;

import java.util.LinkedList;

public class Code01_SlidingWindowMaxArray {

    public static int[] getMaxWindow(int[] arr, int w) {
        if (arr == null || w < 1 || arr.length < w) {
            return null;
        }
        LinkedList<Integer> qmax = new LinkedList<Integer>();
        int[] res = new int[arr.length - w + 1];
        int index = 0;
        for (int i = 0; i < arr.length; i++) {
            while (!qmax.isEmpty() && arr[qmax.peekLast()] <= arr[i]) {
                qmax.pollLast();
            }
            qmax.addLast(i);
            if (qmax.peekFirst() == i - w) {
                qmax.pollFirst();
            }
            if (i >= w - 1) {
                res[index++] = arr[qmax.peekFirst()];
            }
        }
        return res;
    }

    // for test
    public static void printArray(int[] arr) {
        for (int i = 0; i != arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        int[] arr = {4, 3, 5, 4, 3, 3, 6, 7};
        int w = 3;
        printArray(getMaxWindow(arr, w));

    }

}

```

# 单调栈结构

**解决问题**

在数组中想找到一个数，左边和右边比这个数大、且离这个数最近的位置 

如果对每一个数都想求这样的信息，能不能整体代价达到 $O(N)$

**如何解决**

准备一个栈（内部存放的都是索引值），提供的的元素都是严格由大到小的（无重复值）

假设当前栈中元素都无重复值

此时有三个元素 `a b c` 此时 `a > b , c > a` 

那么此时就会发生弹栈，`a` 要弹出栈

此时有个结论就是,对于 `a` 来说，左边比它大的最近的数是 `b`，右边比它大的最近的数是 `c` 

**如何证明**

因为在 `a ~ c` 这个范围内如果有任何一个数大于 `a` 此时都会发生弹栈，得不到这个结果

所以 `c` 第一个比 `a` 大的数字，对于 `b` 来说它肯定是大于 `a` 的并且也是离 `a` 最近的一个数

并且处于此时的条件 `b ～a` 之间的元素都是小于 `a`  的所以得出了这个结论 

对于一个数来说，左边比它大的最近的数是在栈上它压着的那个数字，右边比它大的最近的数是让它弹栈的数字

**当有重复值**

原理差不多

就是里面存放的元素从数字，变成链表了

其他的不变，每次看链表最后一个元素

**代码实现**

```java
package class04;

import java.util.List;
import java.util.ArrayList;
import java.util.Stack;

public class Code02_MonotonousStack {

    public static int[][] getNearLessNoRepeat(int[] arr) {
        int[][] res = new int[arr.length][2];
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < arr.length; i++) {
            while (!stack.isEmpty() && arr[stack.peek()] > arr[i]) {
                int popIndex = stack.pop();
                int leftLessIndex = stack.isEmpty() ? -1 : stack.peek();
                res[popIndex][0] = leftLessIndex;
                res[popIndex][1] = i;
            }
            stack.push(i);
        }
        while (!stack.isEmpty()) {
            int popIndex = stack.pop();
            int leftLessIndex = stack.isEmpty() ? -1 : stack.peek();
            res[popIndex][0] = leftLessIndex;
            res[popIndex][1] = -1;
        }
        return res;
    }

    public static int[][] getNearLess(int[] arr) {
        int[][] res = new int[arr.length][2];
        Stack<List<Integer>> stack = new Stack<>();
        for (int i = 0; i < arr.length; i++) {
            while (!stack.isEmpty() && arr[stack.peek().get(0)] > arr[i]) {
                List<Integer> popIs = stack.pop();
                // 取位于下面位置的列表中，最晚加入的那个
                int leftLessIndex = stack.isEmpty() ? -1 : stack.peek().get(
                        stack.peek().size() - 1);
                for (Integer popi : popIs) {
                    res[popi][0] = leftLessIndex;
                    res[popi][1] = i;
                }
            }
            if (!stack.isEmpty() && arr[stack.peek().get(0)] == arr[i]) {
                stack.peek().add(Integer.valueOf(i));
            } else {
                ArrayList<Integer> list = new ArrayList<>();
                list.add(i);
                stack.push(list);
            }
        }
        while (!stack.isEmpty()) {
            List<Integer> popIs = stack.pop();
            // 取位于下面位置的列表中，最晚加入的那个
            int leftLessIndex = stack.isEmpty() ? -1 : stack.peek().get(
                    stack.peek().size() - 1);
            for (Integer popi : popIs) {
                res[popi][0] = leftLessIndex;
                res[popi][1] = -1;
            }
        }
        return res;
    }

    // for test
    public static int[] getRandomArrayNoRepeat(int size) {
        int[] arr = new int[(int) (Math.random() * size) + 1];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = i;
        }
        for (int i = 0; i < arr.length; i++) {
            int swapIndex = (int) (Math.random() * arr.length);
            int tmp = arr[swapIndex];
            arr[swapIndex] = arr[i];
            arr[i] = tmp;
        }
        return arr;
    }

    // for test
    public static int[] getRandomArray(int size, int max) {
        int[] arr = new int[(int) (Math.random() * size) + 1];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int) (Math.random() * max) - (int) (Math.random() * max);
        }
        return arr;
    }

    // for test
    public static int[][] rightWay(int[] arr) {
        int[][] res = new int[arr.length][2];
        for (int i = 0; i < arr.length; i++) {
            int leftLessIndex = -1;
            int rightLessIndex = -1;
            int cur = i - 1;
            while (cur >= 0) {
                if (arr[cur] < arr[i]) {
                    leftLessIndex = cur;
                    break;
                }
                cur--;
            }
            cur = i + 1;
            while (cur < arr.length) {
                if (arr[cur] < arr[i]) {
                    rightLessIndex = cur;
                    break;
                }
                cur++;
            }
            res[i][0] = leftLessIndex;
            res[i][1] = rightLessIndex;
        }
        return res;
    }

    // for test
    public static boolean isEqual(int[][] res1, int[][] res2) {
        if (res1.length != res2.length) {
            return false;
        }
        for (int i = 0; i < res1.length; i++) {
            if (res1[i][0] != res2[i][0] || res1[i][1] != res2[i][1]) {
                return false;
            }
        }

        return true;
    }

    // for test
    public static void printArray(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        int size = 10;
        int max = 20;
        int testTimes = 2000000;
        for (int i = 0; i < testTimes; i++) {
            int[] arr1 = getRandomArrayNoRepeat(size);
            int[] arr2 = getRandomArray(size, max);
            if (!isEqual(getNearLessNoRepeat(arr1), rightWay(arr1))) {
                System.out.println("Oops!");
                printArray(arr1);
                break;
            }
            if (!isEqual(getNearLess(arr2), rightWay(arr2))) {
                System.out.println("Oops!");
                printArray(arr2);
                break;
            }
        }
    }
}

```

# 单调栈的应用

**题目**

数组中累积和与最小值的乘积，假设叫做指标A 

给定一个数组，请返回**子数组**中，指标A最大的值

**使用单调栈**

子数组必须是一个连续的数组序列

选择出一个数作为最小值，用单调栈求出一个范围

用最大范围求出累计和，再乘以这个最小值

放在堆中然后便可快速得到最大值

**代码实现**

```java
package class04;

import java.util.Stack;

public class Code03_AllTimesMinToMax {

    public static int max1(int[] arr) {
        int max = Integer.MIN_VALUE;
        for (int i = 0; i < arr.length; i++) {
            for (int j = i; j < arr.length; j++) {
                int minNum = Integer.MAX_VALUE;
                int sum = 0;
                for (int k = i; k <= j; k++) {
                    sum += arr[k];
                    minNum = Math.min(minNum, arr[k]);
                }
                max = Math.max(max, minNum * sum);
            }
        }
        return max;
    }

    public static int max2(int[] arr) {
        int size = arr.length;
        int[] sums = new int[size];
        sums[0] = arr[0];
        for (int i = 1; i < size; i++) {
            sums[i] = sums[i - 1] + arr[i];
        }
        int max = Integer.MIN_VALUE;
        Stack<Integer> stack = new Stack<Integer>();
        for (int i = 0; i < size; i++) {
            while (!stack.isEmpty() && arr[stack.peek()] >= arr[i]) {
                int j = stack.pop();
                max = Math.max(max, (stack.isEmpty() ? sums[i - 1] : (sums[i - 1] - sums[stack.peek()])) * arr[j]);
            }
            stack.push(i);
        }
        while (!stack.isEmpty()) {
            int j = stack.pop();
            max = Math.max(max, (stack.isEmpty() ? sums[size - 1] : (sums[size - 1] - sums[stack.peek()])) * arr[j]);
        }
        return max;
    }

    public static int[] gerenareRondomArray() {
        int[] arr = new int[(int) (Math.random() * 20) + 10];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int) (Math.random() * 101);
        }
        return arr;
    }

    public static void main(String[] args) {
        int testTimes = 2000000;
        for (int i = 0; i < testTimes; i++) {
            int[] arr = gerenareRondomArray();
            if (max1(arr) != max2(arr)) {
                System.out.println("FUCK!");
                break;
            }
        }

    }

}
```

 