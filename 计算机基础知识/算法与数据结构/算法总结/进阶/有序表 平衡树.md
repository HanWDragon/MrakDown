# 有序表 $(o(log{N} ))$

- AVL树
- SB树
- 红黑树
- 跳表

# 何为具有平衡性的树?

就是具有解决左右子树高度相差过大的问题的能力

# 介绍树的左旋和右旋

**左旋**

就是将当前的最小不平衡子树的根节点的右子树指向根节点的右子树的左子树，右子树的左子树指向当前的根节点，然后当前最小不平衡子树的父节点重新指向到之前根节点的右子树

**右旋**

就是将当前的最小不平衡子树的根节点的左子树指向根节点的右子树的左子树，右子树的左子树指向当前的根节点，然后当前最小不平衡子树的父节点重新指向到之前根节点的左子树


# 介绍AVL树及其实现

1. 当插入或者删除一个节点时，可能会让整棵AVL不平衡

	此时，只需要把最小不平衡子树调整即可恢复整体的平衡性。

2. 介绍树的`LL，RR，LR，RL`调整

	- LL 左孩子的左边过长，导致不平衡

		这个时候执行右旋就达到了目的

	- RR 左孩子的右边过长，导致不平衡

		这个时候执行左旋就达到了目的

	- LR 就把导致不平衡的这颗右树的头部变为当前树的根节点，需要多次旋转

		首先将那个不平衡的右树的父亲节点进行左旋变成了 LL 就按之前的处理就行

	- RL 就把导致不平衡的这颗左树的头部变为当前树的根节点，需要多次旋转

		首先将那个不平衡的左树的父亲节点进行右旋变成了 RR 就按之前的处理就行

3. 介绍插入节点时的调整细节

	就是检查高度，然后按照左旋和右旋进行调整

4. 介绍删除节点时的调整细节

	检查节点的是否有左孩子和右孩子在按照情况来处理

**代码实现**

```java
package class02;

/**
 * Not implemented by zuochengyun
 * <p>
 * AVL tree implementation.
 * <p>
 * In computer science, an AVL tree is a self-balancing binary search tree, and
 * it was the first such data structure to be invented.[1] In an AVL tree, the
 * heights of the two child subtrees of any node differ by at most one. Lookup,
 * insertion, and deletion all take O(log n) time in both the average and worst
 * cases, where n is the number of nodes in the tree prior to the operation.
 * Insertions and deletions may require the tree to be rebalanced by one or more
 * tree rotations.
 *
 * @author Ignas Lelys
 * @created Jun 28, 2011
 */
public class AVLTree extends AbstractSelfBalancingBinarySearchTree {

    /**
     * @see trees.AbstractBinarySearchTree#insert(int)
     * <p>
     * AVL tree insert method also balances tree if needed. Additional
     * height parameter on node is used to track if one subtree is higher
     * than other by more than one, if so AVL tree rotations is performed
     * to regain balance of the tree.
     */
    @Override
    public Node insert(int element) {
        Node newNode = super.insert(element);
        rebalance((AVLNode) newNode);
        return newNode;
    }

    /**
     * @see trees.AbstractBinarySearchTree#delete(int)
     */
    @Override
    public Node delete(int element) {
        Node deleteNode = super.search(element);
        if (deleteNode != null) {
            Node successorNode = super.delete(deleteNode);
            if (successorNode != null) {
                // if replaced from getMinimum(deleteNode.right) then come back there and update heights
                AVLNode minimum = successorNode.right != null ? (AVLNode) getMinimum(successorNode.right) : (AVLNode) successorNode;
                recomputeHeight(minimum);
                rebalance((AVLNode) minimum);
            } else {
                recomputeHeight((AVLNode) deleteNode.parent);
                rebalance((AVLNode) deleteNode.parent);
            }
            return successorNode;
        }
        return null;
    }

    /**
     * @see trees.AbstractBinarySearchTree#createNode(int, trees.AbstractBinarySearchTree.Node, trees.AbstractBinarySearchTree.Node, trees.AbstractBinarySearchTree.Node)
     */
    @Override
    protected Node createNode(int value, Node parent, Node left, Node right) {
        return new AVLNode(value, parent, left, right);
    }

    /**
     * Go up from inserted node, and update height and balance informations if needed.
     * If some node balance reaches 2 or -2 that means that subtree must be rebalanced.
     *
     * @param node Inserted Node.
     */
    private void rebalance(AVLNode node) {
        while (node != null) {

            Node parent = node.parent;

            int leftHeight = (node.left == null) ? -1 : ((AVLNode) node.left).height;
            int rightHeight = (node.right == null) ? -1 : ((AVLNode) node.right).height;
            int nodeBalance = rightHeight - leftHeight;
            // rebalance (-2 means left subtree outgrow, 2 means right subtree)
            if (nodeBalance == 2) {
                if (node.right.right != null) {
                    node = (AVLNode) avlRotateLeft(node);
                    break;
                } else {
                    node = (AVLNode) doubleRotateRightLeft(node);
                    break;
                }
            } else if (nodeBalance == -2) {
                if (node.left.left != null) {
                    node = (AVLNode) avlRotateRight(node);
                    break;
                } else {
                    node = (AVLNode) doubleRotateLeftRight(node);
                    break;
                }
            } else {
                updateHeight(node);
            }

            node = (AVLNode) parent;
        }
    }

    /**
     * Rotates to left side.
     */
    private Node avlRotateLeft(Node node) {
        Node temp = super.rotateLeft(node);

        updateHeight((AVLNode) temp.left);
        updateHeight((AVLNode) temp);
        return temp;
    }

    /**
     * Rotates to right side.
     */
    private Node avlRotateRight(Node node) {
        Node temp = super.rotateRight(node);

        updateHeight((AVLNode) temp.right);
        updateHeight((AVLNode) temp);
        return temp;
    }

    /**
     * Take right child and rotate it to the right side first and then rotate
     * node to the left side.
     */
    protected Node doubleRotateRightLeft(Node node) {
        node.right = avlRotateRight(node.right);
        return avlRotateLeft(node);
    }

    /**
     * Take right child and rotate it to the right side first and then rotate
     * node to the left side.
     */
    protected Node doubleRotateLeftRight(Node node) {
        node.left = avlRotateLeft(node.left);
        return avlRotateRight(node);
    }

    /**
     * Recomputes height information from the node and up for all of parents. It needs to be done after delete.
     */
    private void recomputeHeight(AVLNode node) {
        while (node != null) {
            node.height = maxHeight((AVLNode) node.left, (AVLNode) node.right) + 1;
            node = (AVLNode) node.parent;
        }
    }

    /**
     * Returns higher height of 2 nodes.
     */
    private int maxHeight(AVLNode node1, AVLNode node2) {
        if (node1 != null && node2 != null) {
            return node1.height > node2.height ? node1.height : node2.height;
        } else if (node1 == null) {
            return node2 != null ? node2.height : -1;
        } else if (node2 == null) {
            return node1 != null ? node1.height : -1;
        }
        return -1;
    }

    /**
     * Updates height and balance of the node.
     *
     * @param node Node for which height and balance must be updated.
     */
    private static final void updateHeight(AVLNode node) {
        int leftHeight = (node.left == null) ? -1 : ((AVLNode) node.left).height;
        int rightHeight = (node.right == null) ? -1 : ((AVLNode) node.right).height;
        node.height = 1 + Math.max(leftHeight, rightHeight);
    }

    /**
     * Node of AVL tree has height and balance additional properties. If balance
     * equals 2 (or -2) that node needs to be re balanced. (Height is height of
     * the subtree starting with this node, and balance is difference between
     * left and right nodes heights).
     *
     * @author Ignas Lelys
     * @created Jun 30, 2011
     */
    protected static class AVLNode extends Node {
        public int height;

        public AVLNode(int value, Node parent, Node left, Node right) {
            super(value, parent, left, right);
        }
    }

}
```

# 每种树的平衡判断标准

- 红黑树

	颜色

- SB树

	节点个数比较

- AVL树

	高度差

# 介绍SB树及其实现

**平衡性**

每棵子树的大小，不小于其兄弟的子树大小

就是每棵叔叔树的大小，不小于其任何侄子树的大小

**如何实现**

比较节点大小

**代码实现**

```java
package class02;

import java.util.ArrayList;

public class Code02_SizeBalancedTreeMap {

    public static class SizeBalancedTreeMap<K extends Comparable<K>, V> {
        private int root;
        private int len;
        private int[] left;
        private int[] right;
        private int[] size;
        private ArrayList<K> keys;
        private ArrayList<V> values;

        public SizeBalancedTreeMap(int init) {
            left = new int[init + 1];
            right = new int[init + 1];
            size = new int[init + 1];
            keys = new ArrayList<K>();
            values = new ArrayList<V>();
            keys.add(null);
            values.add(null);
            root = 0;
            len = 0;
        }

        private int rightRotate(int index) {
            int iLeft = left[index];
            left[index] = right[iLeft];
            right[iLeft] = index;
            size[iLeft] = size[index];
            size[index] = size[left[index]] + size[right[index]] + 1;
            return iLeft;
        }

        private int leftRotate(int index) {
            int iRight = right[index];
            right[index] = left[iRight];
            left[iRight] = index;
            size[iRight] = size[index];
            size[index] = size[left[index]] + size[right[index]] + 1;
            return iRight;
        }

        private int matain(int index) {
            if (size[left[left[index]]] > size[right[index]]) {
                index = rightRotate(index);
                right[index] = matain(right[index]);
                index = matain(index);
            } else if (size[right[left[index]]] > size[right[index]]) {
                left[index] = leftRotate(left[index]);
                index = rightRotate(index);
                left[index] = matain(left[index]);
                right[index] = matain(right[index]);
                index = matain(index);
            } else if (size[right[right[index]]] > size[left[index]]) {
                index = leftRotate(index);
                left[index] = matain(left[index]);
                index = matain(index);
            } else if (size[left[right[index]]] > size[left[index]]) {
                right[index] = rightRotate(right[index]);
                index = leftRotate(index);
                left[index] = matain(left[index]);
                right[index] = matain(right[index]);
                index = matain(index);
            }
            return index;
        }

        private int findLastIndex(K key) {
            int pre = root;
            int cur = root;
            while (cur != 0) {
                pre = cur;
                if (key.compareTo(keys.get(cur)) == 0) {
                    break;
                } else if (key.compareTo(keys.get(cur)) < 0) {
                    cur = left[cur];
                } else {
                    cur = right[cur];
                }
            }
            return pre;
        }

        private int findLastNoSmallIndex(K key) {
            int ans = 0;
            int cur = root;
            while (cur != 0) {
                if (key.compareTo(keys.get(cur)) == 0) {
                    ans = cur;
                    break;
                } else if (key.compareTo(keys.get(cur)) < 0) {
                    ans = cur;
                    cur = left[cur];
                } else {
                    cur = right[cur];
                }
            }
            return ans;
        }

        private int findLastNoBigIndex(K key) {
            int ans = 0;
            int cur = root;
            while (cur != 0) {
                if (key.compareTo(keys.get(cur)) == 0) {
                    ans = cur;
                    break;
                } else if (key.compareTo(keys.get(cur)) < 0) {
                    cur = left[cur];
                } else {
                    ans = cur;
                    cur = right[cur];
                }
            }
            return ans;
        }

        private int add(int index, K key, V value) {
            if (index == 0) {
                index = ++len;
                keys.add(key);
                values.add(value);
                size[index] = 1;
                left[index] = 0;
                right[index] = 0;
                return index;
            } else {
                size[index]++;
                if (key.compareTo(keys.get(index)) < 0) {
                    left[index] = add(left[index], key, value);
                } else {
                    right[index] = add(right[index], key, value);
                }
                return matain(index);
            }
        }

        private int getIndex(int index, int kth) {
            if (kth == size[left[index]] + 1) {
                return index;
            } else if (kth <= size[left[index]]) {
                return getIndex(left[index], kth);
            } else {
                return getIndex(right[index], kth - size[left[index]] - 1);
            }
        }

        public int size() {
            return len;
        }

        public boolean containsKey(K key) {
            if (key == null) {
                throw new RuntimeException("invalid parameter.");
            }
            int lastIndex = findLastIndex(key);
            return lastIndex != 0 && key.compareTo(keys.get(lastIndex)) == 0 ? true : false;
        }

        public void put(K key, V value) {
            if (key == null) {
                throw new RuntimeException("invalid parameter.");
            }
            if (len == size.length - 1) {
                throw new RuntimeException("size balanced tree is full.");
            }
            int lastIndex = findLastIndex(key);
            if (lastIndex != 0 && key.compareTo(keys.get(lastIndex)) == 0) {
                values.set(lastIndex, value);
            } else {
                root = add(root, key, value);
            }
        }

        public K getIndexKey(int index) {
            if (index < 0 || index >= len) {
                throw new RuntimeException("invalid parameter.");
            }
            return keys.get(getIndex(root, index + 1));
        }

        public V getIndexValue(int index) {
            if (index < 0 || index >= len) {
                throw new RuntimeException("invalid parameter.");
            }
            return values.get(getIndex(root, index + 1));
        }

        public V get(K key) {
            if (key == null) {
                throw new RuntimeException("invalid parameter.");
            }
            int lastIndex = findLastIndex(key);
            if (lastIndex != 0 && key.compareTo(keys.get(lastIndex)) == 0) {
                return values.get(lastIndex);
            } else {
                return null;
            }
        }

        public K firstKey() {
            int cur = root;
            while (left[cur] != 0) {
                cur = left[cur];
            }
            return cur == 0 ? null : keys.get(cur);
        }

        public K lastKey() {
            int cur = root;
            while (right[cur] != 0) {
                cur = right[cur];
            }
            return cur == 0 ? null : keys.get(cur);
        }

        public K floorKey(K key) {
            if (key == null) {
                throw new RuntimeException("invalid parameter.");
            }
            int lastNoBigIndex = findLastNoBigIndex(key);
            return lastNoBigIndex == 0 ? null : keys.get(lastNoBigIndex);
        }

        public K ceilingKey(K key) {
            if (key == null) {
                throw new RuntimeException("invalid parameter.");
            }
            int lastNoSmallIndex = findLastNoSmallIndex(key);
            return lastNoSmallIndex == 0 ? null : keys.get(lastNoSmallIndex);
        }
    }

    public static void main(String[] args) {
        SizeBalancedTreeMap<String, Integer> sbt = new SizeBalancedTreeMap<String, Integer>(10000);

        sbt.put("pos", 512);
        sbt.put("zyp", 7123);
        sbt.put("unz", 542);
        sbt.put("abc", 5113);
        sbt.put("yzk", 665);
        sbt.put("fgi", 38776);
        sbt.put("bke", 2500540);
        sbt.put("lmn", 44334);
        sbt.put("abc", 11);
        sbt.put("abc", 111);

        for (int i = 0; i < sbt.size(); i++) {
            System.out.println(sbt.getIndexKey(i) + " , " + sbt.getIndexValue(i));
        }
        System.out.println(sbt.get("abc"));
        System.out.println(sbt.firstKey());
        System.out.println(sbt.lastKey());
        System.out.println(sbt.floorKey("bke"));
        System.out.println(sbt.ceilingKey("bke"));
        System.out.println(sbt.floorKey("ooo"));
        System.out.println(sbt.ceilingKey("ooo"));
        System.out.println(sbt.floorKey("aaa"));
        System.out.println(sbt.ceilingKey("aaa"));
        System.out.println(sbt.floorKey("zzz"));
        System.out.println(sbt.ceilingKey("zzz"));

    }

}

```

# 介绍SkipList及其实现

**平衡性**

利用随机函数打破输入规律

**如何实现**

就是通过随机产生执指针来让自己的变得快速

**代码实现**

```java
package class02;

import java.util.ArrayList;

public class Code03_SkipListMap {

    public static class SkipListNode<K extends Comparable<K>, V> {
        public K key;
        public V val;
        public ArrayList<SkipListNode<K, V>> nextNodes;

        public SkipListNode(K k, V v) {
            key = k;
            val = v;
            nextNodes = new ArrayList<SkipListNode<K, V>>();
        }

        public boolean isKeyLess(K otherKey) {
            return otherKey != null && (key == null || key.compareTo(otherKey) < 0);
        }

        public boolean isKeyEqual(K otherKey) {
            return (key == null && otherKey == null)
                    || (key != null && otherKey != null && key.compareTo(otherKey) == 0);
        }

    }

    public static class SkipListMap<K extends Comparable<K>, V> {
        private static final double PROBABILITY = 0.5;
        private SkipListNode<K, V> head;
        private int size;
        private int maxLevel;

        public SkipListMap() {
            head = new SkipListNode<K, V>(null, null);
            head.nextNodes.add(null);
            size = 0;
            maxLevel = 0;
        }

        private SkipListNode<K, V> mostRightLessNodeInTree(K key) {
            if (key == null) {
                return null;
            }
            int level = maxLevel;
            SkipListNode<K, V> cur = head;
            while (level >= 0) {
                cur = mostRightLessNodeInLevel(key, cur, level--);
            }
            return cur;
        }

        private SkipListNode<K, V> mostRightLessNodeInLevel(K key, SkipListNode<K, V> cur, int level) {
            SkipListNode<K, V> next = cur.nextNodes.get(level);
            while (next != null && next.isKeyLess(key)) {
                cur = next;
                next = cur.nextNodes.get(level);
            }
            return cur;
        }

        public boolean containsKey(K key) {
            if (key == null) {
                return false;
            }
            SkipListNode<K, V> less = mostRightLessNodeInTree(key);
            SkipListNode<K, V> next = less.nextNodes.get(0);
            return next != null && next.isKeyEqual(key);
        }

        public void put(K key, V value) {
            if (key == null) {
                return;
            }
            SkipListNode<K, V> less = mostRightLessNodeInTree(key);
            SkipListNode<K, V> find = less.nextNodes.get(0);
            if (find != null && find.isKeyEqual(key)) {
                find.val = value;
            } else {
                size++;
                int newNodeLevel = 0;
                while (Math.random() < PROBABILITY) {
                    newNodeLevel++;
                }
                while (newNodeLevel > maxLevel) {
                    head.nextNodes.add(null);
                    maxLevel++;
                }
                SkipListNode<K, V> newNode = new SkipListNode<K, V>(key, value);
                for (int i = 0; i <= newNodeLevel; i++) {
                    newNode.nextNodes.add(null);
                }
                int level = maxLevel;
                SkipListNode<K, V> pre = head;
                while (level >= 0) {
                    pre = mostRightLessNodeInLevel(key, pre, level);
                    if (level <= newNodeLevel) {
                        newNode.nextNodes.set(level, pre.nextNodes.get(level));
                        pre.nextNodes.set(level, newNode);
                    }
                    level--;
                }
            }
        }

        public V get(K key) {
            if (key == null) {
                return null;
            }
            SkipListNode<K, V> less = mostRightLessNodeInTree(key);
            SkipListNode<K, V> next = less.nextNodes.get(0);
            return next != null && next.isKeyEqual(key) ? next.val : null;
        }

        public void remove(K key) {
            if (containsKey(key)) {
                size--;
                int level = maxLevel;
                SkipListNode<K, V> pre = head;
                while (level >= 0) {
                    pre = mostRightLessNodeInLevel(key, pre, level);
                    SkipListNode<K, V> next = pre.nextNodes.get(level);
                    if (next != null && next.isKeyEqual(key)) {
                        // free delete node memory -> C++
                        pre.nextNodes.set(level, next.nextNodes.get(level));
                    }
                    if (level != 0 && pre == head && pre.nextNodes.get(level) == null) {
                        head.nextNodes.remove(level);
                        maxLevel--;
                    }
                    level--;
                }
            }
        }

        public K firstKey() {
            return head.nextNodes.get(0) != null ? head.nextNodes.get(0).key : null;
        }

        public K lastKey() {
            int level = maxLevel;
            SkipListNode<K, V> cur = head;
            while (level >= 0) {
                SkipListNode<K, V> next = cur.nextNodes.get(level);
                while (next != null) {
                    cur = next;
                    next = cur.nextNodes.get(level);
                }
                level--;
            }
            return cur.key;
        }

        public K ceillingKey(K key) {
            if (key == null) {
                return null;
            }
            SkipListNode<K, V> less = mostRightLessNodeInTree(key);
            SkipListNode<K, V> next = less.nextNodes.get(0);
            return next != null ? next.key : null;
        }

        public K floorKey(K key) {
            if (key == null) {
                return null;
            }
            SkipListNode<K, V> less = mostRightLessNodeInTree(key);
            SkipListNode<K, V> next = less.nextNodes.get(0);
            return next != null && next.isKeyEqual(key) ? next.key : less.key;
        }

        public int size() {
            return size;
        }

    }

    // for test
    public static void printAll(SkipListMap<String, String> obj) {
        for (int i = obj.maxLevel; i >= 0; i--) {
            System.out.print("Level " + i + " : ");
            SkipListNode<String, String> cur = obj.head;
            while (cur.nextNodes.get(i) != null) {
                SkipListNode<String, String> next = cur.nextNodes.get(i);
                System.out.print("(" + next.key + " , " + next.val + ") ");
                cur = next;
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        SkipListMap<String, String> test = new SkipListMap<>();
        printAll(test);
        System.out.println("======================");
        test.put("A", "10");
        printAll(test);
        System.out.println("======================");
        test.remove("A");
        printAll(test);
        System.out.println("======================");
        test.put("E", "E");
        test.put("B", "B");
        test.put("A", "A");
        test.put("F", "F");
        test.put("C", "C");
        test.put("D", "D");
        printAll(test);
        System.out.println("======================");
        System.out.println(test.containsKey("B"));
        System.out.println(test.containsKey("Z"));
        System.out.println(test.firstKey());
        System.out.println(test.lastKey());
        System.out.println(test.floorKey("D"));
        System.out.println(test.ceillingKey("D"));
        System.out.println("======================");
        test.remove("D");
        printAll(test);
        System.out.println("======================");
        System.out.println(test.floorKey("D"));
        System.out.println(test.ceillingKey("D"));

    }

}

```

# 社会嗑

1. 简历怎么准备

	- 模版

2. 不同的公司面试考什么?

	- 非算法和数据结构的其他基础内容
	- 算法和数据结构的内容
	- 系统设计

3. 该怎么准备? 

	- 背
	- 练
	- 看 

4. 面试过程的心态

	- 让别人喜欢你 
	- 你也在面试公司

5. 要想做清楚自己是要做技术型人才，还是一生就囚禁在业务中

	要不停的学习让自己成长，业务只能解决自己的温饱，但技术是自己一生的本领
	
6. 关于面试和笔试

	| 方式 | 业务   | 技巧   | 通过     |
	| ---- | ------ | ------ | -------- |
	| 笔试 | $55\%$ | $45\%$ | $35/100$ |
	| 面试 | $30\%$ | $70\%$ |          |

	