# 大数据题目的解题技巧


1. 哈希函数可以把数据按照种类均匀分流
2. 布隆过滤器用于集合的建立与查询，并可以节省大量空间
3. 一致性哈希解决数据服务器的负载管理问题
4. 利用并查集结构做岛问题的并行计算
5. 位图解决某一范围上数字的出现情况，并可以节省大量空间
6. 利用分段统计思想、并进一步节省大量空间
7. 利用堆、外排序来做多个处理单元的结果合并

之前已经介绍过过前4个内容（在基础笔记中）

这一节为大家介绍解决大数据题目的后3个技巧

# 题目一

32位无符号整数的范围是`0~4,294,967,295`，现在有一个正好包含40亿个无符号整数的文件，所以在整个范围中必然存在没出现过的数

可以使用最多1GB的内存，怎么找到所有未出现过的数?

**如何解决**

使用位图，用 bit 作为单位，检测一个数就把对应 bit 设置为 1 ，当完成这个文件中数字的遍历，就可以读取位图中的信息，来看那些数字没有出现过

**进阶**
内存限制为 10MB，但是只用找到一个没出现过的数即可

**如何解决**

将**词频数组**等分为 $2^n$​ 份，份数不要太少，然后当完成这个文件中数字的遍历，每次将文件中取出的数除以每个区间的个数

计算完成后，必有一个数组的个数要小于均分的个数，那么这一段区间就存在那个没出现的数字，继续向下均分，最后得到结果

**假如只有几个变量能够使用呢**

那就二分呗，但是时间贼长就是的了

# 题目二

有一个包含100亿个URL的大文件，假设每个URL占用64B，请找出其中所有重复的URL 

- 布隆过滤器
- 通过哈希函数分流

**补充**

某搜索公司一天的用户搜索词汇是海量的(百亿数据量)，请设计一种求出每天热门Top100 词汇的可行办法

- 使用大根堆排序

# 题目三

32位无符号整数的范围是`0~4294967295`，现在有40亿个无符号整数，可以使用最多1GB的内存，找出所有出现了两次的数。

- 使用哈希分流 -> 再使用哈希表

- 但是这种题建议使用位图

	我们原先使用位图都是用单个比特来标记是否出现

	那么我们可以使用多个比特来表示多个状态

	00 -> 出现了 0 次

	01 -> 出现了 1 次

	10 -> 出现了 2 次

	11 -> 出现了 3 次  

	

**补充** 

可以使用最多10MB的内存，怎么找到这40亿个整数的中位数?

- 将**词频数组**等分为 $2^n$​ 份，份数不要太少，然后当完成这个文件中数字的遍历，每次将文件中取出的数除以每个区间的个数

	计算完成后，将每个数组的词频统计相加，当累加和刚好大于等于所有数字个数的一半，得到的这个区间就是中位数存在的区域

	周而复始得到最后的结果

# 题目四

**位运算的题目**
之前介绍过一些 

给定两个有符号32位整数`a`和`b`，返回`a`和`b`中较大的

**要求**

不用做任何比较判断

**如何实现**

- 通过互斥条件返回结果

**代码实现**

```java
package class06;

public class Code01_GetMax {

    // 翻转比特
    public static int flip(int n) {
        return n ^ 1;
    }

    // 得到符号位的信息
    public static int sign(int n) {
        return flip((n >> 31) & 1);
    }

    public static int getMax1(int a, int b) {
        // 可能会溢出
        int c = a - b;
        int scA = sign(c);
        int scB = flip(scA);
        //两个只有一个等于一
        return a * scA + b * scB;
    }

    public static int getMax2(int a, int b) {
        int c = a - b;
        int sa = sign(a);
        int sb = sign(b);
        int sc = sign(c);
        int difSab = sa ^ sb;
        int sameSab = flip(difSab);
        int returnA = difSab * sa + sameSab * sc;
        int returnB = flip(returnA);
        return a * returnA + b * returnB;
    }

    public static void main(String[] args) {
        int a = -16;
        int b = 1;
        System.out.println(getMax1(a, b));
        System.out.println(getMax2(a, b));
        a = 2147483647;
        b = -2147480000;
        System.out.println(getMax1(a, b)); // wrong answer because of overflow
        System.out.println(getMax2(a, b));

    }

}
```

# 题目五

判断一个32位正数是不是2的幂、4的幂

**如何实现**

- 如果一个数是2的幂 -> 在二进制位中只有一个数为 1
	- 取出最右的一 `eO & (~eO + 1)` 然后进位比较
	- `n & (n - 1) == 0`
- 如果一个数是4的幂 -> 在二进制位中只有一个数为 1 并且这个 1 只在偶数位
	- 让这个二进制数去 & 上奇数位全是 1 偶数位全是 0 要是等于 0 那就是符合条件

**代码实现**

```java
package class06;

public class Code02_Power {

    public static boolean is2Power(int n) {
        return (n & (n - 1)) != 0;
    }

    public static boolean is4Power(int n) {
        return (n & (n - 1)) != 0 && (n & 0x55555555) != 0;
    }

}

```



# 题目六

给定两个有符号32位整数`a`和`b`，不能使用算术运算符，分别实现`a`和`b`的加、减、乘、除运算

**要求**

如果给定a、b执行加减乘除的运算结果就会导致数据的溢出，那么你实现的函数不必对此负责，除此之外请保证计算过程不发生溢出

**代码实现**

```java
package class06;

public class Code03_AddMinusMultiDivideByBit {

    public static int add(int a, int b) {
        int sum = a;
        while (b != 0) {
            //无进位相加信息
            sum = a ^ b;
            // 进位信息
            b = (a & b) << 1;
            a = sum;
        }
        return sum;
    }

    public static int negNum(int n) {
        return add(~n, 1);
    }

    public static int minus(int a, int b) {
        return add(a, negNum(b));
    }

    public static int multi(int a, int b) {
        int res = 0;
        while (b != 0) {
            if ((b & 1) != 0) {
                res = add(res, a);
            }
            a <<= 1;
            b >>>= 1;
        }
        return res;
    }

    public static boolean isNeg(int n) {
        return n < 0;
    }

    public static int div(int a, int b) {
        int x = isNeg(a) ? negNum(a) : a;
        int y = isNeg(b) ? negNum(b) : b;
        int res = 0;
        for (int i = 31; i > -1; i = minus(i, 1)) {
            if ((x >> i) >= y) {
                res |= (1 << i);
                x = minus(x, y << i);
            }
        }
        return isNeg(a) ^ isNeg(b) ? negNum(res) : res;
    }

    public static int divide(int a, int b) {
        if (b == 0) {
            throw new RuntimeException("divisor is 0");
        }
        if (a == Integer.MIN_VALUE && b == Integer.MIN_VALUE) {
            return 1;
        } else if (b == Integer.MIN_VALUE) {
            return 0;
        } else if (a == Integer.MIN_VALUE) {
            int res = div(add(a, 1), b);
            return add(res, div(minus(a, multi(res, b)), b));
        } else {
            return div(a, b);
        }
    }

    public static void main(String[] args) {
        int a = (int) (Math.random() * 100000) - 50000;
        int b = (int) (Math.random() * 100000) - 50000;
        System.out.println("a = " + a + ", b = " + b);
        System.out.println(add(a, b));
        System.out.println(a + b);
        System.out.println("=========");
        System.out.println(minus(a, b));
        System.out.println(a - b);
        System.out.println("=========");
        System.out.println(multi(a, b));
        System.out.println(a * b);
        System.out.println("=========");
        System.out.println(divide(a, b));
        System.out.println(a / b);
        System.out.println("=========");

        a = Integer.MIN_VALUE;
        b = 32;
        System.out.println(divide(a, b));
        System.out.println(a / b);

    }

}

```

# 题目七

假如你有个10G的文件，里面存放有符号整数

**要求**

只给你 **5G内存** 要求将将这个文件的所有整数排好序

**如何实现**

- 涉及到排序，首先想到堆结构

	其次有由于文件太大，所以我们需要将这个文件的数字按照数字的范围划分区间

	按照这个区间依次遍历，当遍历到文件末尾的时候，将小根堆中的数字放到新的文件

	等把整个区间遍历完成就排好序了

- 有个更优的方案

	就是只用一个大根堆，就可以完成。首先遍历文件，将当前文件中最小的一些数选出来

	因为大根堆的头节点都是当前堆中最大的数字，所以只有有数字小于当前节点，就把当前节点放入

	将堆的大小维持在一个范围，之后将所有的数字放到一个数组内，进行排序，放入文件中，周而复始
