# 题目一

把一个数字用中文表示出来，数字范围为 `[0, 99999]`

为了方便输出，使用字母替换相应的中文，万 -> W 千 -> Q 百 -> B 十 -> S 零 -> L

使用数字取代中文数字

对于 11 应该表示为 一十一(1S1)，而不是十一(S1)
**输入描述**

数字 0(包含)到 99999(包含)。

**输出描述**

万 -> W 千 -> Q 百 -> B 十 -> S 零 -> L

示例1

输入

12001

输出

1W2QL1

**解题思路**

就是一个由小到大的问题

**具体实现**

```java
package class07;

public class Problem01_ChineseExpression {

    public static String num1To9(int num) {
        if (num < 1 || num > 9) {
            return "";
        }
        String[] names = {"一", "二", "三", "四", "五", "六", "七", "八", "九"};
        return names[num - 1];
    }

    public static String num1To99(int num, boolean hasBai) {
        if (num < 1 || num > 99) {
            return "";
        }
        if (num < 10) {
            return num1To9(num);
        }
        int shi = num / 10;
        if (shi == 1 && (!hasBai)) {
            return "十" + num1To9(num % 10);
        } else {
            return num1To9(shi) + "十" + num1To9(num % 10);
        }
    }

    public static String num1To999(int num) {
        if (num < 1 || num > 999) {
            return "";
        }
        if (num < 100) {
            return num1To99(num, false);
        }
        String res = num1To9(num / 100) + "百";
        int rest = num % 100;
        if (rest == 0) {
            return res;
        } else if (rest >= 10) {
            res += num1To99(rest, true);
        } else {
            res += "零" + num1To9(rest);
        }
        return res;
    }

    public static String num1To9999(int num) {
        if (num < 1 || num > 9999) {
            return "";
        }
        if (num < 1000) {
            return num1To999(num);
        }
        String res = num1To9(num / 1000) + "千";
        int rest = num % 1000;
        if (rest == 0) {
            return res;
        } else if (rest >= 100) {
            res += num1To999(rest);
        } else {
            res += "零" + num1To99(rest, false);
        }
        return res;
    }

    public static String num1To99999999(int num) {
        if (num < 1 || num > 99999999) {
            return "";
        }
        int wan = num / 10000;
        int rest = num % 10000;
        if (wan == 0) {
            return num1To9999(rest);
        }
        String res = num1To9999(wan) + "万";
        if (rest == 0) {
            return res;
        } else {
            if (rest < 1000) {
                return res + "零" + num1To999(rest);
            } else {
                return res + num1To9999(rest);
            }
        }
    }

    public static String getNumChiExp(int num) {
        if (num == 0) {
            return "零";
        }
        String res = num < 0 ? "负" : "";
        int yi = Math.abs(num / 100000000);
        int rest = Math.abs((num % 100000000));
        if (yi == 0) {
            return res + num1To99999999(rest);
        }
        res += num1To9999(yi) + "亿";
        if (rest == 0) {
            return res;
        } else {
            if (rest < 10000000) {
                return res + "零" + num1To99999999(rest);
            } else {
                return res + num1To99999999(rest);
            }
        }
    }

    // for test
    public static int generateRandomNum() {
        boolean isNeg = Math.random() > 0.5 ? false : true;
        int value = (int) (Math.random() * Integer.MIN_VALUE);
        return isNeg ? value : -value;
    }

    public static void main(String[] args) {
        System.out.println(0);
        System.out.println(getNumChiExp(0));

        System.out.println(Integer.MAX_VALUE);
        System.out.println(getNumChiExp(Integer.MAX_VALUE));

        System.out.println(Integer.MIN_VALUE);
        System.out.println(getNumChiExp(Integer.MIN_VALUE));

        int num = generateRandomNum();
        System.out.println(num);
        System.out.println(getNumChiExp(num));

        num = generateRandomNum();
        System.out.println(num);
        System.out.println(getNumChiExp(num));

        num = generateRandomNum();
        System.out.println(num);
        System.out.println(getNumChiExp(num));

        num = generateRandomNum();
        System.out.println(num);
        System.out.println(getNumChiExp(num));

        System.out.println(getNumChiExp(10));
        System.out.println(getNumChiExp(110));
        System.out.println(getNumChiExp(1010));
        System.out.println(getNumChiExp(10010));
        System.out.println(getNumChiExp(1900000000));
        System.out.println(getNumChiExp(1000000010));
        System.out.println(getNumChiExp(1010100010));

    }
}


package class07;

public class Problem01_EnglishExpression {

    public static String num1To19(int num) {
        if (num < 1 || num > 19) {
            return "";
        }
        String[] names = {"One ", "Two ", "Three ", "Four ", "Five ", "Six ",
                "Seven ", "Eight ", "Nine ", "Ten ", "Eleven ", "Twelve ",
                "Thirteen ", "Fourteen ", "Fifteen ", "Sixteen ", "Sixteen ",
                "Eighteen ", "Nineteen "};
        return names[num - 1];
    }

    public static String num1To99(int num) {
        if (num < 1 || num > 99) {
            return "";
        }
        if (num < 20) {
            return num1To19(num);
        }
        int high = num / 10;
        String[] tyNames = {"Twenty ", "Thirty ", "Forty ", "Fifty ",
                "Sixty ", "Seventy ", "Eighty ", "Ninety "};
        return tyNames[high - 2] + num1To19(num % 10);
    }

    public static String num1To999(int num) {
        if (num < 1 || num > 999) {
            return "";
        }
        if (num < 100) {
            return num1To99(num);
        }
        int high = num / 100;
        return num1To19(high) + "Hundred " + num1To99(num % 100);
    }

    public static String getNumEngExp(int num) {
        if (num == 0) {
            return "Zero";
        }
        String res = "";
        if (num < 0) {
            res = "Negative, ";
        }
        if (num == Integer.MIN_VALUE) {
            res += "Two Billion, ";
            num %= -2000000000;
        }
        num = Math.abs(num);
        int high = 1000000000;
        int highIndex = 0;
        String[] names = {"Billion", "Million", "Thousand", ""};
        while (num != 0) {
            int cur = num / high;
            num %= high;
            if (cur != 0) {
                res += num1To999(cur);
                res += names[highIndex] + (num == 0 ? " " : ", ");
            }
            high /= 1000;
            highIndex++;
        }
        return res;
    }

    public static int generateRandomNum() {
        boolean isNeg = Math.random() > 0.5 ? false : true;
        int value = (int) (Math.random() * Integer.MIN_VALUE);
        return isNeg ? value : -value;
    }

    public static void main(String[] args) {
        System.out.println(getNumEngExp(0));
        System.out.println(getNumEngExp(Integer.MAX_VALUE));
        System.out.println(getNumEngExp(Integer.MIN_VALUE));
        int num = generateRandomNum();
        System.out.println(num);
        System.out.println(getNumEngExp(num));

    }

}

```

# 题目二

给定一个整数数组A，长度为n，有 `1 <= A[i] <= n`，且对于[1,n]的整数，其中部分整数会重复出现而部分不会出现

实现算法找到[1,n]中所有未出现在A中的整数

提示

尝试实现 $O(n)$ 的时间复杂度和 $O(1)$ 的空间复杂度(返回值不计入空间复杂度)

输入描述

一行数字，全部为整数，空格分隔

A0 A1 A2 A3...

输出描述

一行数字，全部为整数，空格分隔R0 R1 R2 R3... 

示例

输入

1 3 4 3

输出

2

**解题思路**

我让数组上的 i 位置，放的是 i+1 就这样把 数组遍历一遍就可以找到，所有未出现在A中的整数

**具体实现**

```java
package class07;

public class Problem02_PrintNoInArray {

    // 请保证arr[0..N-1]上的数字都在[1～n]之间
    public static void printNumberNoInArray(int[] arr) {
        if (arr == null || arr.length == 0) {
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            modify(arr[i], arr);
        }
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] != i + 1) {
                System.out.println(i + 1);
            }
        }
    }

    public static void modify(int value, int[] arr) {
        while (arr[value - 1] != value) {
            int tmp = arr[value - 1];
            arr[value - 1] = value;
            value = tmp;
        }
    }

    public static void main(String[] args) {
        int[] test = {3, 2, 3, 5, 6, 1, 6};
        printNumberNoInArray(test);
    }

}

```

# 题目三

小Q得到一个神奇的数列   `1, 12, 123,...12345678910,1234567891011...` 

并且小Q对于能否被3整除这个性质很感兴趣

小Q现在希望你能帮他计算一下从数列的第l个到第r个(包含端点),有多少个数可以被3整除

输入描述

输入包括两个整数l和r(1 <= l <= r <= 1e9), 表示要求解的区间两端

输出描述

输出一个整数, 表示区间内能被3整除的数字个数

示例1

输入 25

输出 3

**解题思路**

判断一个数能不能被3整除，等价于一个数的每位之和能否被3整除

刚开始想打表，但发现数据量是1e9，一维数组最多只能开到1e8,所以就纯暴力判断了

不过数据是有规律的，第一个数是1、第二个数 是12，第三个数是123，所以只用判断n*(n+1)/2%3即可

因为数量太大了，所以用long long

**具体实现**

```java
package class07;

public class Problem03_3times {

    public static int getNum(int l, int r) {
        int sum = 0;
        for (int i = l; i <= r; i++) {
            long tmp = (long) (i + 1) * (long) i / 2L;
            if (tmp % 3 == 0) {
                sum++;
            }
        }
        return sum;
    }

}

```

# 题目四

CC 里面有一个土豪很喜欢一位女直播 Kik i唱歌，平时就经常给她点赞、送礼、私聊。最近 CC 直播平台在举行中秋之星主播唱歌比赛，假设一开始该女主播的初始人气值为 start， 能够晋升下一轮人气需要刚好达到 end， 土豪给主播增加人气的可以采取的方法有

1. 点赞 花费x C币，人气 + 2
2. 送礼 花费y C币，人气 * 2
3. 私聊 花费z C币，人气 - 2

其中 end 远大于 start 且 end 为偶数， 请写一个程序帮助土豪计算一下，最少花费多少C币就能帮助该主播 Kiki 将人气刚好达到 end，从而能够晋级下一轮?

输入描述

第一行输入5个数据，分别为 `x y z start end`，每项数据以空格分开

其中  `0<x, y, z<=10000， 0<start, end<=1000000`

**输出描述**

需要花费的最少C币

示例1

输入

 3 100 1 2 6 

输出

 6

**解题思路**

有的题目你发现题目给出的递归条件，程序根本无法运行，于是我们需要人为的来规定递归的范围

假设一开始的人气值为 a 要达到的人气值为 b，有三种方式处理人气，于是你开始按题目给出的递归条件开始写

我们需要从题目本身找出 basecase 的限制，才能求解这个题目，首先最通用的是找出一个平凡解，就是我能通过一直点赞来达到我的解

就像开始的人气 10 我要的人气为 20 我可以通过点赞的方式达到这个问题的答案，于是在 Basecase 中就得到的限制条件，就是人为的给

递归加限制，当遇到有的题目限制不够，就可以通过找到频繁解来加入限制条件

第二个限制条件就是通过题目的条件发现的，就是乘的操作不需要大于人气两倍，因为要是这样，还不如相加

**其实就是限制区间**

将原先的许多可能性都扼杀在摇篮中

**具体实现**

```java
package class07;

public class Problem04_Kiki {

    public static int minCcoins1(int add, int times, int del, int start, int end) {
        if (start > end) {
            return -1;
        }
        return process(0, end, add, times, del, start, end * 2, ((end - start) / 2) * add);
    }

    /*
    pre 就是之前已经花了多少钱  可变参数
    aim 目标  固定参数
    add times del  固定参数
    finish 当前的人气  可变参数
    limitAim 人气大到什么时候就不需要尝试  固定参数
    limitCoin 超过多少硬币就不再尝试  固定参数
    返回最小钱数
    */
    
    public static int process(int pre, int aim, int add, int times, int del, int finish, int limitAim, int limitCoin) {
        if (pre > limitCoin) {
            return Integer.MAX_VALUE;
        }
        if (aim < 0) {
            return Integer.MAX_VALUE;
        }
        if (aim > limitAim) {
            return Integer.MAX_VALUE;
        }
        if (aim == finish) {
            return pre;
        }
        int min = Integer.MAX_VALUE;
        //人气加二的方式
        int p1 = process(pre + add, aim - 2, add, times, del, finish, limitAim, limitCoin);
        if (p1 != Integer.MAX_VALUE) {
            min = p1;
        }
        //人气减二的方式
        int p2 = process(pre + del, aim + 2, add, times, del, finish, limitAim, limitCoin);
        if (p2 != Integer.MAX_VALUE) {
            min = Math.min(min, p2);
        }
        //人气乘二的方式
        if ((aim & 1) == 0) {
            int p3 = process(pre + times, aim / 2, add, times, del, finish, limitAim, limitCoin);
            if (p3 != Integer.MAX_VALUE) {
                min = Math.min(min, p3);
            }
        }
        return min;
    }

    //动态规划版本
    public static int minCcoins2(int add, int times, int del, int start, int end) {
        if (start > end) {
            return -1;
        }
        int limitCoin = ((end - start) / 2) * add;
        int limitAim = end * 2;
        int[][] dp = new int[limitCoin + 1][limitAim + 1];
        for (int pre = 0; pre <= limitCoin; pre++) {
            for (int aim = 0; aim <= limitAim; aim++) {
                if (aim == start) {
                    dp[pre][aim] = pre;
                } else {
                    dp[pre][aim] = Integer.MAX_VALUE;
                }
            }
        }
        for (int pre = limitCoin; pre >= 0; pre--) {
            for (int aim = 0; aim <= limitAim; aim++) {
                if (aim - 2 >= 0 && pre + add <= limitCoin) {
                    dp[pre][aim] = Math.min(dp[pre][aim], dp[pre + add][aim - 2]);
                }
                if (aim + 2 <= limitAim && pre + del <= limitCoin) {
                    dp[pre][aim] = Math.min(dp[pre][aim], dp[pre + del][aim + 2]);
                }
                if ((aim & 1) == 0) {
                    if (aim / 2 >= 0 && pre + times <= limitCoin) {
                        dp[pre][aim] = Math.min(dp[pre][aim], dp[pre + times][aim / 2]);
                    }
                }
            }
        }
        return dp[0][end];
    }

    public static void main(String[] args) {
        int add = 6;
        int times = 5;
        int del = 1;
        int start = 10;
        int end = 30;
        System.out.println(minCcoins1(add, times, del, start, end));
        System.out.println(minCcoins2(add, times, del, start, end));
    }

}

```

# 题目五

求完全二叉树节点的个数

**解题思路**

因为是完全二叉树，于是我们需要知道这个树的深度，便可以大致估计这个树的数量级

首先我们一路向左遍历，获取树的深度，然后再查看头节点右子树的最左节点的深度

我们就知道这个树的左子树或者右子树的数量，剩下的半棵子树就递归去求就行

**具体实现**

```java
package class07;

public class Problem05_CompleteTreeNodeNumber {

    public static class Node {
        public int value;
        public Node left;
        public Node right;

        public Node(int data) {
            this.value = data;
        }
    }

    public static int nodeNum(Node head) {
        if (head == null) {
            return 0;
        }
        return bs(head, 1, mostLeftLevel(head, 1));
    }

    public static int bs(Node node, int l, int h) {
        if (l == h) {
            return 1;
        }
        if (mostLeftLevel(node.right, l + 1) == h) {
            return (1 << (h - l)) + bs(node.right, l + 1, h);
        } else {
            return (1 << (h - l - 1)) + bs(node.left, l + 1, h);
        }
    }

    public static int mostLeftLevel(Node node, int level) {
        while (node != null) {
            level++;
            node = node.left;
        }
        return level - 1;
    }

    public static void main(String[] args) {
        Node head = new Node(1);
        head.left = new Node(2);
        head.right = new Node(3);
        head.left.left = new Node(4);
        head.left.right = new Node(5);
        head.right.left = new Node(6);
        System.out.println(nodeNum(head));

    }

}

```

# 题目六

CC 直播的运营部门组织了很多运营活动，每个活动需要花费一定的时间参与，主播每参 加完一个活动即可得到一定的奖励

参与活动可以从任意活动开始，但一旦开始，就需要将后续活动参加完毕(注意:最后一个活动必须参与)

活动之间存在一定的依赖关系(不存在环的情况)，现在给出所有的活动时间与依赖关系，以及给出有限的时间

请帮主播计算在有限的时候内，能获得的最大奖励，以及需要的最少时长

如上图数据所示，给定有限时间为10天

可以获取得最大奖励为  1700，需要的时长为  9天 

参加的活动为 BDFH 四个

输入描述

第一行输入数据N与D，表示有N项活动，D表示给予的时长。0<N<=1000，0<D<=10000。 从第二行开始到N+1行，每行描述一个活动

的信息，其中第一项表示当前活动需要花费的时间t，第二项表示可以获 得的奖励a，之后有N项数据，表示当前活动与其他活动的依赖关

系，1表示有依赖，0表示无依赖。每项数据用空格 分开。

输出描述

输出两项数据 A 与 T ，用空格分割

A 表示所获得的最大奖励，T 表示所需要的时长

输入
 `8 10`
`3 2000 0 1 1 0 0 0 0 0`
`3 4000 0 0 0 1 1 0 0 0`
`2 2500 0 0 0 1 0 0 0 0`
`1 1600 0 0 0 0 1 1 1 0`
`4 3800 0 0 0 0 0 0 0 1`
`2 2600 0 0 0 0 0 0 0 1`
`4 4000 0 0 0 0 0 0 0 1`
`3 3500 0 0 0 0 0 0 0 0`

输出

`11700 9`

**解题思路**

就是图问题

就是将原来的问题转化为图问题

本质就是图的宽度优先遍历，但是是反着的

对于当前的每个节点都建立自己的有序表

key -> 到最后的总天数  value -> 挣的钱

于是倒着进行宽度优先遍历，于是每个节点都更新了自己的书籍

对于单条路径来说，节点的信息不需要处理因为只有一条信息，但是如果当前的节点有多条记录，就需要筛选

对于当前的纪录如果当前有序表中的某个节点的天数比某个节点大，而且赚的钱也少，直接删除这个节点

而且只在每次合并表的时候，检查数据，因为有序表具有不可重的性质，所以遇到相同值的时候比较对应的条目即可

**具体实现**

```java
package class07;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map.Entry;
import java.util.TreeMap;

public class Problem06_MaxRevenue {

    // 请保证只有唯一的最后节点
    public static int[] maxRevenue(int allTime, int[] revenue, int[] times, int[][] dependents) {
        int size = revenue.length;
        HashMap<Integer, ArrayList<Integer>> parents = new HashMap<>();
        for (int i = 0; i < size; i++) {
            parents.put(i, new ArrayList<>());
        }
        int end = -1;
        for (int i = 0; i < dependents.length; i++) {
            boolean allZero = true;
            for (int j = 0; j < dependents[0].length; j++) {
                if (dependents[i][j] != 0) {
                    parents.get(j).add(i);
                    allZero = false;
                }
            }
            if (allZero) {
                end = i;
            }
        }
        HashMap<Integer, TreeMap<Integer, Integer>> nodeCostRevenueMap = new HashMap<>();
        for (int i = 0; i < size; i++) {
            nodeCostRevenueMap.put(i, new TreeMap<>());
        }
        nodeCostRevenueMap.get(end).put(times[end], revenue[end]);
        LinkedList<Integer> queue = new LinkedList<>();
        queue.add(end);
        while (!queue.isEmpty()) {
            int cur = queue.poll();
            for (int last : parents.get(cur)) {
                for (Entry<Integer, Integer> entry : nodeCostRevenueMap.get(cur).entrySet()) {
                    int lastCost = entry.getKey() + times[last];
                    int lastRevenue = entry.getValue() + revenue[last];
                    TreeMap<Integer, Integer> lastMap = nodeCostRevenueMap.get(last);
                    if (lastMap.floorKey(lastCost) == null || lastMap.get(lastMap.floorKey(lastCost)) < lastRevenue) {
                        lastMap.put(lastCost, lastRevenue);
                    }
                }
                queue.add(last);
            }
        }
        TreeMap<Integer, Integer> allMap = new TreeMap<>();
        for (TreeMap<Integer, Integer> curMap : nodeCostRevenueMap.values()) {
            for (Entry<Integer, Integer> entry : curMap.entrySet()) {
                int cost = entry.getKey();
                int reven = entry.getValue();
                if (allMap.floorKey(cost) == null || allMap.get(allMap.floorKey(cost)) < reven) {
                    allMap.put(cost, reven);
                }
            }
        }
        return new int[]{allMap.floorKey(allTime), allMap.get(allMap.floorKey(allTime))};
    }

    public static void main(String[] args) {
        int allTime = 10;
        int[] revenue = {2000, 4000, 2500, 1600, 3800, 2600, 4000, 3500};
        int[] times = {3, 3, 2, 1, 4, 2, 4, 3};
        int[][] dependents = {
                {0, 1, 1, 0, 0, 0, 0, 0},
                {0, 0, 0, 1, 1, 0, 0, 0},
                {0, 0, 0, 1, 0, 0, 0, 0},
                {0, 0, 0, 0, 1, 1, 1, 0},
                {0, 0, 0, 0, 0, 0, 0, 1},
                {0, 0, 0, 0, 0, 0, 0, 1},
                {0, 0, 0, 0, 0, 0, 0, 1},
                {0, 0, 0, 0, 0, 0, 0, 0}};


        int[] res = maxRevenue(allTime, revenue, times, dependents);
        System.out.println(res[0] + " , " + res[1]);
    }

}

```

# 题目七

最长递增子序列问题

**解题思路**

- 经典求法

	就是建立一个表，纪录着之前的最长递增子序列的个数，每次就是便利查表

	但是有个缺点就是我们在

- 经典改良版

	我们额外引入一个数组，这个数组纪录这个数组，组成这个递增子序列的长度的最小值

**具体实现**

```java
package class07;

import java.util.Arrays;
import java.util.Comparator;

public class Problem07_EnvelopesProblem {

    public static class Envelope {
        public int l;
        public int h;

        public Envelope(int weight, int hight) {
            l = weight;
            h = hight;
        }
    }

    public static class EnvelopeComparator implements Comparator<Envelope> {
        @Override
        public int compare(Envelope o1, Envelope o2) {
            return o1.l != o2.l ? o1.l - o2.l : o2.h - o1.h;
        }
    }

    public static Envelope[] getSortedEnvelopes(int[][] matrix) {
        Envelope[] res = new Envelope[matrix.length];
        for (int i = 0; i < matrix.length; i++) {
            res[i] = new Envelope(matrix[i][0], matrix[i][1]);
        }
        Arrays.sort(res, new EnvelopeComparator());
        return res;
    }

    public static int maxEnvelopes(int[][] matrix) {
        Envelope[] envelopes = getSortedEnvelopes(matrix);
        int[] ends = new int[matrix.length];
        ends[0] = envelopes[0].h;
        int right = 0;
        int l = 0;
        int r = 0;
        int m = 0;
        for (int i = 1; i < envelopes.length; i++) {
            l = 0;
            r = right;
            while (l <= r) {
                m = (l + r) / 2;
                if (envelopes[i].h > ends[m]) {
                    l = m + 1;
                } else {
                    r = m - 1;
                }
            }
            right = Math.max(right, l);
            ends[l] = envelopes[i].h;
        }
        return right + 1;
    }

    public static void main(String[] args) {
        int[][] test = {{3, 4}, {2, 3}, {4, 5}, {1, 3}, {2, 2}, {3, 6}, {1, 2}, {3, 2}, {2, 4}};
        System.out.println(maxEnvelopes(test));
    }
}

```

