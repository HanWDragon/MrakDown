# 题目一

给定一个数组 arr ，求差值为 k 的去重数字对

**如何解决**

哈希表去重

**具体实现**

```java
package class02;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;

public class Problem01_SubvalueEqualK {

    public static List<List<Integer>> allPair(int[] arr, int k) {
        HashSet<Integer> set = new HashSet<>();
        for (int i = 0; i < arr.length; i++) {
            set.add(arr[i]);
        }
        List<List<Integer>> res = new ArrayList<>();
        for (Integer cur : set) {
            if (set.contains(cur + k)) {
                res.add(Arrays.asList(cur, cur + k));
            }
        }
        return res;
    }
}

```

# 题目二

给一个包含 n 个整数元素的集合 a，一个包含 m 个整数元素的集合 b 

定义 magic 操作为，从一个集合中取出一个元素，放到另一个集合里，且操作过后每个集合的平均值都大大于于操作前

**注意以下两点**

1. 不可以把一个集合的元素取空，这样就没有平均值了
2. 值为 x 的元素从集合 b 取出放入集合 a，但集合 a 中已经有值为 x 的元素，则a 的平均值不变(因为集合元素不会重复)，b 的平均值可能会改变(因为 x 被取出 了)

问最多可以进行多少次magic操作

**如何解决**

平均数大的集合拿出数据到平均数小的集合，数据的范围在它们的平均数范围之间

等到确实没有数字可以拿的时候就结束

而且对于满足这个区间的数字，取最小的数字（贪心）

**具体实现**

```java
package class02;

import java.util.Arrays;
import java.util.HashSet;

public class Problem02_MagicOp {

    // 请保证arr1无重复值、arr2中无重复值，且arr1和arr2肯定有数字
    public static int maxOps(int[] arr1, int[] arr2) {
        double sum1 = 0;
        for (int i = 0; i < arr1.length; i++) {
            sum1 += (double) arr1[i];
        }
        double sum2 = 0;
        for (int i = 0; i < arr2.length; i++) {
            sum2 += (double) arr2[i];
        }
        if (avg(sum1, arr1.length) == avg(sum2, arr2.length)) {
            return 0;
        }
        int[] arrMore = null;
        int[] arrLess = null;
        double sumMore = 0;
        double sumLess = 0;
        if (avg(sum1, arr1.length) > avg(sum2, arr2.length)) {
            arrMore = arr1;
            sumMore = sum1;
            arrLess = arr2;
            sumLess = sum2;
        } else {
            arrMore = arr2;
            sumMore = sum2;
            arrLess = arr1;
            sumLess = sum1;
        }
        Arrays.sort(arrMore);
        HashSet<Integer> setLess = new HashSet<>();
        for (int num : arrLess) {
            setLess.add(num);
        }
        int moreSize = arrMore.length;
        int lessSize = arrLess.length;
        int ops = 0;
        for (int i = 0; i < arrMore.length; i++) {
            double cur = (double) arrMore[i];
            if (cur < avg(sumMore, moreSize) && cur > avg(sumLess, lessSize)
                    && !setLess.contains(arrMore[i])) {
                sumMore -= cur;
                moreSize--;
                sumLess += cur;
                lessSize++;
                setLess.add(arrMore[i]);
                ops++;
            }
        }
        return ops;
    }

    public static double avg(double sum, int size) {
        return sum / (double) (size);
    }

    public static void main(String[] args) {
        int[] arr1 = {1, 2, 5};
        int[] arr2 = {2, 3, 4, 5, 6};
        System.out.println(maxOps(arr1, arr2));

    }

}

```

# 题目三

将给定的数转换为字符串

原则如下

1对应 a

2对应b

....

26对应z

**例如**

12258 可以转换为 `"abbeh"   "aveh"   "abyh"  "lbeh"  "lyh"` 个数为5

编写一个函数，给出可以转换的不同字符串的个数

**如何解决**

**具体实现**

```java
package class02;

public class Problem03_NumToStringWays {

    public static int convertWays(int num) {
        if (num < 1) {
            return 0;
        }
        return process(String.valueOf(num).toCharArray(), 0);
    }

    public static int process(char[] str, int index) {
        if (index == str.length) {
            return 1;
        }
        if (str[index] == '0') {
            return 0;
        }
        int res = process(str, index + 1);
        if (index == str.length - 1) {
            return res;
        }
        if (((str[index] - '0') * 10 + str[index + 1] - '0') < 27) {
            res += process(str, index + 2);
        }
        return res;
    }

    // 还能简化
    public static int dpways(int num) {
        if (num < 1) {
            return 0;
        }
        char[] str = String.valueOf(num).toCharArray();
        int[] dp = new int[str.length + 1];
        dp[str.length] = 1;
        dp[str.length - 1] = str[str.length - 1] == '0' ? 0 : 1;
        for (int i = str.length - 2; i >= 0; i--) {
            if (str[i] == '0') {
                dp[i] = 0;
            } else {
                dp[i] = dp[i + 1]
                        + (((str[i] - '0') * 10 + str[i + 1] - '0') < 27 ? dp[i + 2]
                        : 0);
            }
        }
        return dp[0];
    }

    public static void main(String[] args) {
        int test = 111143311;
        System.out.println(convertWays(test));
        System.out.println(dpways(test));
    }

}

```

# 题目四

一个合法的括号匹配序列有以下定义

1. 空串""是一个合法的括号匹配序列
2. 如果 `"X"` 和 `"Y"` 都是合法的括号匹配序列  `"XY"`  也是一个合法的括号匹配序列
3. 如果 `"X"` 是一个合法的括号匹配序列,那么 `"(X)"` 也是一个合法的括号匹配序列
4. 每个合法的括号序列都可以由以上规则生成

**例如**

`"" "()"  "()()" "((()))" `都是合法的括号序列

对于一个合法的括号序列我们又有以下定义它的深度

1. 空串""的深度是0

2. 如果字符串 `"X"` 的深度是 `x` ,字符串 `"Y"` 的深度是 `y` ,那么字符串 `"XY"` 的深度为 `max(x,y)`

3. 如果 `"X"` 的深度是 `x` , 那么字符串 `"(X)"` 的深度是 `x+1`

**例如**
`"()()()"` 的深度是1 

`"((()))"` 的深度是3

牛牛现在给你一个合法的括号序列,需要你计算出其深度

**如何解决**



**具体实现**

```java
package class02;

public class Problem04_ParenthesesDeep {

    public static boolean isValid(char[] str) {
        if (str == null || str.equals("")) {
            return false;
        }
        int status = 0;
        for (int i = 0; i < str.length; i++) {
            if (str[i] != ')' && str[i] != '(') {
                return false;
            }
            if (str[i] == ')' && --status < 0) {
                return false;
            }
            if (str[i] == '(') {
                status++;
            }
        }
        return status == 0;
    }

    public static int deep(String s) {
        char[] str = s.toCharArray();
        if (!isValid(str)) {
            return 0;
        }
        int count = 0;
        int max = 0;
        for (int i = 0; i < str.length; i++) {
            if (str[i] == '(') {
                max = Math.max(max, ++count);
            } else {
                count--;
            }
        }
        return max;
    }

    public static int maxLength(String str) {
        if (str == null || str.equals("")) {
            return 0;
        }
        char[] chas = str.toCharArray();
        int[] dp = new int[chas.length];
        int pre = 0;
        int res = 0;
        for (int i = 1; i < chas.length; i++) {
            if (chas[i] == ')') {
                pre = i - dp[i - 1] - 1;
                if (pre >= 0 && chas[pre] == '(') {
                    dp[i] = dp[i - 1] + 2 + (pre > 0 ? dp[pre - 1] : 0);
                }
            }
            res = Math.max(res, dp[i]);
        }
        return res;
    }

    public static void main(String[] args) {
        String test = "((()))";
        System.out.println(deep(test));

    }

}

```

# 题目五

请编写一个程序，对一个栈里的整型数据，按升序进行排序( 即排序前，栈里的数据是无序的，排序后最大元素位于栈顶)

要求最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中

**如何解决**

单调栈结构

**具体实现**

```java
package class02;

import java.util.Stack;

public class Problem05_StackSortStack {

    public static void sortStackByStack(Stack<Integer> stack) {
        Stack<Integer> help = new Stack<Integer>();
        while (!stack.isEmpty()) {
            int cur = stack.pop();
            while (!help.isEmpty() && help.peek() < cur) {
                stack.push(help.pop());
            }
            help.push(cur);
        }
        while (!help.isEmpty()) {
            stack.push(help.pop());
        }
    }

    public static void main(String[] args) {
        Stack<Integer> stack = new Stack<Integer>();
        stack.push(3);
        stack.push(1);
        stack.push(6);
        stack.push(2);
        stack.push(5);
        stack.push(4);
        sortStackByStack(stack);
        System.out.println(stack.pop());
        System.out.println(stack.pop());
        System.out.println(stack.pop());
        System.out.println(stack.pop());
        System.out.println(stack.pop());
        System.out.println(stack.pop());

    }

}

```

# 题目六

牛牛和羊羊都很喜欢青草。今天他们决定玩青草游戏

最初有一个装有 n 份青草的箱子,牛牛和羊羊依次进行,牛牛先开始

在每个回合中,每个 玩家必须吃一些箱子中的青草,所吃的青草份数必须是 4 的 x 次幂,比如 1  4 , 16   ,64 等等

不能在箱子中吃到有效份数青草的玩家落败

假定牛牛和羊羊都是按照最佳方法进行游戏,请输出胜利者的名字

**如何解决**

打表

**具体实现**

```java
package class02;

public class Problem06_Eat {

    public static void printWinner(int n) {
        if (n % 5 == 0 || n % 5 == 2) {
            System.out.println("yang");
        } else {
            System.out.println("niu");
        }
    }

}

```

# 题目七

二叉树每个结点都有一个 int 型权值，给定一棵二叉树，要求计算出从根结点到叶结点的所有路径中，权值和最大的值为多少

**如何解决**

树型DP

**具体实现**

```java
package class02;

import java.util.HashMap;
import java.util.Stack;

public class Problem07_MaxSumInTree {

    public static class Node {
        public int value;
        public Node left;
        public Node right;

        public Node(int val) {
            value = val;
        }
    }

    public static int maxSumRecursive(Node head) {
        return process(head, 0);
    }

    public static int process(Node x, int pre) {
        if (x == null) {
            return Integer.MIN_VALUE;
        }
        if (x.left == null && x.right == null) {
            return pre + x.value;
        }
        int leftMax = process(x.left, pre + x.value);
        int rightMax = process(x.right, pre + x.value);
        return Math.max(leftMax, rightMax);
    }

    public static int maxSumUnrecursive(Node head) {
        int max = 0;
        HashMap<Node, Integer> sumMap = new HashMap<>();
        if (head != null) {
            Stack<Node> stack = new Stack<Node>();
            stack.add(head);
            sumMap.put(head, head.value);
            while (!stack.isEmpty()) {
                head = stack.pop();
                if (head.left == null && head.right == null) {
                    max = Math.max(max, sumMap.get(head));
                }
                if (head.right != null) {
                    sumMap.put(head.right, sumMap.get(head) + head.right.value);
                    stack.push(head.right);
                }
                if (head.left != null) {
                    sumMap.put(head.left, sumMap.get(head) + head.left.value);
                    stack.push(head.left);
                }
            }
        }
        return max;
    }

    public static void main(String[] args) {
        Node head = new Node(4);
        head.left = new Node(1);
        head.left.right = new Node(5);
        head.right = new Node(-7);
        head.right.left = new Node(3);
        System.out.println(maxSumRecursive(head));
        System.out.println(maxSumUnrecursive(head));

    }
}
```