

# 斐波那契线代套路

原先计算的时间复杂度  $O(N)$  可以缩减到  $O(log(N))$  这一系列的问题都可以缩减到  $O(log(N))$  

**除了初始项之外，后续的每一项都有严格的递归式的问题** 
$$
\begin{bmatrix}
F(N)
  &
F(N-1)
\end{bmatrix}
= 
\begin{bmatrix}
F(2)
  &
F(1)
\end{bmatrix}
\times 
\begin{bmatrix}
1
  & 1\\1
  &0
\end{bmatrix}^{N-2}
$$
这就是斐波那契的快速计算式

现在又有问题了

就是如何计算一个矩阵的 N 次方最快

我们先想如何计算一个常数的 N 次方最快

假设有个数字 $10^{75}$ 请问如何计算它最快

先把指数换成二进制 $10^{1001011}$  我们就可以分解这个式子

假设最开始的结果 `res = 1 `  $t = 10^{1}$   

每次检查二进制指数的比特位信息

如果为 1 则将当前的 t 乘以当前的 res

然后 `t = t * t`  直到遍历完，得到当前的结果

那么由上面的信息就可以将通式求解出来

首先观察递推式的样子，看到当前需要多大的矩阵
$$
F(N) = F(N -1) + \cdots + F(N- X)
$$
这个时候就需要 $X * X$  的矩阵，然后写出线代递推式
$$
\begin{bmatrix}
F(X +2)  & \cdots   &F(2)
\end{bmatrix}=
\begin{bmatrix}
F(X +1)  & \cdots   &F(1)
\end{bmatrix}\times
\left [ 5*5  \right ]
$$
通过最开始给出的初始条件推出最后面这个矩阵的信息就可以得到最开始的那个通式
$$
\begin{bmatrix}
 F(N) & \cdots  & F(N-X)
\end{bmatrix}
=
\begin{bmatrix}
 F(1) & \cdots  & F(X)
\end{bmatrix}
\times 
\left [ X * X \right ]^{N - X}
$$
之后就是代码和数学计算的问题了

# 题目一

字符串只由'0'和'1'两种字符构成

当字符串长度为1时，所有可能的字符串为"0"、"1"

当字符串长度为2时，所有可能的字符串为"00"、"01"、"10"、"11"

当字符串长度为3时，所有可能的字符串为"000"、"001"、"010"、"011"、"100"、 "101"、"110"、"111"

...

如果某一个字符串中，只要是出现'0'的位置，左边就靠着'1'，这样的字符串叫作达标字符串
给定一个正数N，返回所有长度为N的字符串中，达标字符串的数量

比如，N=3，返回3，因为只有"101"、"110"、"111"达标

**解题思路**

- 打表（通过观察得出结论）
- 斐波那契数列

**具体实现**

```java
package class05;

public class Problem01_ZeroLeftOneStringNumber {

    public static int getNum1(int n) {
        if (n < 1) {
            return 0;
        }
        return process(1, n);
    }

    public static int process(int i, int n) {
        if (i == n - 1) {
            return 2;
        }
        if (i == n) {
            return 1;
        }
        return process(i + 1, n) + process(i + 2, n);
    }

    public static int getNum2(int n) {
        if (n < 1) {
            return 0;
        }
        if (n == 1) {
            return 1;
        }
        int pre = 1;
        int cur = 1;
        int tmp = 0;
        for (int i = 2; i < n + 1; i++) {
            tmp = cur;
            cur += pre;
            pre = tmp;
        }
        return cur;
    }

    public static int getNum3(int n) {
        if (n < 1) {
            return 0;
        }
        if (n == 1 || n == 2) {
            return n;
        }
        int[][] base = {{1, 1}, {1, 0}};
        int[][] res = matrixPower(base, n - 2);
        return 2 * res[0][0] + res[1][0];
    }

    public static int[][] matrixPower(int[][] m, int p) {
        int[][] res = new int[m.length][m[0].length];
        for (int i = 0; i < res.length; i++) {
            res[i][i] = 1;
        }
        int[][] tmp = m;
        for (; p != 0; p >>= 1) {
            if ((p & 1) != 0) {
                res = muliMatrix(res, tmp);
            }
            tmp = muliMatrix(tmp, tmp);
        }
        return res;
    }

    public static int[][] muliMatrix(int[][] m1, int[][] m2) {
        int[][] res = new int[m1.length][m2[0].length];
        for (int i = 0; i < m1.length; i++) {
            for (int j = 0; j < m2[0].length; j++) {
                for (int k = 0; k < m2.length; k++) {
                    res[i][j] += m1[i][k] * m2[k][j];
                }
            }
        }
        return res;
    }

    public static void main(String[] args) {
        for (int i = 0; i != 20; i++) {
            System.out.println(getNum1(i));
            System.out.println(getNum2(i));
            System.out.println(getNum3(i));
            System.out.println("===================");

        }
    }
}

```

# 题目二

在迷迷糊糊的大草原上，小红捡到了n根木棍，第i根木棍的长度为i， 小红现在很开心

想选出其中的三根木棍组成美丽的三角形。 但是小明想捉弄小红，想去掉一些木棍，使得小红任意选三根木棍都不能组成三角形

请问小明最少去掉多少根木棍 

给定N，返回至少去掉多少根木棍

**解题思路**

- 贪心算法（斐波那契数列）

	满足 `arr[i] = arr[i-1] + arr[i-2]`

**具体实现**

```java
package class05;

/*
 *
 * 在迷迷糊糊的大草原上，小红捡到了n根木棍，第i根木棍的长度为i，
 * 小红现在很开心。想选出其中的三根木棍组成美丽的三角形。
 * 但是小明想捉弄小红，想去掉一些木棍，使得小红任意选三根木棍都不能组成三角形。
 * 请问小明最少去掉多少根木棍呢？
 *
 * */
public class Problem02_DeleteWood {

    public static int minDelete(int m) {
        if (m < 4) {
            return 0;
        }
        int k_2 = 2;
        int k_1 = 3;
        int num = 3;
        while (k_2 + k_1 <= m) {
            num++;
            k_1 += k_2;
            k_2 = k_1 - k_2;
        }
        return m - num;
    }

    public static void main(String[] args) {
        int test = 8;
        System.out.println(minDelete(test));
    }
}

```

# 题目三

给定一个数组arr，如果通过调整可以做到arr中任意两个相邻的数字相乘是4的倍数， 返回true，如果不能返回false

**解题思路**

就是把数字分为三组

- 奇数
- 只有一个因数为 2
- 有因数为4 的数字

按照只有一个因数为 2 的个数分类

- == 0
- != 0

**具体实现**

```java
package class05;

public class Problem03_NearMultiple4Times {

    public static boolean nearMultiple4Times(int[] arr) {
        int fourTimes = 0; // 是4的倍数的数有多少个
        int evenExpFourTimes = 0; // 是偶数但不是4的倍数的数有多少个
        int odd = 0; // 奇数有多少个
        for (int i = 0; i < arr.length; i++) {
            if ((arr[i] & 1) != 0) {
                odd++;
            } else {
                if (arr[i] % 4 == 0) {
                    fourTimes++;
                } else {
                    evenExpFourTimes++;
                }
            }
        }
        return evenExpFourTimes == 0 ? (fourTimes + 1 >= odd) : (evenExpFourTimes >= odd);
    }

}

```

# 题目四

给定一个字符串，如果该字符串符合人们日常书写一个整数的形式，返回int类型的这个数

如果不符合或者越界返回-1或者报错

**解题思路**

- 除了数字之外只允许负号的出现
- 如果有符号负号，只能在开头出现一次，而且1必须跟着数字字符，但是数字字符不能为 0 
- 如果开头为 0，后续必没有字符

但是这里有个问题就是负数能表示的范围大，所以初始用正数表示

**具体实现**

```java
package class05;

public class Problem04_ConvertStringToInteger {

    public static int convert(String str) {
        if (str == null || str.equals("")) {
            return 0; // can not convert
        }
        char[] chas = str.toCharArray();
        if (!isValid(chas)) {
            return 0; // can not convert
        }
        boolean posi = chas[0] == '-' ? false : true;
        int minq = Integer.MIN_VALUE / 10;
        int minr = Integer.MIN_VALUE % 10;
        int res = 0;
        int cur = 0;
        for (int i = posi ? 0 : 1; i < chas.length; i++) {
            cur = '0' - chas[i];
            if ((res < minq) || (res == minq && cur < minr)) {
                return 0; // can not convert
            }
            res = res * 10 + cur;
        }
        if (posi && res == Integer.MIN_VALUE) {
            return 0; // can not convert
        }
        return posi ? -res : res;
    }

    public static boolean isValid(char[] chas) {
        if (chas[0] != '-' && (chas[0] < '0' || chas[0] > '9')) {
            return false;
        }
        if (chas[0] == '-' && (chas.length == 1 || chas[1] == '0')) {
            return false;
        }
        if (chas[0] == '0' && chas.length > 1) {
            return false;
        }
        for (int i = 1; i < chas.length; i++) {
            if (chas[i] < '0' || chas[i] > '9') {
                return false;
            }
        }
        return true;
    }

    public static void main(String[] args) {
        String test1 = "2147483647"; // max in java
        System.out.println(convert(test1));

        String test2 = "-2147483648"; // min in java
        System.out.println(convert(test2));

        String test3 = "2147483648"; // overflow
        System.out.println(convert(test3));

        String test4 = "-2147483649"; // overflow
        System.out.println(convert(test4));

        String test5 = "-123";
        System.out.println(convert(test5));

    }

}

```

# 题目五

设计并实现TopKRecord结构，可以不断地向其中加入字符串，并且可以根据字 符串出现的情况随时打印加入次数最多的前k个字符串

具体为

1. k在TopKRecord实例生成时指定，并且不再变化(k是构造TopKRecord的参数)

2. 含有 add(String str)方法，即向TopKRecord中加入字符串

3. 含有 printTopK()方法，即打印加入次数最多的前k个字符串，打印有哪些 字符串和对应的次数即可，不要求严格按排名顺序打印

4. 如果在出现次数最多的前k个字符串中，最后一名的字符串有多个，比如出现次数最多的前3个字符串具体排名为

	A 100次 B 90次 C 80次 D 80次 E 80次

	其他任何字符串出现次数都不超过80次

	那么只需要打印3个，打印ABC、ABD、ABE都可以

	也就是说可以随意抛弃最后一名，只要求打印 k 个

要求

1. 在任何时候，add 方法的时间复杂度不超过 $O(log{}{N})$
2. 在任何时候，printTopK方法的时间复杂度不超过 $O(N)$

**解题思路**

自己手动去实现堆，并且还要使用HashMap来实现纪录字符串在堆中的位置和字符对应的节点信息

这个堆是小根堆，并且容量只有 K ，HashMap主要是辅助堆来完成在改动堆中的数据的时候维持堆的结构

**具体实现**

```java
package class05;

import java.util.HashMap;

public class Problem05_TopKTimesRealTime {

    public static class Node {
        public String str;
        public int times;

        public Node(String s, int t) {
            str = s;
            times = t;
        }
    }

    public static class TopKRecord {
        private Node[] heap;
        private int index;
        private HashMap<String, Node> strNodeMap;
        private HashMap<Node, Integer> nodeIndexMap;

        public TopKRecord(int size) {
            heap = new Node[size];
            index = 0;
            strNodeMap = new HashMap<String, Node>();
            nodeIndexMap = new HashMap<Node, Integer>();
        }

        public void add(String str) {
            Node curNode = null;
            int preIndex = -1;
            if (!strNodeMap.containsKey(str)) {
                curNode = new Node(str, 1);
                strNodeMap.put(str, curNode);
                nodeIndexMap.put(curNode, -1);
            } else {
                curNode = strNodeMap.get(str);
                curNode.times++;
                preIndex = nodeIndexMap.get(curNode);
            }
            if (preIndex == -1) {
                if (index == heap.length) {
                    if (heap[0].times < curNode.times) {
                        nodeIndexMap.put(heap[0], -1);
                        nodeIndexMap.put(curNode, 0);
                        heap[0] = curNode;
                        heapify(0, index);
                    }
                } else {
                    nodeIndexMap.put(curNode, index);
                    heap[index] = curNode;
                    heapInsert(index++);
                }
            } else {
                heapify(preIndex, index);
            }
        }

        public void printTopK() {
            System.out.println("TOP: ");
            for (int i = 0; i != heap.length; i++) {
                if (heap[i] == null) {
                    break;
                }
                System.out.print("Str: " + heap[i].str);
                System.out.println(" Times: " + heap[i].times);
            }
        }

        private void heapInsert(int index) {
            while (index != 0) {
                int parent = (index - 1) / 2;
                if (heap[index].times < heap[parent].times) {
                    swap(parent, index);
                    index = parent;
                } else {
                    break;
                }
            }
        }

        private void heapify(int index, int heapSize) {
            int l = index * 2 + 1;
            int r = index * 2 + 2;
            int smallest = index;
            while (l < heapSize) {
                if (heap[l].times < heap[index].times) {
                    smallest = l;
                }
                if (r < heapSize && heap[r].times < heap[smallest].times) {
                    smallest = r;
                }
                if (smallest != index) {
                    swap(smallest, index);
                } else {
                    break;
                }
                index = smallest;
                l = index * 2 + 1;
                r = index * 2 + 2;
            }
        }

        private void swap(int index1, int index2) {
            nodeIndexMap.put(heap[index1], index2);
            nodeIndexMap.put(heap[index2], index1);
            Node tmp = heap[index1];
            heap[index1] = heap[index2];
            heap[index2] = tmp;
        }

    }

    public static String[] generateRandomArray(int len, int max) {
        String[] res = new String[len];
        for (int i = 0; i != len; i++) {
            res[i] = String.valueOf((int) (Math.random() * (max + 1)));
        }
        return res;
    }

    public static void printArray(String[] arr) {
        for (int i = 0; i != arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        TopKRecord record = new TopKRecord(2);
        record.add("zuo");
        record.printTopK();
        record.add("cheng");
        record.add("cheng");
        record.printTopK();
        record.add("Yun");
        record.add("Yun");
        record.printTopK();

    }
}
```

# 题目六

牛牛准备参加学校组织的春游, 出发前牛牛准备往背包里装入一些零食, 牛牛的背包容量为 w
牛牛家里一共有 n 袋零食, 第 i 袋零食体积为 v[i]

牛牛想知道在总体积不超过背包容量的情况下，他一共有多少种零食放法(总体积为 0 也算一种放法)

**解题思路**

常规的递归 -> 动态规划

就是将之前的背包问题扩展了

首先对于这个问题分解来看，就是在严格限定背包重量的情况下，求出对应的数目

然后相加，得到最后的结果我

**具体实现**

```java
package class05;

public class Problem06_CompriseWays {

    // 请保证arr里面都是正数, w也是正数
    public static int ways(int[] arr, int w) {
        if (arr == null || arr.length == 0 || w < 0) {
            return 0;
        }
        int[][] dp = new int[arr.length][w + 1];
        for (int i = 0; i < arr.length; i++) {
            dp[i][0] = 1;
        }
        for (int j = 1; j <= w; j++) {
            dp[0][j] = j >= arr[0] ? 2 : 1;
        }
        for (int i = 1; i < arr.length; i++) {
            for (int j = 1; j <= w; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j - arr[i] >= 0) {
                    dp[i][j] += dp[i - 1][j - arr[i]];
                }
            }
        }
        return dp[arr.length - 1][w];
    }

    public static void main(String[] args) {
        int[] arr = {4, 3, 2, 9};
        int w = 8;
        System.out.println(ways(arr, w));
    }

}

```

# 题目七

为了找到自己满意的工作，牛牛收集了每种工作的难度和报酬

牛牛选工作的标准是在难度不超过自身能力值的情况下，牛牛选择报酬最高的工作

在牛牛选定了自己的工作后，牛牛的小伙伴们来找牛牛帮忙选工作， 牛牛依然使用自己的标准来帮助小伙伴们

牛牛的小伙伴太多了，于是他只好把这个任务交给了你。

```java
class Job {
	public int money;// 该工作的报酬 
   public int hard; // 该工作的难度
	public Job(int money, int hard) { 
      this.money = money;
 		this.hard = hard;
	} 
}

```

给定一个 Job 类型的数组 jobarr ，表示所有的工作

给定一个 int 类型的数组 arr，表示所有小伙伴的能力

返回 int 类型的数组，表示每一个小伙伴按照牛牛的标准选工作后所能获得的报酬

**解题思路**

有序表问题

一次排序，第一次难度由小到大，如果难度一样，则按到工资由大到小的顺序排列

弄成一个Map为难度递增，报酬一定递增，选出对应的工作就行

**具体实现**

```java
package class05;

import java.util.Arrays;
import java.util.Comparator;
import java.util.TreeMap;

public class Problem07_ChooseWork {

    public static class Job {
        public int money;
        public int hard;

        public Job(int money, int hard) {
            this.money = money;
            this.hard = hard;
        }
    }

    public static class JobComparator implements Comparator<Job> {
        @Override
        public int compare(Job o1, Job o2) {
            return o1.hard != o2.hard ? (o1.hard - o2.hard) : (o2.money - o1.money);
        }
    }

    public static int[] getMoneys(Job[] job, int[] ability) {
        Arrays.sort(job, new JobComparator());
        TreeMap<Integer, Integer> map = new TreeMap<>();
        map.put(job[0].hard, job[0].money);
        Job pre = job[0];
        for (int i = 1; i < job.length; i++) {
            if (job[i].hard != pre.hard && job[i].money > pre.money) {
                pre = job[i];
                map.put(pre.hard, pre.money);
            }
        }
        int[] ans = new int[ability.length];
        for (int i = 0; i < ability.length; i++) {
            Integer key = map.ceilingKey(ability[i]);
            ans[i] = key != null ? map.get(key) : 0;
        }
        return ans;
    }

    public static void main(String[] args) {
        TreeMap<Integer, Integer> map = new TreeMap<>();
        Integer key = map.ceilingKey(5);
        int test1 = key != null ? map.get(key) : 0;
        System.out.println(test1);
        System.out.println("====");
        int test2 = map.get(map.ceilingKey(5));
        System.out.println(test2);
    }

}

```

