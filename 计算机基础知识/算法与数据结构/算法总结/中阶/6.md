# 题目一

给你一个字符串类型的数组arr

譬如

`String[] arr = { "b\\cst", "d\\", "a\\d\\e", "a\\b\\c" }` 

你把这些路径中蕴含的目录结构给画出来，子目录直接列在父目录下面，并比父目录向右进两格，就像这样

`a`

​	`b`

​			`c`

​	`d`

​		    `e`

`b`

​	`cst`

`d`

同一级的需要按字母顺序排列，不能乱

**解题思路**

前缀树

深度优先遍历

**具体实现**

```java
package class06;

import java.util.TreeMap;

public class Problem01_GetFolderTree {

    public static class Node {
        public String name;
        public TreeMap<String, Node> nextMap;

        public Node(String name) {
            this.name = name;
            nextMap = new TreeMap<>();
        }
    }

    public static void print(String[] folderPaths) {
        if (folderPaths == null || folderPaths.length == 0) {
            return;
        }
        Node head = generateFolderTree(folderPaths);
        printProcess(head, 0);
    }

    public static Node generateFolderTree(String[] folderPaths) {
        Node head = new Node("");
        for (String foldPath : folderPaths) {
            String[] paths = foldPath.split("\\\\");
            Node cur = head;
            for (int i = 0; i < paths.length; i++) {
                if (!cur.nextMap.containsKey(paths[i])) {
                    cur.nextMap.put(paths[i], new Node(paths[i]));
                }
                cur = cur.nextMap.get(paths[i]);
            }
        }
        return head;
    }

    public static void printProcess(Node head, int level) {
        if (level != 0) {
            System.out.println(get2nSpace(level) + head.name);
        }
        for (Node next : head.nextMap.values()) {
            printProcess(next, level + 1);
        }
    }

    public static String get2nSpace(int n) {
        String res = "";
        for (int i = 1; i < n; i++) {
            res += "  ";
        }
        return res;
    }

    public static void main(String[] args) {
        String[] arr = {"b\\cst", "d\\", "a\\d\\e", "a\\b\\c"};
        print(arr);
    }

}

```

# 题目二

双向链表节点结构和二叉树节点结构是一样的，如果你把 last 认为是 left ，next认为是next的话

给定一个搜索二叉树的头节点 head ，请转化成一条有序的双向链表，并返回链表的头节点

**解题思路**

这就是树型DP的问题

从左节点和右节点得到当前它们自己的双向链表的头和尾

然后做拼接，就完成了这个题

**具体实现**

```java
package class06;

import java.util.LinkedList;
import java.util.Queue;

public class Problem02_BSTtoDoubleLinkedList {

    public static class Node {
        public int value;
        public Node left;
        public Node right;

        public Node(int data) {
            this.value = data;
        }
    }

    public static Node convert1(Node head) {
        Queue<Node> queue = new LinkedList<Node>();
        inOrderToQueue(head, queue);
        if (queue.isEmpty()) {
            return head;
        }
        head = queue.poll();
        Node pre = head;
        pre.left = null;
        Node cur = null;
        while (!queue.isEmpty()) {
            cur = queue.poll();
            pre.right = cur;
            cur.left = pre;
            pre = cur;
        }
        pre.right = null;
        return head;
    }

    public static void inOrderToQueue(Node head, Queue<Node> queue) {
        if (head == null) {
            return;
        }
        inOrderToQueue(head.left, queue);
        queue.offer(head);
        inOrderToQueue(head.right, queue);
    }


    public static class RetrunType {
        public Node start;
        public Node end;

        public RetrunType(Node start, Node end) {
            this.start = start;
            this.end = end;
        }
    }

    public static Node convert2(Node head) {
        if (head == null) {
            return null;
        }
        return process(head).start;
    }

    public static RetrunType process(Node head) {
        if (head == null) {
            return new RetrunType(null, null);
        }
        RetrunType leftList = process(head.left);
        RetrunType rightList = process(head.right);
        if (leftList.end != null) {
            leftList.end.right = head;
        }
        head.left = leftList.end;
        head.right = rightList.start;
        if (rightList.start != null) {
            rightList.start.left = head;
        }
        return new RetrunType(leftList.start != null ? leftList.start : head,
                rightList.end != null ? rightList.end : head);
    }

    public static void printBSTInOrder(Node head) {
        System.out.print("BST in-order: ");
        if (head != null) {
            inOrderPrint(head);
        }
        System.out.println();
    }

    public static void inOrderPrint(Node head) {
        if (head == null) {
            return;
        }
        inOrderPrint(head.left);
        System.out.print(head.value + " ");
        inOrderPrint(head.right);
    }

    public static void printDoubleLinkedList(Node head) {
        System.out.print("Double Linked List: ");
        Node end = null;
        while (head != null) {
            System.out.print(head.value + " ");
            end = head;
            head = head.right;
        }
        System.out.print("| ");
        while (end != null) {
            System.out.print(end.value + " ");
            end = end.left;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        Node head = new Node(5);
        head.left = new Node(2);
        head.right = new Node(9);
        head.left.left = new Node(1);
        head.left.right = new Node(3);
        head.left.right.right = new Node(4);
        head.right.left = new Node(7);
        head.right.right = new Node(10);
        head.left.left = new Node(1);
        head.right.left.left = new Node(6);
        head.right.left.right = new Node(8);

        printBSTInOrder(head);
        head = convert1(head);
        printDoubleLinkedList(head);

        head = new Node(5);
        head.left = new Node(2);
        head.right = new Node(9);
        head.left.left = new Node(1);
        head.left.right = new Node(3);
        head.left.right.right = new Node(4);
        head.right.left = new Node(7);
        head.right.right = new Node(10);
        head.left.left = new Node(1);
        head.right.left.left = new Node(6);
        head.right.left.right = new Node(8);

        printBSTInOrder(head);
        head = convert2(head);
        printDoubleLinkedList(head);

    }

}
```

# 题目三

找到一棵二叉树中，最大的搜索二叉子树，返回最大搜索二叉子树的节点个数

**解题思路**

对于这个问题也是树型DP的套路

当前最大搜索二叉树与头节点有关吗

- 有关
	- 就拼起来向上传递信息
- 无关
	- 得到当前两树的子树的信息判断谁是最大的向上传递信息

设计返回值

- 当前树的最大值和最小值
- 还有当前树的节点个数
- 是否是二叉搜索树
- 最大头节点

**具体实现**

```java
package class06;

public class Problem03_BiggestSubBSTInTree {

    public static class Node {
        public int value;
        public Node left;
        public Node right;

        public Node(int data) {
            this.value = data;
        }
    }

    public static Node getMaxBST(Node head) {
        return process(head).maxBSTHead;
    }

    public static class ReturnType {
        public Node maxBSTHead;
        public int maxBSTSize;
        public int min;
        public int max;

        public ReturnType(Node maxBSTHead, int maxBSTSize, int min, int max) {
            this.maxBSTHead = maxBSTHead;
            this.maxBSTSize = maxBSTSize;
            this.min = min;
            this.max = max;
        }
    }

    public static ReturnType process(Node X) {
        // base case : 如果子树是空树
        // 最小值为系统最大
        // 最大值为系统最小
        if (X == null) {
            return new ReturnType(null, 0, Integer.MAX_VALUE, Integer.MIN_VALUE);
        }
        // 默认直接得到左树全部信息
        ReturnType lData = process(X.left);
        // 默认直接得到右树全部信息
        ReturnType rData = process(X.right);
        // 以下过程为信息整合
        // 同时以X为头的子树也做同样的要求，也需要返回如ReturnType描述的全部信息
        // 以X为头的子树的最小值是：左树最小、右树最小、X的值，三者中最小的
        int min = Math.min(X.value, Math.min(lData.min, rData.min));
        // 以X为头的子树的最大值是：左树最大、右树最大、X的值，三者中最大的
        int max = Math.max(X.value, Math.max(lData.max, rData.max));
        // 如果只考虑可能性一和可能性二，以X为头的子树的最大搜索二叉树大小
        int maxBSTSize = Math.max(lData.maxBSTSize, rData.maxBSTSize);
        // 如果只考虑可能性一和可能性二，以X为头的子树的最大搜索二叉树头节点
        Node maxBSTHead = lData.maxBSTSize >= rData.maxBSTSize ? lData.maxBSTHead
                : rData.maxBSTHead;
        // 利用收集的信息，可以判断是否存在可能性三
        if (lData.maxBSTHead == X.left && rData.maxBSTHead == X.right
                && X.value > lData.max && X.value < rData.min) {
            maxBSTSize = lData.maxBSTSize + rData.maxBSTSize + 1;
            maxBSTHead = X;
        }
        // 信息全部搞定，返回
        return new ReturnType(maxBSTHead, maxBSTSize, min, max);
    }

    // for test -- print tree
    public static void printTree(Node head) {
        System.out.println("Binary Tree:");
        printInOrder(head, 0, "H", 17);
        System.out.println();
    }

    public static void printInOrder(Node head, int height, String to, int len) {
        if (head == null) {
            return;
        }
        printInOrder(head.right, height + 1, "v", len);
        String val = to + head.value + to;
        int lenM = val.length();
        int lenL = (len - lenM) / 2;
        int lenR = len - lenM - lenL;
        val = getSpace(lenL) + val + getSpace(lenR);
        System.out.println(getSpace(height * len) + val);
        printInOrder(head.left, height + 1, "^", len);
    }

    public static String getSpace(int num) {
        String space = " ";
        StringBuffer buf = new StringBuffer("");
        for (int i = 0; i < num; i++) {
            buf.append(space);
        }
        return buf.toString();
    }

    public static void main(String[] args) {

        Node head = new Node(6);
        head.left = new Node(1);
        head.left.left = new Node(0);
        head.left.right = new Node(3);
        head.right = new Node(12);
        head.right.left = new Node(10);
        head.right.left.left = new Node(4);
        head.right.left.left.left = new Node(2);
        head.right.left.left.right = new Node(5);
        head.right.left.right = new Node(14);
        head.right.left.right.left = new Node(11);
        head.right.left.right.right = new Node(15);
        head.right.right = new Node(13);
        head.right.right.left = new Node(20);
        head.right.right.right = new Node(16);

        printTree(head);
        Node bst = getMaxBST(head);
        printTree(bst);

    }

}


```

# 题目四

已知一棵二叉树中没有重复节点，并且给定了这棵树的中序遍历数组和先序遍历数组，返回后序遍历数组
比如给定

`int[] pre = { 1, 2, 4, 5, 3, 6, 7 }`

`int[] in = { 4, 2, 5, 1, 6, 3, 7 }`

返回

`int [] res ={4,5,2,6,7,3,1}`

**解题思路**

因为在先序遍历的性质，所以头节点就是 pre 数组的第一个元素，也是 pos 数组最后一个元素，按照此题给出的样本就是 1

然后在 in 数组中通过得到的头节点将整课数组分为左子树和右子树，此时再结合递归函数来处理这些子树

因为先序遍历的第一个一定是后序遍历的最后一个元素

然后在

**具体实现**

```java
package class06;

import java.util.HashMap;

public class Problem04_PreAndInArrayToPosArray {

    public static int[] getPosArray(int[] pre, int[] in) {
        if (pre == null || in == null) {
            return null;
        }
        int len = pre.length;
        int[] pos = new int[len];
        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
        for (int i = 0; i < len; i++) {
            map.put(in[i], i);
        }
        setPos(pre, 0, len - 1, in, 0, len - 1, pos, len - 1, map);
        return pos;
    }

    //利用pre[prei ... prej] 结合in[ini ... inj] 填写好pos[posi ... posj]
    //通过根节点将它们分开
    public static int setPos(int[] p, int pi, int pj, int[] n, int ni, int nj, int[] s, int si,
                             HashMap<Integer, Integer> map) {
        if (pi > pj) {
            return si;
        }
        s[si--] = p[pi];
        int i = map.get(p[pi]);
        si = setPos(p, pj - nj + i + 1, pj, n, i + 1, nj, s, si, map);
        return setPos(p, pi + 1, pi + i - ni, n, ni, i - 1, s, si, map);
    }

    public static void printArray(int[] arr) {
        if (arr == null) {
            return;
        }
        for (int i = 0; i != arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        int[] pre = {1, 2, 4, 5, 3, 6, 7};
        int[] in = {4, 2, 5, 1, 6, 3, 7};
        int[] pos = getPosArray(pre, in);
        printArray(pos);

    }
}

```

# 题目五

小Q正在给一条长度为 n 的道路设计路灯安置方案

为了让问题更简单,小Q把道路视为 n 个方格,需要照亮的地方用 '.' 表示, 不需要 照亮的障碍物格子用 'X' 表示

小Q现在要在道路上设置一些路灯, 对于安置在 pos 位置的路灯, 这盏路灯可以照亮 pos - 1 , pos ,  pos + 1 这三个位置

小Q希望能安置尽量少的路灯照亮所有 '.' 区域, 希望你能帮他计算一下最少需 要多少盏路灯

输入描述

输入的第一行包含一个正整数 `t(1 <= t <= 1000)` , 表示测试用例数接下来每两行一个测试数据

第一行一个正整数 `n(1 <= n <= 1000)` ,表示道路的长度

第二行一个字符串 s 表示道路的构造,只包含 '.' 和 'X' 

输出描述

对于每个测试用例, 输出一个正整数表示最少需要多少盏路灯

**解题思路**

贪心策略

- 当前位置不能放灯
- 当前位置可以放灯
	- 当前位置的后一个位置为 X 那么 X 之前的这个位置必定放灯
	- 当前位置的后一个位置为 . 那么这个位置必定放灯

动态规划

**具体实现**

```java
package class06;

public class Problem05_Light {

    public static int minLight1(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }
        char[] str = s.toCharArray();
        char[] help = new char[str.length + 2];
        help[0] = '.';
        help[str.length] = '.';
        for (int i = 0; i < str.length; i++) {
            help[i + 1] = str[i];
        }
        return process(help, 1, true);
    }

    // 当前来到了i位置
    // 函数潜台词：help[0..i-2]上都已经点亮了
    // pre表示i-1位置是否点亮
    // 返回如果把所有位置都点亮，help[i..最后]需要几盏灯
    // process(help, i, true)：表示help[0..i-2]上都已经点亮了，i-1位置也点亮的情况下，help[i..最后]需要几盏灯
    // process(help, i, false)：表示help[0..i-2]上都已经点亮了，但是i-1位置没亮的情况下，help[i..最后]需要几盏灯
    public static int process(char[] help, int i, boolean pre) {
        if (i == help.length) {
            return 0;
        }
        if (i == help.length - 1) {
            return pre ? 0 : Integer.MAX_VALUE;
        }
        int ans = Integer.MAX_VALUE;
        int restLight = 0;
        if (pre) {
            if (help[i] == '.') {
                restLight = process(help, i + 1, true);
                if (restLight != Integer.MAX_VALUE) {
                    ans = Math.min(ans, restLight);
                }
            } else {
                restLight = process(help, i + 1, false);
                if (restLight != Integer.MAX_VALUE) {
                    ans = Math.min(ans, restLight);
                }
                restLight = process(help, i + 2, true);
                if (restLight != Integer.MAX_VALUE) {
                    ans = Math.min(ans, restLight + 1);
                }
            }
        } else {
            restLight = process(help, i + 2, true);
            if (restLight != Integer.MAX_VALUE) {
                ans = Math.min(ans, restLight + 1);
            }
        }
        return ans;
    }

    public static int minLight2(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }
        char[] str = s.toCharArray();
        char[] help = new char[str.length + 2];
        help[0] = '.';
        help[str.length] = '.';
        for (int i = 0; i < str.length; i++) {
            help[i + 1] = str[i];
        }
        int[][] dp = new int[help.length + 1][2];
        dp[help.length][0] = 0;
        dp[help.length][1] = 0;
        dp[help.length - 1][0] = Integer.MAX_VALUE;
        dp[help.length - 1][1] = 0;
        for (int i = help.length - 2; i >= 1; i--) {
            dp[i][0] = Integer.MAX_VALUE;
            dp[i][1] = Integer.MAX_VALUE;
            int restLight = 0;
            if (help[i] == '.') {
                restLight = dp[i + 1][1];
                if (restLight != Integer.MAX_VALUE) {
                    dp[i][1] = Math.min(dp[i][1], restLight);
                }
            } else {
                restLight = dp[i + 1][0];
                if (restLight != Integer.MAX_VALUE) {
                    dp[i][1] = Math.min(dp[i][1], restLight);
                }
                restLight = dp[i + 2][1];
                if (restLight != Integer.MAX_VALUE) {
                    dp[i][1] = Math.min(dp[i][1], restLight + 1);
                }
            }
            restLight = dp[i + 2][1];
            if (restLight != Integer.MAX_VALUE) {
                dp[i][0] = Math.min(dp[i][0], restLight + 1);
            }
        }
        return dp[1][1];
    }

    public static void main(String[] args) {
        String test = "...X.X.X..XX.XX.X.X.X.X.XX.XXX.X.XXX.XX";
        System.out.println(minLight1(test));
        System.out.println(minLight2(test));
    }

}

```

# 题目六

为了保证招聘信息的质量问题，公司为每个职位设计了打分系统，打分可以为正数，也可以为负数

正数表示用户认可帖子质量，负数表示用户不认可帖子质量

打分的分数 根据评价用户的等级大小不定，比如可以为 -1分，10分，30分，-10分等

假设数组A记录了一条帖子所有打分记录，现在需要找出帖子曾经得到过最高的分数是多少

用于后续根据最高分数来确认需要对发帖用户做相应的惩罚或奖励，其中最高分的定义为

用户所有打分记录中，连续打分数据之和的最大值

即认为是帖子曾经获得的最高分

**例如**

帖子 `10001010` 近期的打分记录为  `[1,1,-1,-10,11,4,-6,9,20,-10,-2]`

那么该条帖子曾经到达过的最高分数为 `11+4+(-6)+9+20=38`

请实现一段代码，输入为帖子近期的打分记录，输出为当前帖子得到的最高分数

**解题思路**

- 暴力递归 -> 动态规划

- 假设答案法

	我假设这段答案在数组中数组之和最大而且最长，从 `[i - j]` 为这个数字的范围

	那么我可以很轻松的推出下面的性质

	- `[i - x]`这个范围的所有数组和都大于 0  x属于`[i- j]`
	- `[? - i-1]`这一段肯定是都小于 0，要是大于0就说明违反了规则

**具体实现**

```java
package class06;

public class Problem06_SubArrayMaxSum {

    public static int maxSum(int[] arr) {
        if (arr == null || arr.length == 0) {
            return 0;
        }
        int max = Integer.MIN_VALUE;
        int cur = 0;
        for (int i = 0; i != arr.length; i++) {
            cur += arr[i];
            max = Math.max(max, cur);
            cur = cur < 0 ? 0 : cur;
        }
        return max;
    }

    public static void printArray(int[] arr) {
        for (int i = 0; i != arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        int[] arr1 = {-2, -3, -5, 40, -10, -10, 100, 1};
        System.out.println(maxSum(arr1));

        int[] arr2 = {-2, -3, -5, 0, 1, 2, -1};
        System.out.println(maxSum(arr2));

        int[] arr3 = {-2, -3, -5, -1};
        System.out.println(maxSum(arr3));

    }

}

```

# 题目七

给定一个整型矩阵，返回子矩阵的最大累计和

**解题思路**

当前假设是 3 * 3 的矩阵，就是分区块求，然后取当前的最大值 

`[0 - 0]`  `[0 - 1]`  `[0 - 1 - 2]`  `[1 - 1]`  `[1 - 2]`  `[2 - 2]`

分成多个区块

在具体实现的时候还用到了**压缩数组**的技巧

 `[i - j]`这个范围问题可以通过将这个范围的纵列相加压缩成一个数组

这样就变成了上一个问题的思路了

- 假设答案法

**具体实现**

```java
package class06;

public class Problem07_SubMatrixMaxSum {

    public static int maxSum(int[][] m) {
        if (m == null || m.length == 0 || m[0].length == 0) {
            return 0;
        }
        int max = Integer.MIN_VALUE;
        int cur = 0;
        int[] s = null;
        for (int i = 0; i != m.length; i++) {
            s = new int[m[0].length];
            for (int j = i; j != m.length; j++) {
                cur = 0;
                for (int k = 0; k != s.length; k++) {
                    s[k] += m[j][k];
                    cur += s[k];
                    max = Math.max(max, cur);
                    cur = cur < 0 ? 0 : cur;
                }
            }
        }
        return max;
    }

    public static void main(String[] args) {
        int[][] matrix = {{-90, 48, 78}, {64, -40, 64}, {-81, -7, 66}};
        System.out.println(maxSum(matrix));

    }

}

```

