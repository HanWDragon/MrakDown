# 题目一

有n个打包机器从左到右一字排开，上方有一个自动装置会抓取一批放物品到每个打包机上，放到每个机器上的这些物品数量有多有少

由于物品数量不相同，需要工人 将每个机器上的物品进行移动从而到达物品数量相等才能打包

每个物品重量太大、 每次只能搬一个物品进行移动，为了省力，只在相邻的机器上移动

请计算在搬动最小轮数的前提下，使每个机器上的物品数量相等

如果不能使每个机器上的物品相同， 返回-1 

**例如**

`[1,0,5]`  表示有3个机器，每个机器上分别有 `1、0、5` 个物品

**经过这些轮后** 

第一轮  `1 0<-5 => 1 1 4` 

第二轮  `1<-1<-4 => 2 1 3`  

第三轮: `2 1 <- 3 => 2 2 2` 

移动了3轮，每个机器上的物品相等，所以返回 3

**例如**

`[2,2,3]`  表示有3个机器，每个机器上分别有 `2、2、3` 个物品， 这些物品不管怎么移动，都不能使三个机器上物品数量相等，返回 -1

**解题思路**

假设 a 在这个机器的中间

那么看左右机器的物品数量，就会有以下几种结果

- 左边和右边都小于平均数

	那么至少需要它们的绝对值之和的次数

- 左边和右边都小于平均数

	左侧的绝对值和右侧的绝对值取最大的

- 左边和右边的数量一个大于平均数，一个小于平均数

	左侧的绝对值和右侧的绝对值取最大的

遍历一遍找出数字最大的那个机器，因为只有它满足了其他的机器才能完成自己的任务

**具体实现**

```java
package class03;

public class 
Problem01_PackingMachine {

    public static int MinOps(int[] arr) {
        if (arr == null || arr.length == 0) {
            return 0;
        }
        int size = arr.length;
        int sum = 0;
        for (int i = 0; i < size; i++) {
            sum += arr[i];
        }
        if (sum % size != 0) {
            return -1;
        }
        int avg = sum / size;
        int leftSum = 0;
        int ans = 0;
        for (int i = 0; i < arr.length; i++) {
            int L = i * avg - leftSum;
            int R = (size - i - 1) * avg - (sum - leftSum - arr[i]);
            if (L > 0 && R > 0) {
                ans = Math.max(ans, Math.abs(L) + Math.abs(R));
            } else {
                ans = Math.max(ans, Math.max(Math.abs(L), Math.abs(R)));
            }
            leftSum += arr[i];
        }
        return ans;
    }

    public static void main(String[] args) {

    }

}

```

# 题目二

用zigzag的方式打印矩阵，比如如下的矩阵 

0		1		2		3
4		5		6		7
8		9		10	 11

**打印顺序为**

`0 1 4 8 5 2 3 6 9 10 7 11`

**解题思路**

设置两个点，关注宏观调度顺序

**具体实现**

```java
package class03;

public class Problem02_ZigZagPrintMatrix {

    public static void printMatrixZigZag(int[][] matrix) {
        int tR = 0;
        int tC = 0;
        int dR = 0;
        int dC = 0;
        int endR = matrix.length - 1;
        int endC = matrix[0].length - 1;
        boolean fromUp = false;
        while (tR != endR + 1) {
            printLevel(matrix, tR, tC, dR, dC, fromUp);
            tR = tC == endC ? tR + 1 : tR;
            tC = tC == endC ? tC : tC + 1;
            dC = dR == endR ? dC + 1 : dC;
            dR = dR == endR ? dR : dR + 1;
            fromUp = !fromUp;
        }
        System.out.println();
    }

    public static void printLevel(int[][] m, int tR, int tC, int dR, int dC,
                                  boolean f) {
        if (f) {
            while (tR != dR + 1) {
                System.out.print(m[tR++][tC--] + " ");
            }
        } else {
            while (dR != tR - 1) {
                System.out.print(m[dR--][dC++] + " ");
            }
        }
    }

    public static void main(String[] args) {
        int[][] matrix = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};
        printMatrixZigZag(matrix);

    }

}

```

# 题目三

用螺旋的方式打印矩阵，比如如下的矩阵 

0		1		2		3
4		5		6		7
8		9		10	  11

**打印顺序为**

`0 1 2 3 7 11 10 9 8 4 5 6`

**解题思路**

首先是如何确定一个框

就是一个矩阵的对角线上的两点，通过得到这两点就可以开始算法设计了

对于这两个点我们可以设置自己的打印逻辑了

**具体实现**

```java
package class03;

public class Problem04_PrintMatrixSpiralOrder {

    public static void spiralOrderPrint(int[][] matrix) {
        int tR = 0;
        int tC = 0;
        int dR = matrix.length - 1;
        int dC = matrix[0].length - 1;
        while (tR <= dR && tC <= dC) {
            printEdge(matrix, tR++, tC++, dR--, dC--);
        }
    }

    public static void printEdge(int[][] m, int tR, int tC, int dR, int dC) {
        if (tR == dR) {
            for (int i = tC; i <= dC; i++) {
                System.out.print(m[tR][i] + " ");
            }
        } else if (tC == dC) {
            for (int i = tR; i <= dR; i++) {
                System.out.print(m[i][tC] + " ");
            }
        } else {
            int curC = tC;
            int curR = tR;
            while (curC != dC) {
                System.out.print(m[tR][curC] + " ");
                curC++;
            }
            while (curR != dR) {
                System.out.print(m[curR][dC] + " ");
                curR++;
            }
            while (curC != tC) {
                System.out.print(m[dR][curC] + " ");
                curC--;
            }
            while (curR != tR) {
                System.out.print(m[curR][tC] + " ");
                curR--;
            }
        }
    }

    public static void main(String[] args) {
        int[][] matrix = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12},
                {13, 14, 15, 16}};
        spiralOrderPrint(matrix);

    }

}
```

# 题目四

给定一个正方形矩阵，只用有限几个变量，实现矩阵中每个位置的数顺时针转动 90度，比如如下的矩阵

0		1		2		3

4		5		6		7

8		9		10	 11

12	  13	  14	 15 

矩阵应该被调整为

12		8		4		0
13		9		5		1
14		10	  6		2
15		11	  7		3

**解题思路**

就是将四个点分组

通过分组将所有的点按顺序变化

**具体实现**

```java
package class03;

public class Problem03_RotateMatrix {

    public static void rotate(int[][] matrix) {
        int tR = 0;
        int tC = 0;
        int dR = matrix.length - 1;
        int dC = matrix[0].length - 1;
        while (tR < dR) {
            rotateEdge(matrix, tR++, tC++, dR--, dC--);
        }
    }

    public static void rotateEdge(int[][] m, int tR, int tC, int dR, int dC) {
        int times = dC - tC;
        int tmp = 0;
        for (int i = 0; i != times; i++) {
            tmp = m[tR][tC + i];
            m[tR][tC + i] = m[dR - i][tC];
            m[dR - i][tC] = m[dR][dC - i];
            m[dR][dC - i] = m[tR + i][dC];
            m[tR + i][dC] = tmp;
        }
    }

    public static void printMatrix(int[][] matrix) {
        for (int i = 0; i != matrix.length; i++) {
            for (int j = 0; j != matrix[0].length; j++) {
                System.out.print(matrix[i][j] + " ");
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        int[][] matrix = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12},
                {13, 14, 15, 16}};
        printMatrix(matrix);
        rotate(matrix);
        System.out.println("=========");
        printMatrix(matrix);

    }

}
```



# 题目五

给定一个元素为非负整数的二维数组matrix，每行和每列都是从小到大有序的

再给定一个非负整数aim，请判断aim是否在matrix中

**解题思路**

右上开始找

**具体实现**

```java
package class03;

public class Problem05_FindNumInSortedMatrix {

    public static boolean isContains(int[][] matrix, int K) {
        int row = 0;
        int col = matrix[0].length - 1;
        while (row < matrix.length && col > -1) {
            if (matrix[row][col] == K) {
                return true;
            } else if (matrix[row][col] > K) {
                col--;
            } else {
                row++;
            }
        }
        return false;
    }

    public static void main(String[] args) {
        int[][] matrix = new int[][]{{0, 1, 2, 3, 4, 5, 6},// 0
                {10, 12, 13, 15, 16, 17, 18},// 1
                {23, 24, 25, 26, 27, 28, 29},// 2
                {44, 45, 46, 47, 48, 49, 50},// 3
                {65, 66, 67, 68, 69, 70, 71},// 4
                {96, 97, 98, 99, 100, 111, 122},// 5
                {166, 176, 186, 187, 190, 195, 200},// 6
                {233, 243, 321, 341, 356, 370, 380} // 7
        };
        int K = 233;
        System.out.println(isContains(matrix, K));
    }

}

```



# 题目六

假设s和m初始化，`s = "a"; m = s;`   再定义两种操作

**第一种操作**
`m = s;`
`s = s + s;`

**第二种操作**

`s = s + m;`

求最小的操作步骤数，可以将s拼接到长度等于 n

**解题思路**

- 如果 s 的长度为质数

	次数为长度减一

- 如果不是质数

	就分解为质数之乘

	将它们相加减去自己的个数

**具体实现**

```java
package class03;

public class Problem06_SplitNbySM {

    // 附加题：怎么判断一个数是不是质数？
    public static boolean isPrim(int n) {
        if (n < 2) {
            return false;
        }
        int max = (int) Math.sqrt((double) n);
        for (int i = 2; i <= max; i++) {
            if (n % i == 0) {
                return false;
            }
        }
        return true;
    }

    // 请保证n不是质数
    // 返回:
    // 0) 所有因子的和，但是因子不包括1
    // 1) 所有因子的个数，但是因子不包括1
    public static int[] divsSumAndCount(int n) {
        int sum = 0;
        int count = 0;
        for (int i = 2; i <= n; i++) {
            while (n % i == 0) {
                sum += i;
                count++;
                n /= i;
            }
        }
        return new int[]{sum, count};
    }

    public static int minOps(int n) {
        if (n < 2) {
            return 0;
        }
        if (isPrim(n)) {
            return n - 1;
        }
        int[] divSumAndCount = divsSumAndCount(n);
        return divSumAndCount[0] - divSumAndCount[1];
    }

}

```



# 题目七

给定一个字符串类型的数组arr，求其中出现次数最多的前 K 个

**解题思路**

- 建立词频表

	放入小根堆，空间只有 K 个

	就这样就找到了最多的前 K 个

**具体实现**

```java
package class03;

import java.util.Comparator;
import java.util.HashMap;
import java.util.Map.Entry;
import java.util.PriorityQueue;

public class Problem07_TopKTimes {

    public static class Node {
        public String str;
        public int times;

        public Node(String s, int t) {
            str = s;
            times = t;
        }
    }

    public static class NodeComparator implements Comparator<Node> {

        @Override
        public int compare(Node o1, Node o2) {
            return o2.times - o1.times;
        }

    }

    public static void printTopKAndRank(String[] arr, int topK) {
        if (arr == null || arr.length == 0 || topK < 1) {
            return;
        }
        HashMap<String, Integer> map = new HashMap<>();
        for (String str : arr) {
            if (!map.containsKey(str)) {
                map.put(str, 0);
            }
            map.put(str, map.get(str) + 1);
        }
        topK = Math.min(arr.length, topK);
        PriorityQueue<Node> heap = new PriorityQueue<>(new NodeComparator());
        for (Entry<String, Integer> entry : map.entrySet()) {
            Node cur = new Node(entry.getKey(), entry.getValue());
            if (heap.size() < topK) {
                heap.add(cur);
            } else {
                if (heap.peek().times < cur.times) {
                    heap.poll();
                }
            }

        }
        while (!heap.isEmpty()) {
            System.out.println(heap.poll().str);
        }
    }

    public static String[] generateRandomArray(int len, int max) {
        String[] res = new String[len];
        for (int i = 0; i != len; i++) {
            res[i] = String.valueOf((int) (Math.random() * (max + 1)));
        }
        return res;
    }

    public static void printArray(String[] arr) {
        for (int i = 0; i != arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        String[] arr1 = {"A", "B", "A", "C", "A", "C", "B", "B", "K"};
        printTopKAndRank(arr1, 2);

        String[] arr2 = generateRandomArray(50, 10);
        int topK = 3;
        printArray(arr2);
        printTopKAndRank(arr2, topK);

    }
}
```







