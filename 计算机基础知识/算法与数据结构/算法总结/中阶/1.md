# 题目一

给定一个有序数组arr，代表数轴上从左到右有n个点  `arr[0]、arr[1]...arr[n-1]`  

给定一个正数L，代表一根长度为L的绳子，求绳子最多能覆盖其中的几个点

**如何实现**

- 每次将绳子放在一个端点上，通过二分搜索找到当前绳子上没被绳子覆盖最左的点
- 通过滑动窗口解决，每个窗口长度最多为 5 个单位长度

**代码实现**

```java
package class01;

public class Problem01_CordCoverMaxPoint {

    // 长度为L的绳子最多覆盖几个点，请保证arr有序
    public static int maxPoint(int[] arr, int L) {
        int res = 1;
        for (int i = 0; i < arr.length; i++) {
            int nearest = nearestIndex(arr, i, arr[i] - L);
            res = Math.max(res, i - nearest + 1);
        }
        return res;
    }

    // 在arr[0..R]范围上，找满足>=value的最左位置
    public static int nearestIndex(int[] arr, int R, int value) {
         int L = 0;
        int index = R;
        while (L < R) {
            int mid = L + ((R - L) >> 1);
            if (arr[mid] >= value) {
                index = mid;
                R = mid - 1;
            } else {
                L = mid + 1;
            }
        }
        return index;
    }

    public static void main(String[] args) {
        int[] arr = {0, 13, 24, 35, 46, 57, 60, 72, 87};
        int L = 6;

        System.out.println(maxPoint(arr, L));

    }

}

```

# 题目二

小虎去附近的商店买苹果，奸诈的商贩使用了捆绑交易，只提供6个每袋和8个每袋的包装包装不可拆分

可是小虎现在只想购买恰好n个苹果，小虎想购买尽量少的袋数方便携带。如果不能购买恰好n个苹果，小虎将不会购买

输入一个整数n，表示小虎想购买的个苹果，返回最小使用多少袋子

如果无论如何都不能正好装下，返回 -1

**如何实现**

- 先尽量使用 8 个的袋子来装，装不下了在用 6 个的袋子装

	首先得到所需能装8个的袋子的最大数量，减去对应的苹果，在看是否能被 6 整除

	如果不能则 8 个袋子的数量减一，循环往复，得到最后的结果

	但是为了效率，我们肯定不能从头试到尾，所以终止条件设置为

	只要当前剩下的苹果大于两种袋子能装苹果的最小公倍数，就可以断定这个问题不成立


**代码实现**

```java
package class01;

public class Problem02_AppleMinBags {

    public static int minBags(int apple) {
        if (apple < 0) {
            return -1;
        }
        //初始设置的条件
        int bag6 = -1;
        //初始需要最多的能装8个的袋子
        int bag8 = apple / 8;
        //剩下的苹果数
        int rest = apple - 8 * bag8;
        //终止条件
        while (bag8 >= 0 && rest < 24) {
            //需要 6 的袋子数
            int restUse6 = minBagBase6(rest);
            //看能被 6 整除吗
            if (restUse6 != -1) {
                bag6 = restUse6;
                break;
            }
            rest = apple - 8 * (--bag8);
        }
        //返回需要的袋子数
        return bag6 == -1 ? -1 : bag6 + bag8;
    }

    //能被 6 整除吗 ？
    public static int minBagBase6(int rest) {
        return rest % 6 == 0 ? (rest / 6) : -1;
    }

    //通过打印所需要的袋子数找规律的得到的代码
    //这就是打表法，首先通过暴力枚举的方式得到最初的版本
    //可以通过自己找规律得到最后最优的算法（找规律）
    public static int minBagAwesome(int apple) {
        if ((apple & 1) != 0) {
            return -1;
        }
        if (apple < 18) {
            return apple == 0 ? 0 : (apple == 6 || apple == 8) ? 1
                    : (apple == 12 || apple == 14 || apple == 16) ? 2 : -1;
        }
        return (apple - 18) / 8 + 3;
    }

    public static void main(String[] args) {
        int max = Integer.MAX_VALUE;
        int testTime = 100000000;
        for (int test = 0; test < testTime; test++) {
            int apple = (int) (Math.random() * max);
            if (minBags(apple) != minBagAwesome(apple)) {
                System.out.println("error");
            }
        }

    }

}

```

# 题目三

牛牛有一些排成一行的正方形。每个正方形已经被染成红色或者绿色

牛牛现在可以选择任意一个正方形然后用这两种颜色的任意一种进行染色,这个正方形的颜色将 会被覆盖

牛牛的目标是在完成染色之后,每个红色R都比每个绿色G距离最左侧近

牛牛想知道他最少需要涂染几个正方形

**如样例所示**

`s = RGRGR` 我们涂染之后变成  `RRRGG`  满足要求了,涂染的个数为2,没有比这个更好的涂染方案

**如何实现**

预处理数组

就是看在代码结构中有那些结构是经常需要查询的，就提前将这些数据放到容器中，等要用到的时候再去取出来使用

这样可以提高数据的利用率和算法的复杂度

**代码实现**

```java
package class01;

public class Problem03_ColorLeftRight {

    // RGRGR -> RRRGG
    public static int minPaint(String s) {
        if (s == null || s.length() < 2) {
            return 0;
        }
        char[] chs = s.toCharArray();
        int[] right = new int[chs.length];
        right[chs.length - 1] = chs[chs.length - 1] == 'R' ? 1 : 0;
        for (int i = chs.length - 2; i >= 0; i--) {
            right[i] = right[i + 1] + (chs[i] == 'R' ? 1 : 0);
        }
        int res = right[0];
        int left = 0;
        for (int i = 0; i < chs.length - 1; i++) {
            left += chs[i] == 'G' ? 1 : 0;
            res = Math.min(res, left + right[i + 1]);
        }
        res = Math.min(res, left + (chs[chs.length - 1] == 'G' ? 1 : 0));
        return res;
    }

    public static void main(String[] args) {
        String test = "GGGGGR";
        System.out.println(minPaint(test));

    }

}

```



# 题目四

给定一个 N*N 的矩阵matrix，只有0和1两种值，返回边框全是1的最大正方形的边长长度
**例如**
0		1		1		1		1

0		1		0		0		1

0		1		0		0		1

0		1		1		1		1

0		1		0		1		1 

其中边框全是1的最大正方形的大小为4*4，所以返回 4

**如何实现**

预处理数组

开始设置两个数组，里面存放有多少个连续个一

这样原先的遍历操作就变成了查表操作

**代码实现**

```java
package class01;

public class Problem04_MaxOneBorderSize {

    public static void setBorderMap(int[][] m, int[][] right, int[][] down) {
        int r = m.length;
        int c = m[0].length;
        if (m[r - 1][c - 1] == 1) {
            right[r - 1][c - 1] = 1;
            down[r - 1][c - 1] = 1;
        }
        for (int i = r - 2; i != -1; i--) {
            if (m[i][c - 1] == 1) {
                right[i][c - 1] = 1;
                down[i][c - 1] = down[i + 1][c - 1] + 1;
            }
        }
        for (int i = c - 2; i != -1; i--) {
            if (m[r - 1][i] == 1) {
                right[r - 1][i] = right[r - 1][i + 1] + 1;
                down[r - 1][i] = 1;
            }
        }
        for (int i = r - 2; i != -1; i--) {
            for (int j = c - 2; j != -1; j--) {
                if (m[i][j] == 1) {
                    right[i][j] = right[i][j + 1] + 1;
                    down[i][j] = down[i + 1][j] + 1;
                }
            }
        }
    }

    public static int getMaxSize(int[][] m) {
        int[][] right = new int[m.length][m[0].length];
        int[][] down = new int[m.length][m[0].length];
        setBorderMap(m, right, down);
        for (int size = Math.min(m.length, m[0].length); size != 0; size--) {
            if (hasSizeOfBorder(size, right, down)) {
                return size;
            }
        }
        return 0;
    }

    public static boolean hasSizeOfBorder(int size, int[][] right, int[][] down) {
        for (int i = 0; i != right.length - size + 1; i++) {
            for (int j = 0; j != right[0].length - size + 1; j++) {
                if (right[i][j] >= size && down[i][j] >= size
                        && right[i + size - 1][j] >= size
                        && down[i][j + size - 1] >= size) {
                    return true;
                }
            }
        }
        return false;
    }

    public static int[][] generateRandom01Matrix(int rowSize, int colSize) {
        int[][] res = new int[rowSize][colSize];
        for (int i = 0; i != rowSize; i++) {
            for (int j = 0; j != colSize; j++) {
                res[i][j] = (int) (Math.random() * 2);
            }
        }
        return res;
    }

    public static void printMatrix(int[][] matrix) {
        for (int i = 0; i != matrix.length; i++) {
            for (int j = 0; j != matrix[0].length; j++) {
                System.out.print(matrix[i][j] + " ");
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        int[][] matrix = generateRandom01Matrix(7, 8);
        printMatrix(matrix);
        System.out.println(getMaxSize(matrix));
    }
}

```

# 题目五

给定一个函数f，可以1\~5的数字等概率返回一个

请加工出1\~7的数字等概率返回一个的函数g

给定一个函数f，可以a\~b的数字等概率返回一个

请加工出c\~d的数字等概率 返回一个的函数g

给定一个函数f，以p概率返回0，以1-p概率返回1

请加工出等概率返回0和1的函数g

**如何实现**

本质上就是把原来的等概率多返回值，变成等概率返回两种返回值

那么所有的数字都可以用二进制表示，最后再将二进制转换为结果

对于最后一题刻意找到等概率事件来进行判断

**代码实现**

```java
package class01;

public class Problem05_Rand5ToRand7 {

    public static int rand1To5() {
        return (int) (Math.random() * 5) + 1;
    }

    public static int rand1To7() {
        int num = 0;
        do {
            num = (rand1To5() - 1) * 5 + rand1To5() - 1;
        } while (num > 20);
        return num % 7 + 1;
    }

    public static int rand01p() {
        // you can change p to what you like, but it must be (0,1)
        double p = 0.83;
        return Math.random() < p ? 0 : 1;
    }

    public static int rand01() {
        int num;
        do {
            num = rand01p();
        } while (num == rand01p());
        return num;
    }

    public static int rand0To3() {
        return rand01() * 2 + rand01();
    }

    public static int rand1To6() {
        int num = 0;
        do {
            num = rand0To3() * 4 + rand0To3();
        } while (num > 11);
        return num % 6 + 1;
    }

    public static int rand1ToM(int m) {
        return (int) (Math.random() * m) + 1;
    }

    public static int rand1ToN(int n, int m) {
        int[] nMSys = getMSysNum(n - 1, m);
        int[] randNum = getRanMSysNumLessN(nMSys, m);
        return getNumFromMSysNum(randNum, m) + 1;
    }


    public static int[] getMSysNum(int value, int m) {
        int[] res = new int[32];
        int index = res.length - 1;
        while (value != 0) {
            res[index--] = value % m;
            value = value / m;
        }
        return res;
    }


    public static int[] getRanMSysNumLessN(int[] nMSys, int m) {
        int[] res = new int[nMSys.length];
        int start = 0;
        while (nMSys[start] == 0) {
            start++;
        }
        int index = start;
        boolean lastEqual = true;
        while (index != nMSys.length) {
            res[index] = rand1ToM(m) - 1;
            if (lastEqual) {
                if (res[index] > nMSys[index]) {
                    index = start;
                    lastEqual = true;
                    continue;
                } else {
                    lastEqual = res[index] == nMSys[index];
                }
            }
            index++;
        }
        return res;
    }


    public static int getNumFromMSysNum(int[] mSysNum, int m) {
        int res = 0;
        for (int i = 0; i != mSysNum.length; i++) {
            res = res * m + mSysNum[i];
        }
        return res;
    }

    public static void printCountArray(int[] countArr) {
        for (int i = 0; i != countArr.length; i++) {
            System.out.println(i + " appears " + countArr[i] + " times");
        }
    }

    public static void main(String[] args) {
        int testTimes = 1000000;
        int[] countArr1 = new int[8];
        for (int i = 0; i != testTimes; i++) {
            countArr1[rand1To7()]++;
        }
        printCountArray(countArr1);

        System.out.println("=====================");

        int[] countArr2 = new int[7];
        for (int i = 0; i != testTimes; i++) {
            countArr2[rand1To6()]++;
        }
        printCountArray(countArr2);

        System.out.println("=====================");

        int n = 17;
        int m = 3;
        int[] countArr3 = new int[n + 1];
        for (int i = 0; i != 2000000; i++) {
            countArr3[rand1ToN(n, m)]++;
        }
        printCountArray(countArr3);

        System.out.println("=====================");

    }

}

```

# 题目六

给定一个非负整数n，代表二叉树的节点个数

返回能形成多少种不同的二叉树结构

**如何实现**

一个树有左树和右树

那么就是一个标准的递归问题了

这个问题可以优化为查表问题

然后左树和右树的可能数相乘就得到了当前的可能数

然后把所有的可能的情况相加就得到了最后的接过

**代码实现**

```java
package class01;

import java.util.LinkedList;
import java.util.List;

public class Problem06_UniqueBST {

    public static class Node {
        public int value;
        public Node left;
        public Node right;

        public Node(int data) {
            this.value = data;
        }
    }

    public static int numTrees(int n) {
        //结束条件
        if (n < 2) {
            return 1;
        }
        int[] num = new int[n + 1];
        num[0] = 1;
        for (int i = 1; i < n + 1; i++) {
            for (int j = 1; j < i + 1; j++) {
                num[i] += num[j - 1] * num[i - j];
            }
        }
        return num[n];
    }

    public static List<Node> generateTrees(int n) {
        return generate(1, n);
    }

    public static List<Node> generate(int start, int end) {
        List<Node> res = new LinkedList<Node>();
        if (start > end) {
            res.add(null);
        }
        Node head = null;
        for (int i = start; i < end + 1; i++) {
            head = new Node(i);
            List<Node> lSubs = generate(start, i - 1);
            List<Node> rSubs = generate(i + 1, end);
            for (Node l : lSubs) {
                for (Node r : rSubs) {
                    head.left = l;
                    head.right = r;
                    res.add(cloneTree(head));
                }
            }
        }
        return res;
    }

    public static Node cloneTree(Node head) {
        if (head == null) {
            return null;
        }
        Node res = new Node(head.value);
        res.left = cloneTree(head.left);
        res.right = cloneTree(head.right);
        return res;
    }

    // for test -- print tree
    public static void printTree(Node head) {
        System.out.println("Binary Tree:");
        printInOrder(head, 0, "H", 17);
        System.out.println();
    }

    public static void printInOrder(Node head, int height, String to, int len) {
        if (head == null) {
            return;
        }
        printInOrder(head.right, height + 1, "v", len);
        String val = to + head.value + to;
        int lenM = val.length();
        int lenL = (len - lenM) / 2;
        int lenR = len - lenM - lenL;
        val = getSpace(lenL) + val + getSpace(lenR);
        System.out.println(getSpace(height * len) + val);
        printInOrder(head.left, height + 1, "^", len);
    }

    public static String getSpace(int num) {
        String space = " ";
        StringBuffer buf = new StringBuffer("");
        for (int i = 0; i < num; i++) {
            buf.append(space);
        }
        return buf.toString();
    }

    public static void main(String[] args) {
        int n = 4;
        System.out.println(numTrees(n));
        List<Node> res = generateTrees(n);
        for (Node node : res) {
            printTree(node);
        }
    }

}

```



# 题目七

一个完整的括号字符串定义规则如下

1. 空字符串是完整的。

2. 如果s是完整的字符串，那么(s)也是完整的

3. 如果s和t是完整的字符串，将它们连接起来形成的st也是完整的  

例如  `"(()())"`  `""`  和`"(())()"`  是完整的括号字符串  `"())("`   `"()("`  和  `")"` 是不完整的括号字符串

牛牛有一个括号字符串s,现在需要在其中任意位置尽量少地添加括号,将其转化为一个完整的括号字符串

请问牛牛至少需要添加多少个括号

**如何实现**

遍历一遍看括号

**代码实现**

```java
package class01;

public class Problem07_NeedParentheses {

    public static int needParentheses(String str) {
        int leftRest = 0;
        int needSolveRight = 0;
        for (int i = 0; i < str.length(); i++) {
            if (str.charAt(i) == '(') {
                leftRest++;
            } else {
                if (leftRest == 0) {
                    needSolveRight++;
                } else {
                    leftRest--;
                }
            }
        }
        return leftRest + needSolveRight;
    }

    public static void main(String args[]) {

    }

}

```

