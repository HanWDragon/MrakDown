# 题目一

一个数组的异或和是指数组中所有的数异或在一起的结果

给定一个数组arr，求最大子数组异或和

**解题思路**

**具体实现**

```java
package class08;

import java.util.HashMap;

public class Problem01_MostEOR {

    public static int mostEOR(int[] arr) {
        int ans = 0;
        int xor = 0;
        int[] mosts = new int[arr.length];
        HashMap<Integer, Integer> map = new HashMap<>();
        map.put(0, -1);
        for (int i = 0; i < arr.length; i++) {
            xor ^= arr[i];
            if (map.containsKey(xor)) {
                int pre = map.get(xor);
                mosts[i] = pre == -1 ? 1 : (mosts[pre] + 1);
            }
            if (i > 0) {
                mosts[i] = Math.max(mosts[i - 1], mosts[i]);
            }
            map.put(xor, i);
            ans = Math.max(ans, mosts[i]);
        }
        return ans;
    }

    // for test
    public static int comparator(int[] arr) {
        if (arr == null || arr.length == 0) {
            return 0;
        }
        int[] eors = new int[arr.length];
        int eor = 0;
        for (int i = 0; i < arr.length; i++) {
            eor ^= arr[i];
            eors[i] = eor;
        }
        int[] mosts = new int[arr.length];
        mosts[0] = arr[0] == 0 ? 1 : 0;
        for (int i = 1; i < arr.length; i++) {
            mosts[i] = eors[i] == 0 ? 1 : 0;
            for (int j = 0; j < i; j++) {
                if ((eors[i] ^ eors[j]) == 0) {
                    mosts[i] = Math.max(mosts[i], mosts[j] + 1);
                }
            }
            mosts[i] = Math.max(mosts[i], mosts[i - 1]);
        }
        return mosts[mosts.length - 1];
    }

    // for test
    public static int[] generateRandomArray(int maxSize, int maxValue) {
        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int) ((maxValue + 1) * Math.random());
        }
        return arr;
    }

    // for test
    public static void printArray(int[] arr) {
        if (arr == null) {
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    // for test
    public static void main(String[] args) {
        int testTime = 500000;
        int maxSize = 300;
        int maxValue = 100;
        boolean succeed = true;
        for (int i = 0; i < testTime; i++) {
            int[] arr = generateRandomArray(maxSize, maxValue);
            int res = mostEOR(arr);
            int comp = comparator(arr);
            if (res != comp) {
                succeed = false;
                printArray(arr);
                System.out.println(res);
                System.out.println(comp);
                break;
            }
        }
        System.out.println(succeed ? "Nice!" : "Fucking fucked!");
    }

}

```

# 题目二

给定一个只由 0(假)、1(真)、&(逻辑与)、|(逻辑或)和^(异或)五种字符组成的字符串 express，再给定一个布尔值 desired

返回express能有多少种组合方式，可以达到desired的结果

**举例**

`express="1^0|0|1"，desired=false`

 只有 `1^((0|0)|1)`  和  `1^(0|(0|1))`  的组合可以得到 `false`，返回 2

`express="1"，desired=false`

无组合则可以得到 `false` ，返回 0

**解题思路**

这个题就是，进行尝试，假设每一个二元运算都是最后一个结合的

加入说我最后需要的结果就是True，那我们就倒着来推，有多少种方式来得到 true，这是一个范围上的尝试

于是我们设计相应的函数  `int p(char[] exp, boolean desired, int L, int R)`  就是假设这个范围上的二元符号是最后结合的符号

我们其实就是枚举这些二元符号，每次都假设它们是最后结合的，那么对应具体的细节就是

我给定一个范围  L-> R  在这个范围中，最后结果为 true，假设 i 位置有一个 & 运算符，就把这个字符串分成两半

因为这个是 & 所以两边都要为 true 才能达到给定的结果

所以后续只能这样调参数 `p(exp, true, L, i - 1)   p(exp, true, i + 1, R)`  只有这样才能得到结果将对应的结果相乘得到最终的结果

接下来就是代码实现的问题

这个改为动态规划，就是两张表，一张 true 表，一张 false 表

**具体实现**

```java
package class08;

public class Problem02_ExpressionNumber {

    public static boolean isValid(char[] exp) {
        if ((exp.length & 1) == 0) {
            return false;
        }
        for (int i = 0; i < exp.length; i = i + 2) {
            if ((exp[i] != '1') && (exp[i] != '0')) {
                return false;
            }
        }
        for (int i = 1; i < exp.length; i = i + 2) {
            if ((exp[i] != '&') && (exp[i] != '|') && (exp[i] != '^')) {
                return false;
            }
        }
        return true;
    }

    public static int num1(String express, boolean desired) {
        if (express == null || express.equals("")) {
            return 0;
        }
        char[] exp = express.toCharArray();
        if (!isValid(exp)) {
            return 0;
        }
        return p(exp, desired, 0, exp.length - 1);
    }

    public static int p(char[] exp, boolean desired, int L, int R) {
        if (L == R) {
            if (exp[L] == '1') {
                return desired ? 1 : 0;
            } else {
                return desired ? 0 : 1;
            }
        }
        int res = 0;
        if (desired) {
            for (int i = L + 1; i < R; i += 2) {
                switch (exp[i]) {
                    case '&':
                        res += p(exp, true, L, i - 1) * p(exp, true, i + 1, R);
                        break;
                    case '|':
                        res += p(exp, true, L, i - 1) * p(exp, false, i + 1, R);
                        res += p(exp, false, L, i - 1) * p(exp, true, i + 1, R);
                        res += p(exp, true, L, i - 1) * p(exp, true, i + 1, R);
                        break;
                    case '^':
                        res += p(exp, true, L, i - 1) * p(exp, false, i + 1, R);
                        res += p(exp, false, L, i - 1) * p(exp, true, i + 1, R);
                        break;
                }
            }
        } else {
            for (int i = L + 1; i < R; i += 2) {
                switch (exp[i]) {
                    case '&':
                        res += p(exp, false, L, i - 1) * p(exp, true, i + 1, R);
                        res += p(exp, true, L, i - 1) * p(exp, false, i + 1, R);
                        res += p(exp, false, L, i - 1) * p(exp, false, i + 1, R);
                        break;
                    case '|':
                        res += p(exp, false, L, i - 1) * p(exp, false, i + 1, R);
                        break;
                    case '^':
                        res += p(exp, true, L, i - 1) * p(exp, true, i + 1, R);
                        res += p(exp, false, L, i - 1) * p(exp, false, i + 1, R);
                        break;
                }
            }
        }
        return res;
    }

    public static int num2(String express, boolean desired) {
        if (express == null || express.equals("")) {
            return 0;
        }
        char[] exp = express.toCharArray();
        if (!isValid(exp)) {
            return 0;
        }
        int[][] t = new int[exp.length][exp.length];
        int[][] f = new int[exp.length][exp.length];
        t[0][0] = exp[0] == '0' ? 0 : 1;
        f[0][0] = exp[0] == '1' ? 0 : 1;
        for (int i = 2; i < exp.length; i += 2) {
            t[i][i] = exp[i] == '0' ? 0 : 1;
            f[i][i] = exp[i] == '1' ? 0 : 1;
            for (int j = i - 2; j >= 0; j -= 2) {
                for (int k = j; k < i; k += 2) {
                    if (exp[k + 1] == '&') {
                        t[j][i] += t[j][k] * t[k + 2][i];
                        f[j][i] += (f[j][k] + t[j][k]) * f[k + 2][i] + f[j][k] * t[k + 2][i];
                    } else if (exp[k + 1] == '|') {
                        t[j][i] += (f[j][k] + t[j][k]) * t[k + 2][i] + t[j][k] * f[k + 2][i];
                        f[j][i] += f[j][k] * f[k + 2][i];
                    } else {
                        t[j][i] += f[j][k] * t[k + 2][i] + t[j][k] * f[k + 2][i];
                        f[j][i] += f[j][k] * f[k + 2][i] + t[j][k] * t[k + 2][i];
                    }
                }
            }
        }
        return desired ? t[0][t.length - 1] : f[0][f.length - 1];
    }

    public static void main(String[] args) {
        String express = "1^0&0|1&1^0&0^1|0|1&1";
        boolean desired = true;
        System.out.println(num1(express, desired));
        System.out.println(num2(express, desired));

    }

}

```

# 题目三

在数据加密和数据压缩中常需要对特殊的字符串进行编码

给定的字母表A由26个小写英文字母组成，即 `A={a, b...z}`

该字母表产生的长序字符串是指定字符串中字母从左到右出现的次序与字母在字母表中出现 的次序相同，且每个字符最多出现1次

例如  `a，b，ab，bc，xyz`  等字符串是升序字符串，对字母表 A 产生的所有长度不超过 6 的升序字符串按照字典排列编码如下

`a(1)，b(2)，c(3)......，z(26)，ab(27)， ac(28)......`   

对于任意长度不超过16的升序字符串，迅速计算出它在上述字典中的编码

输入描述:

第1行是一个正整数 N，表示接下来共有 N 行，在接下来的 N 行中，每行给出一个字符串

输出描述

输出N行，每行对应于一个字符串编码

示例1

输入
 3
 a
 b
 ab

输出
 1
 2
 27

**解题思路**

对于这个问题，我们需要寻找一个单位长度，就是将这些字母，放在对应的单位长度下

**具体实现**

```java
package class08;

public class Problem03_StringToKth {

    // 第i个字符开头、长度为len的所有字符串中的第一个字符串，是第几个
    public static int f(int i, int len) {
        int sum = 0;
        if (len == 1) {
            return 1;
        }
        for (int j = i + 1; j <= 26; j++) {
            sum += f(j, len - 1);
        }
        return sum;

    }

    // 长度为len的字符串有多少个
    public static int g(int len) {
        int sum = 0;
        for (int i = 1; i <= 26; i++) {
            sum += f(i, len);
        }
        return sum;
    }

    public static int kth(String s) {
        char[] str = s.toCharArray();
        int sum = 0;
        int len = str.length;
        for (int i = 1; i < len; i++) {
            sum += g(i);
        }
        int first = str[0] - 'a' + 1;
        for (int i = 1; i < first; i++) {
            sum += f(i, len);
        }
        int pre = first;
        for (int i = 1; i < len; i++) {
            int cur = str[i] - 'a' + 1;
            for (int j = pre + 1; j < cur; j++) {
                sum += f(j, len - i);
            }
            pre = cur;
        }
        return sum + 1;
    }

    public static void main(String[] args) {
        String test = "bc";
        System.out.println(kth(test));
    }

}

```

# 题目四

在一个字符串中找到没有重复字符子串中最长的长度

**例如**

`abcabcbb` 没有重复字符的最长子串是 `abc` ，长度为 3 

`bbbbb` ，答案是 `b`，长度为 1

`pwwkew` ，答案是 `wke` ，长度是 3

**要求**

答案必须是子串，`"pwke"`  是一个子字符序列但不是一个子字符串

**解题思路**

- 因为没有重复字符的出现，所以当这这个子串出现了重复字母就立即停下，记下当前的位置
- 然后将刚刚的子串的最后一个字符删去，又是当这这个子串出现了重复字母就立即停下，记下当前的位置

对于上面的记录的位置，那个离我近就选谁，就是答案

遍历一遍，取最长的答案

**具体实现**

```java
package class08;

public class Problem04_LongestNoRepeatSubstring {

    public static int maxUnique(String str) {
        if (str == null || str.equals("")) {
            return 0;
        }
        char[] chas = str.toCharArray();
        int[] map = new int[256];
        for (int i = 0; i < 256; i++) {
            map[i] = -1;
        }
        int len = 0;
        int pre = -1;
        int cur = 0;
        for (int i = 0; i != chas.length; i++) {
            pre = Math.max(pre, map[chas[i]]);
            cur = i - pre;
            len = Math.max(len, cur);
            map[chas[i]] = i;
        }
        return len;
    }

    // for test
    public static String getRandomString(int len) {
        char[] str = new char[len];
        int base = 'a';
        int range = 'z' - 'a' + 1;
        for (int i = 0; i != len; i++) {
            str[i] = (char) ((int) (Math.random() * range) + base);
        }
        return String.valueOf(str);
    }

    // for test
    public static String maxUniqueString(String str) {
        if (str == null || str.equals("")) {
            return str;
        }
        char[] chas = str.toCharArray();
        int[] map = new int[256];
        for (int i = 0; i < 256; i++) {
            map[i] = -1;
        }
        int len = -1;
        int pre = -1;
        int cur = 0;
        int end = -1;
        for (int i = 0; i != chas.length; i++) {
            pre = Math.max(pre, map[chas[i]]);
            cur = i - pre;
            if (cur > len) {
                len = cur;
                end = i;
            }
            map[chas[i]] = i;
        }
        return str.substring(end - len + 1, end + 1);
    }

    public static void main(String[] args) {
        String str = getRandomString(20);
        System.out.println(str);
        System.out.println(maxUnique(str));
        System.out.println(maxUniqueString(str));
    }
}

```

# 题目五

给定两个字符串 str1 和 str2 ，再给定三个整数 ic 、dc 和 rc ，分别代表插入、删除和替换一个字符的代价

返回将str1编辑成str2的最小代价

**举例**

`str1="abc"，str2="adc"，ic=5，dc=3，rc=2` 

从 `"abc" `编辑成 `"adc"`，把 `'b'` 替换成 `'d'` 是代价最小的，所以返回 2

`str1="abc"，str2="adc"，ic=5，dc=3，rc=100`   从 `"abc"` 编辑成 "`adc"` ，先删除 `'b'` ，然后插入 `'d' `是代价最小的,所以返回8 

`str1="abc"，str2="abc"，ic=5，dc=3，rc=2`  不用编辑了，本来就是一样的字符串，所以返回 0

**解题思路**

动态规划

**具体实现**

```java
package class08;

public class Problem05_EditCost {

    public static int minCost1(String str1, String str2, int ic, int dc, int rc) {
        if (str1 == null || str2 == null) {
            return 0;
        }
        char[] chs1 = str1.toCharArray();
        char[] chs2 = str2.toCharArray();
        int row = chs1.length + 1;
        int col = chs2.length + 1;
        int[][] dp = new int[row][col];
        for (int i = 1; i < row; i++) {
            dp[i][0] = dc * i;
        }
        for (int j = 1; j < col; j++) {
            dp[0][j] = ic * j;
        }
        for (int i = 1; i < row; i++) {
            for (int j = 1; j < col; j++) {
                if (chs1[i - 1] == chs2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = dp[i - 1][j - 1] + rc;
                }
                dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] + ic);
                dp[i][j] = Math.min(dp[i][j], dp[i - 1][j] + dc);
            }
        }
        return dp[row - 1][col - 1];
    }

    public static int minCost2(String str1, String str2, int ic, int dc, int rc) {
        if (str1 == null || str2 == null) {
            return 0;
        }
        char[] chs1 = str1.toCharArray();
        char[] chs2 = str2.toCharArray();
        char[] longs = chs1.length >= chs2.length ? chs1 : chs2;
        char[] shorts = chs1.length < chs2.length ? chs1 : chs2;
        if (chs1.length < chs2.length) { ֵ
            int tmp = ic;
            ic = dc;
            dc = tmp;
        }
        int[] dp = new int[shorts.length + 1];
        for (int i = 1; i <= shorts.length; i++) {
            dp[i] = ic * i;
        }
        for (int i = 1; i <= longs.length; i++) {
            int pre = dp[0]; ֵ
            dp[0] = dc * i;
            for (int j = 1; j <= shorts.length; j++) {
                int tmp = dp[j]; 
                if (longs[i - 1] == shorts[j - 1]) {
                    dp[j] = pre;
                } else {
                    dp[j] = pre + rc;
                }
                dp[j] = Math.min(dp[j], dp[j - 1] + ic);
                dp[j] = Math.min(dp[j], tmp + dc);
                pre = tmp; 
            }
        }
        return dp[shorts.length];
    }

    public static void main(String[] args) {
        String str1 = "ab12cd3";
        String str2 = "abcdf";
        System.out.println(minCost1(str1, str2, 5, 3, 2));
        System.out.println(minCost2(str1, str2, 5, 3, 2));

        str1 = "abcdf";
        str2 = "ab12cd3";
        System.out.println(minCost1(str1, str2, 3, 2, 4));
        System.out.println(minCost2(str1, str2, 3, 2, 4));

        str1 = "";
        str2 = "ab12cd3";
        System.out.println(minCost1(str1, str2, 1, 7, 5));
        System.out.println(minCost2(str1, str2, 1, 7, 5));

        str1 = "abcdf";
        str2 = "";
        System.out.println(minCost1(str1, str2, 2, 9, 8));
        System.out.println(minCost2(str1, str2, 2, 9, 8));

    }

}

```

# 题目六

给定一个全是小写字母的字符串 str，删除多余字符，使得每种字符只保留一个，并让最终结果字符串的字典序最小

**举例**

`str = "acbc"`，删掉第一个 `'c'` ，得到 `"abc"` ，是所有结果字符串中字典序最小的

`str = "dbcacbca"` ，删掉第一个 `'b`' 、第一个 `'c'` 、第二个 `'c'` 、第二个 `'a'` ，得到 `"dabc"` ， 是所有结果字符串中字典序最小的

**解题思路**

贪心

统计每个单词的词频表，开始遍历数组遇到相同的元素就减去，当其中的某个单词的词频减为了 0 就停止

此时就开始处理字符串了，每次就减去，直到某个为 0，此时就开始处理这个子串，因为当某个词频减为 0

就代表在这个子串必须进行处理了，于是接下来就要选出 ascii 码最小的字母，然后将处理后的子串继续处理

拼出答案

**具体实现**

```java
package class08;

public class Problem06_RemoveDuplicateLettersLessLexi {

    public static String removeDuplicateLetters(String s) {
        char[] str = s.toCharArray();
        // 小写字母ascii码值范围[97~122]，所以用长度为26的数组做次数统计
        // 如果map[i] > -1，则代表ascii码值为i的字符的出现次数
        // 如果map[i] == -1，则代表ascii码值为i的字符不再考虑
        int[] map = new int[26];
        for (int i = 0; i < str.length; i++) {
            map[str[i] - 'a']++;
        }
        char[] res = new char[26];
        int index = 0;
        int L = 0;
        int R = 0;
        while (R != str.length) {
            // 如果当前字符是不再考虑的，直接跳过
            // 如果当前字符的出现次数减1之后，后面还能出现，直接跳过
            if (map[str[R] - 'a'] == -1 || --map[str[R] - 'a'] > 0) {
                R++;
            } else { // 当前字符需要考虑并且之后不会再出现了
                // 在str[L..R]上所有需要考虑的字符中，找到ascii码最小字符的位置
                int pick = -1;
                for (int i = L; i <= R; i++) {
                    if (map[str[i] - 'a'] != -1 && (pick == -1 || str[i] < str[pick])) {
                        pick = i;
                    }
                }
                // 把ascii码最小的字符放到挑选结果中
                res[index++] = str[pick];
                // 在上一个的for循环中，str[L..R]范围上每种字符的出现次数都减少了
                // 需要把str[pick + 1..R]上每种字符的出现次数加回来
                for (int i = pick + 1; i <= R; i++) {
                    if (map[str[i] - 'a'] != -1) { // 只增加以后需要考虑字符的次数
                        map[str[i] - 'a']++;
                    }
                }
                // 选出的ascii码最小的字符，以后不再考虑了
                map[str[pick] - 'a'] = -1;
                // 继续在str[pick + 1......]上重复这个过程
                L = pick + 1;
                R = L;
            }
        }
        return String.valueOf(res, 0, index);
    }

}

```

# 题目七

给定两个字符串，记为 `start` 和 `to` ，再给定一个字符串列表 `list` ， `list` 中一定包含 `to list` 中没有重复字符串，所有的字符串都是小写的

规定

`start` 每次只能改变一个字符，最终的目标是彻底变成 `to`，但是每次变成的新字符串必须在 `list` 中存在

请返回所有最短的变换路径

举例 

`start="abc",end="cab",list={"cab","acc","cbc","ccc","cac","cbb","aab","abb"}`

转换路径的方法有很多种，但所有最短的转换路径如下

`abc -> abb -> aab -> cab`

`abc -> abb -> cbb -> cab`

`abc -> cbc -> cac -> cab`

`abc -> cbc -> cbb -> cab`

**解题思路**

**具体实现**

```java
package class08;

import java.util.*;

public class Problem07_WordMinPaths {

    public static List<List<String>> findMinPaths(String start, String to,
                                                  List<String> list) {
        list.add(start);
        HashMap<String, ArrayList<String>> nexts = getNexts(list);
        HashMap<String, Integer> distances = getDistances(start, nexts);
        LinkedList<String> pathList = new LinkedList<>();
        List<List<String>> res = new ArrayList<>();
        getShortestPaths(start, to, nexts, distances, pathList, res);
        return res;
    }

    public static HashMap<String, ArrayList<String>> getNexts(List<String> words) {
        Set<String> dict = new HashSet<>(words);
        HashMap<String, ArrayList<String>> nexts = new HashMap<>();
        for (int i = 0; i < words.size(); i++) {
            nexts.put(words.get(i), new ArrayList<>());
        }
        for (int i = 0; i < words.size(); i++) {
            nexts.put(words.get(i), getNext(words.get(i), dict));
        }
        return nexts;
    }

    private static ArrayList<String> getNext(String word, Set<String> dict) {
        ArrayList<String> res = new ArrayList<String>();
        char[] chs = word.toCharArray();
        for (char cur = 'a'; cur <= 'z'; cur++) {
            for (int i = 0; i < chs.length; i++) {
                if (chs[i] != cur) {
                    char tmp = chs[i];
                    chs[i] = cur;
                    if (dict.contains(String.valueOf(chs))) {
                        res.add(String.valueOf(chs));
                    }
                    chs[i] = tmp;
                }
            }
        }
        return res;
    }

    public static HashMap<String, Integer> getDistances(String start,
                                                        HashMap<String, ArrayList<String>> nexts) {
        HashMap<String, Integer> distances = new HashMap<>();
        distances.put(start, 0);
        Queue<String> queue = new LinkedList<String>();
        queue.add(start);
        HashSet<String> set = new HashSet<String>();
        set.add(start);
        while (!queue.isEmpty()) {
            String cur = queue.poll();
            for (String str : nexts.get(cur)) {
                if (!set.contains(str)) {
                    distances.put(str, distances.get(cur) + 1);
                    queue.add(str);
                    set.add(str);
                }
            }
        }
        return distances;
    }

    private static void getShortestPaths(String cur, String to,
                                         HashMap<String, ArrayList<String>> nexts,
                                         HashMap<String, Integer> distances, LinkedList<String> solution,
                                         List<List<String>> res) {
        solution.add(cur);
        if (to.equals(cur)) {
            res.add(new LinkedList<String>(solution));
        } else {
            for (String next : nexts.get(cur)) {
                if (distances.get(next) == distances.get(cur) + 1) {
                    getShortestPaths(next, to, nexts, distances, solution, res);
                }
            }
        }
        solution.pollLast();
    }

    public static void main(String[] args) {
        String start = "abc";
        String end = "cab";
        String[] test = {"abc", "cab", "acc", "cbc", "ccc", "cac", "cbb",
                "aab", "abb"};
        ArrayList<String> list = new ArrayList<>();
        for (int i = 0; i < test.length; i++) {
            list.add(test[i]);
        }
        List<List<String>> res = findMinPaths(start, end, list);
        for (List<String> obj : res) {
            for (String str : obj) {
                System.out.print(str + " -> ");
            }
            System.out.println();
        }

    }

}

```

