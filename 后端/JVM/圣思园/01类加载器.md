# 类加载

- 在Java代码中，类型的加载、连接与初始化过程都是在程序运行期间完成的，给程序提供了更大的灵活性，增加了更多的可能性

## Java虚拟机与程序的生命周期

在如下的几种情况下，Java虚拟机将结束生命周期

- 执行了 `System.exit()` 方法
- 程序正常执行结束
- 程序在执行过程中遇到了异常或错误而异常终止
- 由于操作系统出现错误而导致Java虚拟机进程终止

## 类的加载、连接、初始化

加载 -> 验证  -> 准备 -> 解析 -> 初始化 -> 类实例化 -> 垃圾回收与对象终结

### 加载

查找并加载类的二进制数据

- 类的加载指的是将类的`.class`文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，那然后在内存创建一个`java.lang.Class`对象（规范未说明`Class`对象位于何处，Hotspot虚拟机将其放在方法区）用来封装类在方法区内的数据结构
- **类的加载的最终产品就是位于内存中的Class对象**
- Class 对象封装了类在方法区内的数据结构，并向Java程序员提供了访问方法区内的数据结构的接口
- 类加载器并不需要等到某个类被 **首次主动使用** 时再加载它
- JVM规范允许类加载器在某个时刻预料到某个类佳肴被使用时就预先加载它，如果在预先加载的过程中就遇到了 `.class` 文件确实或者存在戳我，类加载器必须在**程序首次主动使用**该类时才报告错误（**LinkageError**错误）
- 如果这个类一直没有被程序主动使用，那么**类加载器就不会报告错误**

加载`.class`文件的方式

- 从本地操作系统中直接加载
- 通过网络下载`.class`文件
- 从 `zip jar` 等归档文件中加载`.class`文件
- 从专有数据库中提取`.class`文件
- **将Java源文件动态编译为`.class`文件`(JSP DynamicProxy)`**

#### 获得 ClassLoader 的途径

##### 获得当前类的 ClassLoader

`clazz.getClassLoader`

##### 获得当前线程上下文的 ClassLoader

`Thread.currentThread().getContextLoader()`

##### 获得系统类加载器

`ClassLoader.getSystemClassLoader()`

##### 获得调用者的 ClassLoader

`DeiverManager.getCallerClassLoader()`

#### 有两种类型的类加载器

类加载器用来把类加载到Java虚拟机中。从JDK1.2版本开始，类的加载过程采用双亲委派机制，这种机制能更好的保证Java平台的安全。在此委托机制当中，除了Java虚拟机知道的根类加载器外，其余的类加载器都有且只有一个父加载器。当Java程序请求加载器 `loader` 加载一个类时， `loader` 首先委托自己的父加载器去加载这个类，如果父加载器能加载，则这个加载任务就由父加载器完成，否则才由加载器 `loader` 本身加载这个类

##### Java虚拟机自带的加载器

###### 根类加载器（Bootstrap）

该加载器没有父加载器，它负责加载虚拟机的核心类库（如 `java.lang.*` 等），例如 `java.lang.Object` 就是由根类加载器加载的。根类加载器从系统属性 `sun.boot.class.path` 所指定的目录中加载类库。根类加载器的实现依赖于底层的操作系统，属于虚拟机实现的一部分，它并没有继承 `java.lang.ClassLoader` 类

###### 扩展类加载器（Extension）

它的父加载器为根类加载器。它从 `java.ext.dirs` 系统属性所指定的目录中加载类库，或者从JDK的安装目录的 `jre\lib\ext` 子目录（扩展目录）下加载类库，如果把用户创建的 `JAR` 文件放在这个目录下，也会自动由扩展类加载器加载。扩展类加载器是纯 Java 类，是 `java.lang.ClassLoader` 类的子类

###### 系统（应用）类加载器（System）

系统（System）类加载器也被称为应用类加载器，它的父加载器是扩展类加载器。它从环境变量 `classpath` 或者系统属性 `java.class.path` 所指定的目录中加载类，它是用户自定义的类加载器的默认父加载器。系统类加载器是纯 Java 类，是 `java.lang.ClassLoader` 类的子类

##### 用户自定义的类加载器

- `java.lang.ClassLoader` 的子类
- 除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java 提供了抽象类 `java.lang.ClassLoader`，**所有用户自定义的类加载器都应该继承 `ClassLoader` 类**

#### 命名空间

- 每一个类加载器都有自己的命名空间，**命名空间由该加载器及其所有父加载器加载的类组成**
- 在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类
- 在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类
- 同一个命名空间内的类是相互可见的。
- 子加载器的命名空间包含所有父加载器的命名空间。因此由子加载器加载的类能看见父加载器加载的类。例如系统类加载器加载的类就可以看见根类加载器加载的类
- 由父加载器加载的类不能看见子加载器加载的类
- 如果两个加载器之间没有直接或间接的父子关系，那么它们各自加载的类互不可见
- 在运行期，一个 Java 类是由该类的完全限定名（binary name，二进制名）和用于加载该类的定义类加载器（defining loader）所共同决定的。如果同样的完全限定名一样的类是由两个不同的类加载器所加载，那么这些类就是不同的，即便 `.class` 文件的字节码一样，并且从相同的位置加载也是这样的

#### 类加载器双亲委托模型的好处

- 可以确保 Java 核心类库的类型安全，所有的 Java 应用都至少会引用 `java.lang.Object` 类，也就是说在运行期间，`java.lang.Object` 这个类会被加载到 JVM 中；如果这个类是我们自己编写的类加载器完成的，那么很有可能在 JVM 中存在多个版本的 `java.lang.Object` 类，而且这些加载的虽然都是同一 `Object` 对象，但是它们之间并不兼容，还是相互不可见的（正是命名空间发挥着作用）
- 可以确保 Java 核心类库所提供的类不会被自定义的类所替代
- 不同的类加载器可以为相同名称（binary name）的类创建额外的命名空间。相同名称的类可以并存在 JVM 中，只需要用不同的类加载器加载它们即可。不同的类加载器加载的类是互不兼容的，这样就相当于在 JVM 的内部创建了一个又一个相互隔离的 Java 类空间，这类技术在很多框架中都得到了实际应用

### 连接

**类被加载后，就进入连接阶段。连接就是将读入到内存中类的二进制数据合并到虚拟机的运行时环境当中**

#### 验证

确保被加载的类的正确性

##### 验证的内容

- 类文件的结构检查
- 语义检查
- 字节码验证
- 二进制兼容性的验证

#### 准备

为类的**静态变量**分配内存，并将其初始化为**默认值**，但是在到达初始化之前，这些变量都没有初始化为真正的初始值

#### 解析

就是在类型的常量池中寻找类、接口、字段和方法的符号引动**把类中的符号引用转换为直接引用的过程**

### 初始化

**为类的静态变量赋于正确的初始值**

- 静态变量的声明语句，以及静态代码块都被看作类的初始化语句，Java虚拟机会按照初始化语句在类文件中的先后顺序来执行它们

#### 初始化步骤

- 加入这个类没有被加载和连接，那就先进行加载和连接
- 加入这个类存在直接父类，而且这个父类还没有被初始化，那就先初始化直接父类
- 假如类中存在初始化语句，那就依次执行这些初始化语句

#### 初始化时机

- Java程序对类的使用方式可以分为两种，主动使用和被动使用
- 所有的Java虚拟机实现必须在每个类或接口被Java程序**首次主动使用**时才初始化它们
- 只有当程序访问的静态变量或静态方法确实是在当前类或当前接口中定义时，才可以认为是对类或者接口的主动使用
- **调用`ClassLoader`类的`loadClass`方法加载一个类，并不是对类的主动使用，不会导致类的初始化**

当Java虚拟机在初始化一个类时，要求它的所有父类都已经初始化，但是这个规则不适用与接口

- 在初始化一个类时，并不会先初始化它所实现的接口
- 在初始化一个接口时，并不会先初始化它的父接口

因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化

##### 主动使用（七种）

- 创建类的实例
- 访问某个类或接口的静态变量，或者对该静态变量赋值
- 调用类的静态方法
- 反射（如`Class.forName("com.apache.util")`）
- 初始化一个类的子类
- Java虚拟机启动时被标明为启动类的类`(Java Test)`
- JDK1.7开始提供的动态语言支持，`java.lang.invoke.MethodHandle`实例的解析结果`REF_getStatic REF_putStatic REF_invokeStatic`句柄对应类没有初始化，则开始初始化


##### 被动使用

除了以上 7 种情况，其他使用Java类的方式都被看作是对类的**被动使用**，都不会导致类的**初始化**

### 类实例化

- 为新的对象分配内存
- 为实例变量赋默认值
- 为实例变量赋正确的初始值

Java 编译器在它编译的每一个类中都至少生成一个实例初始化方法，在 Java 的 class 文件中，这个初始化方法被称为 `<init>` 。针对源代码中每一个类的构造方法，Java 编译器都会产生一个 `<init>`  方法

## 类的使用和卸载

## 使用

### 主动使用


### 被动使用

## 卸载

- 当一个类被加载、连接、初始化后，它的生命周期就开始了。当这个类的 Class 对象不再被引用，即这个 Class 对象不可访问时，Class 对象就会结束生命周期，这个类在方法区的数据也会被卸载，从而结束这个类的生命周期
- **一个类何时结束生命周期，取决于代表它的 Class 对象何时结束生命周期**
- 由 Java 虚拟机自带的类加载器说加载的类，在虚拟机的生命周期中，始终不会被卸载。之前已经介绍过，Java 虚拟机自带的类加载器包括根类加载器、扩展类加载器、系统类加载器。Java 虚拟机会始终引用这些类加载器，而这些类加载器则会始终引用它们说加载的类的 Class 对象，因此这些 Class 对象始终是可触及的
- **由用户自定义的类加载器所加载的类是可以被卸载的**
- 运行这些程序时，我们自己编写的类由我们自己编写的类加载器加载。在类加载器的内部实现中，用一个 Java 集合来存放所加载类的引用。另一方面，一个 Class 对象总是会引用它的类加载器。由此可见，代表一个类的 Class 实例于我们自己编写的类加载器为双向关联关系。
- 一个类的实例总是引用代表这个类的 Class 对象。在 Objecr 类中定义了 `getClass()` 方法，这个方法返回代表对象所属类的 Class 对象的引用。此外，所有的 Java 类都有一个静态属性 class ，它引用着代表这个类的 Class 对象