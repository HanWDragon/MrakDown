# JVM运行时内存数据区域

![](image/Pasted%20image%2020220508113117.png)

## Java虚拟机栈（JVM Stack）

- Java虚拟机栈描述的是Java方法的执行模型：每个方法执行的时候会创建一个帧（Frame）栈用与存放局部变量表，操作栈，动态链接，方法出口等信息，一个方法的执行过程，就是这个方法对于栈帧的入栈出栈过程
- 线程隔离

## 堆（Heap）

- 堆里存放的是对象的实例
- **是Java虚拟机管理内存中最大的一块**
- **GC主要的工作区域，为了高效的GC，会把堆细分更多的子区域**
- 线程共享

## 方法区域

- 存放了每个Class的结构信息，包括常量池、字段描述、方法描述
- GC的非主要工作区域
- Java虚拟机规范表水可以不要求虚拟机在这一区域实现GC，这一区域的GC“性价比“一般都比较低
- 在堆中，尤其是在新生代，常规应用进行一次GC一般可以回收70%～95%的空间，而方法区的GC效率远小与此
- 当前的商业JVM都有实现方法区的GC，主要回收两部分内容：废弃常量与无用类
- 类回收需要满足如下三个条件
	- 该类所有的实例都已经被GC，也就是JVM中不存在该Class的任何实例
	- 加载该类的ClassLoader已经被GC了
	- 该类对应的java.lang.Class对象没有在任何地方被引用，即不能在任何地方通过反射访问该对象的方法
- 在大量使用反射、动态代理、CGLib、ASM等字节码框架，动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要JVM具备类卸载的支持来保证方法区不会溢出


# JVM垃圾回收（GC）模型

## 垃圾判断算法

### 引用计数算法（Reference Counting）

- 给对象添加一个引用计数器，当有一个地方引用它，计数器加一，当引用失效，计数器减一，任何时刻计数器为0的对象就是不可能再被使用的
- 引用计数算法无法解决对象循环引用的问题

### 根搜索算法（Root Tracing）

- 在实际的生产语言中（Java、C#等），都是使用根搜索算法判定对象是否存活
- 算法的基本思路就是通过一系列的称为”GC Roots“ 的点作为起始进行向下搜索，当一个对象到GC Roots没有任何引用链（Reference Chain）相连，则证明此对象是不可用的

#### 在Java中，GC Roots包括

- 在VM栈（帧中的本地变量）中的应用
- 方法区中的静态引用
- JNI（即一般说的Native方法）中的引用

## GC算法

![](image/Pasted%20image%2020220508184941.png)

### 标记-清除算法（Mark-Sweep）

- 算法分为“**标记**”和“**清除**”两个阶段，首先标记出所有需要需要回收的对象，然后回收所有需要回收的对象
- 缺点
	- **效率问题**，标记和清理两个过程效率都不高，需要扫描所有对象，堆越大GC越慢
	- **空间问题**，标记清理之后会产生大量不连续的内存碎片，空间碎片太多可能会导致后续使用中无法找到足够的连续内存而提前触发另一次垃圾收集动作，GC次数越多，碎片越严重

![](image/Pasted%20image%2020220508144615.png)

![](image/Pasted%20image%2020220508144659.png)

![](image/Pasted%20image%2020220508144919.png)

![](image/Pasted%20image%2020220508144953.png)

### 标记整理算法（Mark-Compact）

- 标记过程依然一样，但后续步骤不是进行直接清理，而是让所有存活的对象一端移动，然后直接清理掉这段边界以外的内存
- 没有内存碎片
- 比Mark-Sweep耗费更多的时间进行compact

![](image/Pasted%20image%2020220508152119.png)



### 复制收集算法（Copying）

- 将可用内存划分为两块，每次只使用其中的一块，当半区内存用完了，仅将还存活的对象复制到另外一块上面，然后就把原来的一块内存空间一次性清理掉
- 这样使得每一次内存后手都是对整个半区的回收，内存分配时依旧不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存就可以了，实现简单，运行高效
- **只是这种算法的代价是将可用内存缩小到原来的一半，代价高昂**
- 现代的商业虚拟机中都是用了这一种算法来回收**新生代**
- 将内存分为一块较大的eden空间和2块较少的survivor空间，每次使用eden和其中一块survivor，当回收时将eden和survivor还存活的对象一次性拷贝到另外一块survivor空间上，然后清理掉eden和用过的survivor
- Oracle Hotspot虚拟机默认eden和survivor的大小比例是8:1，也就是每次只有10%的内存是“浪费“的
- **复制收集算法在对象存活率高的时候，效果并不理想**
- 如果不想浪费50%的空间，就需要有额外的空间进行分配担保用于应付半区内存中所有对象都100%存活的极端情况，所有在老年代一般不能直接选用这个算法
- 只需要扫描存活的对象，效率更高
- 不会产生碎片
- 需要浪费额外的内存作为复制区
- 复制算法非常适合生命周期比较短的对象，因为这样每次GC都能回收大部分对象，复制的开销比较小
- 根据IBM的专门研究，98%的Java对象只会存活1个GC周期，对这些对象很适合用复制算法。而且不用1:1的划分工作区和复制区的空间

![](image/Pasted%20image%2020220508151226.png)

![](image/Pasted%20image%2020220508151321.png)

![](image/Pasted%20image%2020220508151334.png)

### 分代收集算法（Generational Collecting）

- 当前商业虚拟机的垃圾收集都是采用“分代收集”（Generational Collecting）算法，根据对象的不同的存活时间将内存划分为几块。
- 一般是把Java堆分为**新生代和老年代**，这样就可以根据各个年代的特点采用最适合的收集算法，譬如新生代每次GC都有大量的对象内存被回收，那么就可以选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集
- 综合前面几种GC算法的优缺点，针对不同生命周期的对象那个采用不同的GC算法

![](image/Pasted%20image%2020220508153526.png)

- Hotspot 在Java6中共划分为三个代：**年轻代（Young Generation）、老年代（Old Generation）、永久代（Permanent Generation）**

![](image/Pasted%20image%2020220508153937.png)

## 年轻代（Young Generation）

- 新生成的对象都放在新生代。年轻代用复制算法进行GC（理论上，年轻代对象的生命周期非常短，所以非常适合复制算法）
- 年轻代分为三个区。一个Eden区，两个Survivor区（可以通过参数来设置Survivor个数）。对象在Eden区中生成，当Eden区满时，会存活的对象将被复制到一个Survivor区，当这个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当第二个Survivor区也满了的时候，从第一个Survivor区复制过来的对象并且此时还存活的对象，将会被复制到老年代。2个Survivor是完全对称，相互交替使用
- Eden和2个Survivor的缺省比例是8:1:1也是就是10%的空间会被浪费。可以根据GC log的信息来调整比例

## 老年代（Old Generation）

- 存放了经过一次或者多次GC还存活的对象
- 一般采用Mark-Sweep或者Mark-Compact算法进行GC
- 有多种垃圾收集器可以选择。每种垃圾收集器可以看作一个GC算法的具体实现。可以根据具体应用的需求选用合适的垃圾收集器（追求吞吐量、追求最短响应时间）

## 永久代

- 并不属于堆（Heap），但是GC也会涉及到这个区域
- 存放了每个Class的结构信息，包括常量池、字段描述、方法描述与垃圾收集器要收集的Java对象关系不大

## 内存分配

### 堆上分配

大多数情况都在eden上分配，偶尔会直接在old上分配，细节取决于GC的实现

### 栈上分配

原子类型的局部变量

## 内存回收

- GC要做的是将哪些dead的对象所占用的内存回收掉
	- Hotspot认为没有引用的对象是dead的
	- Hotspot将引用分为四种：**Strong、Soft、Weak、Phantom**
		- Strong即默认通过`Object o = new Object()`这种方式赋值的引用
		- Soft、Weak、Phantom这三种都是继承Reference
- 在Full GC时会对Reference类型的引用进行特殊处理
	- Soft：内存不够时一定会被GC、长期不用也会被GC
	- Weak：一定会被GC，当被mark为dead，会在ReferenceQueue通知
	- Phantom：本来就没引用，当从JVM heap中释放会通知

## GC的时机

- 在分代模型的基础上，GC从时机上分为两种：Scavenge GC和Full GC
- Scavenge GC（Minor GC）
	- 触发时机：新对象生成时，Eden空间满了
	- 理论上Eden区大多数对象会在Scavenge GC回收，复制算法的执行效率会很高，Scavenge GC的时间比较短
- FullGC
	- 对整个JVM进行整理，包括Young、Old、Perm
	- 主要的触发时机
		- Old满了
		- Perm满了
		- `system.gc()`
	- 效率很低，尽量减少Full GC

## 垃圾回收器（Garbage Collector）

- 分代模型：GC的宏观愿景
- 垃圾回收器：GC的具体实现
- Hotspot JVM提供多种垃圾回收器，我们需要根据具体应用的需要采用不同的回收器
- 没有万能的垃圾回收器，每种垃圾收集器都有自己适用的场景

### 并行与并发

- 并行（Parallel）：指多个收集器的线程同时工作，但是用户线程处于等待状态
- 并发（Concurrent）：指收集器在工作的同时，可以允许用户线程工作
	- 并发并不代表解决了GC停顿问题，在关键的步骤还是要停顿。比如在收集器标记垃圾的时候。但在收集器清除垃圾的时候，用户线程可以和GC线程并发执行

### Serial收集器

- 单线程收集器，收集时会暂停所有工作线程（Stop The World，简称STW），使用复制收集算法，虚拟机运行在Client模式时的默认新生代收集器
- 最早的收集器，单线程进行GC
- New和Old Generation都可以使用
- 在新生代，采用复制算法，在老年代，采用Mark-Compact算法
- 因为是单线程GC，没有多线程切换的额外开销，简单实用
- Hotspot Client模式缺省的收集器

![](image/Pasted%20image%2020220508204946.png)

### ParNew收集器

- ParNew收集器就是Serial的多线程版本，除了使用多个收集线程外，其余行为包括算法、STW、对象分配规则、回收策略等都与Serial收集器一摸一样
- 对应的这种收集器是虚拟机运行在Server模式的默认新生代收集器，在单CPU的环境中，ParNew收集器并不会比Serial收集器有更好的效果
- Serial收集器在新生代的多线程版本
- 使用复制算法（因为针对新生代）
- **只有在多CPU的环境下，效率才会比Serial收集器高**
- 可以通过`-XX:ParallelGCThreads`来控制GC线程数的多少，需要结合具体CPU个数
- Server模式下新生代的缺省收集器

### Parallel Scavenge收集器

- Parallel Scavenge收集器也是一个多线程收集器，也是使用复制算法，但它的对象分配规则与回收策略都与ParNew收集器有所不同，它是以吞吐量最大化（即GC时间占总运行时间最小）为目标的收集器实现，它允许较长时间的STW换取总吞吐量最大化

### Serial Old收集器

- Serial Old是单线程收集器，使用标记-整理算法，是老年代的收集器

### Parallel Old收集器

- 老年代版本吞吐量优先收集器，使用多线程和标记-整理算法，JVM1.6提供，在此之前，新生代使用了PS收集器的话，老年代除Serial Old外别无选择，因为PS无法与CMS收集器配合工作
- Parllel Scavenge在老年代的实现
- 在JVM1.6才出现Parallel Old
- 采用多线程，Mark-Compact算法
- 更注重吞吐量
- Parllel Scavenge + Parallel Old = 高吞吐量，但GC停顿可能不理想

![](image/Pasted%20image%2020220508214520.png)

### CMS（Concurrent Mark Sweep）收集器

- CMS是一种以最短停顿时间为目标的收集器，使用CMS并不能达到GC效率最高（总体GC时间最小），但它能尽可能降低GC时服务的停顿时间，CMS收集器使用的是标记-清除算法
- 追求最短停顿时间，非常适合Web应用
- 只针对老年区，一般结合ParNew使用
- Concurrent，GC线程和用户线程并发工作（尽量并发）
- 只有在多CPU环境下才有意义
- 使用`-XX:UseConcMarkSweepGC`打开

#### 缺点

- CMS以牺牲CPU资源的代价来减少用户线程的停顿。当CPU个数少于4的时候，有可能对吞吐量影响非常大
- CMS在并发清理的过程中，用户线程还在跑。这时候需要预留一部分空间给用户线程
- CMS用Mark-Sweep，会带来碎片问题。碎片过多的时候会容易频繁触发Full GC

# Java内存泄漏的经典原因

## 对象定义在错误的范围（Wrong Scope）

- 如果Foo实例对象的生命周期较长，会导致临时性内存泄漏。（这里的names变量其实只有临时作用）

```Java
class Foo {
	private String[] names;
	public void doIt(int length) {
		if (names == null || names.length < length)
			names = new String[length];
		populate(names);
		print(names);
	}
}
```

- JVM喜欢生命周期短的对象，咋样做已经足够高效了

```Java
class Foo {
	public void doIt(int length) {
		if (names == null || names.length < length)
		String[] names = new String[length];
		populate(names);
		print(names);
	}
}
```

## 异常（Exception）处理不当

- 错误的做法

```java
Connecttion conn = DriverManager.getConnection(url, name, password);

try {
	String sql = "do a query sql";
	PreparedStatement stmt = conn.preparStatement(sql);
	ReslutSet rs = stmt.executeQuery();
	while (rs.next) {
		doSomeStuff();
	}
	rs.close();
	conn.close();
} catch (Exception e) {
	// 如果doSomeStuff()抛出异常
	// rs.close和conn.close不会被调用
	// 会导致内存泄漏和db链接泄漏
}
```

- 正确的做法

```java
Connecttion conn = DriverManager.getConnection(url, name, password);

try {
	String sql = "do a query sql";
	PreparedStatement stmt = conn.preparStatement(sql);
	ReslutSet rs = stmt.executeQuery();
	while (rs.next) {
		doSomeStuff();
	}
	rs.close();
	conn.close();
} catch (Exception e) {
	// handle exception
} finally {
	// 永远用finally去关闭资源，避免资源泄漏
	if (rs != null) {
		rs.close();
	}
	if (stmt != null) {
		stmt.close();
	}
	conn.close();
}
```

## 集合数据管理不当

- 当使用Array-based的数据结构（ArrayList、HashMap等）时，尽量减少resize
	- 比如new ArrayList时，尽量估算size，在创建的时候把size确定
	- 减少resize可以避免没有必要的array copying，gc碎片等问题
- 如果一个List只需要顺序访问，不需要随机访问（Random Access），用LinkedList代替ArrayList
	- LinkedList本质是链表，不需要resize，但是只适用于顺序访问