# 什么是底层原理，研究的内容是什么

![](image/Pasted%20image%2020220209010109.png)

![](image/Pasted%20image%2020220209010247.png)

![](image/Pasted%20image%2020220209010337.png)

## 从Java代码到CPU指令

![](image/Pasted%20image%2020220209010150.png)

![](image/Pasted%20image%2020220209010222.png)

# JVM内存结构、Java内存模型、Java对象模型

![](image/Pasted%20image%2020220209010702.png)

![](image/Pasted%20image%2020220209010745.png)

## JVM内存结构

![](image/Pasted%20image%2020220209010903.png)

![](image/Pasted%20image%2020220209011228.png)

## Java对象模型

![](image/Pasted%20image%2020220209011309.png)

![](image/Pasted%20image%2020220209011433.png)

# JMM是什么

![](image/Pasted%20image%2020220209011817.png)

## JMM是规范

![](image/Pasted%20image%2020220209011825.png)

![](image/Pasted%20image%2020220209011741.png)

![](image/Pasted%20image%2020220209011844.png)

## JMM是工具类和关键字的原理

![](image/Pasted%20image%2020220209012058.png)

## 最重要的3点内容：重排序、可见性、原子性

# 重排序

## 重排序的例子、什么是重排序

![](image/Pasted%20image%2020220209014029.png)

## 代码演示

```java
package jmm;

import java.util.concurrent.CountDownLatch;

/**
 * 描述：     演示重排序的现象 “直到达到某个条件才停止”，测试小概率事件
 */
public class OutOfOrderExecution {

    private static int x = 0, y = 0;
    private static int a = 0, b = 0;

    public static void main(String[] args) throws InterruptedException {
        int i = 0;
        for (; ; ) {
            i++;
            x = 0;
            y = 0;
            a = 0;
            b = 0;

            CountDownLatch latch = new CountDownLatch(3);

            Thread one = new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        latch.countDown();
                        latch.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    a = 1;
                    x = b;
                }
            });
            Thread two = new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        latch.countDown();
                        latch.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    b = 1;
                    y = a;
                }
            });
            two.start();
            one.start();
            latch.countDown();
            one.join();
            two.join();

            String result = "第" + i + "次（" + x + "," + y + ")";
            if (x == 0 && y == 0) {
                System.out.println(result);
                break;
            } else {
                System.out.println(result);
            }
        }
    }


}

```

## 重排序分析

![](image/Pasted%20image%2020220209013216.png)

 ![](image/Pasted%20image%2020220209013729.png)

 ![](image/Pasted%20image%2020220209013959.png)

## 重排序的好处：提高处理速度

![](image/Pasted%20image%2020220209014230.png)

## 重排序的三种情况

![](image/Pasted%20image%2020220209014336.png)

# 可见性

## 什么是可见性问题

### 代码演示

```java
package jmm;

/**
 * 描述：     演示可见性带来的问题
 */
public class FieldVisibility {

    volatile int a = 1;
    volatile int b = 2;

    private void change() {
        a = 3;
        b = a;
    }


    private void print() {
        System.out.println("b=" + b + ";a=" + a);
    }

    public static void main(String[] args) {
        while (true) {
            FieldVisibility test = new FieldVisibility();
            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    test.change();
                }
            }).start();

            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    test.print();
                }
            }).start();
        }

    }


}

```

![](image/Pasted%20image%2020220209141551.png)

## 为什么有可见性问题

![](image/Pasted%20image%2020220209141903.png)

![](image/Pasted%20image%2020220209142254.png)

![](image/Pasted%20image%2020220209142303.png)

![](image/Pasted%20image%2020220209142313.png)

## JMM的抽象：主内存和本地内存

### 什么是主内存和本地内存

![](image/Pasted%20image%2020220209142520.png)

![](image/Pasted%20image%2020220209142537.png)

![](image/主内存和工作内存2.png)

### 主内存和本地内存的关系

![](image/Pasted%20image%2020220209143137.png)

## Happens-Before原则

## 什么是happens-before

![](image/Pasted%20image%2020220209143458.png)

## 什么不是happens-before

![](image/Pasted%20image%2020220209143838.png)

## Happens-before规则有哪些

### 单线程规则

![](image/Pasted%20image%2020220209144325.png)

### 锁操作（synchronized和Lock）

![](image/Pasted%20image%2020220209144809.png)

![](image/Pasted%20image%2020220209144928.png)

### volatile变量

![](image/Pasted%20image%2020220209150814.png)

### 线程启动

![](image/Pasted%20image%2020220209150937.png)

### 线程join

![](image/Pasted%20image%2020220209151045.png)

### 传递性

 ![](image/Pasted%20image%2020220209151603.png)

### 中断

![](image/Pasted%20image%2020220209151635.png)

### 构造方法

![](image/Pasted%20image%2020220209151701.png)

### 工具类的Happens-Before原则

![](image/Pasted%20image%2020220209144258.png)

### 演示

```java
package jmm;

/**
 * 描述：     演示可见性带来的问题
 */
public class FieldVisibility {

    volatile int a = 1;
    volatile int b = 2;

    private void change() {
        a = 3;
        b = a;
    }


    private void print() {
        System.out.println("b=" + b + ";a=" + a);
    }

    public static void main(String[] args) {
        while (true) {
            FieldVisibility test = new FieldVisibility();
            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    test.change();
                }
            }).start();

            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    test.print();
                }
            }).start();
        }

    }


}

```

![](image/Pasted%20image%2020220209152416.png)

![](image/Pasted%20image%2020220209152529.png)

![](image/Pasted%20image%2020220209153008.png)

## volatile关键字

### volatile是什么

![](image/Pasted%20image%2020220209154507.png)

### volatile的适用场景

![](image/Pasted%20image%2020220209154637.png)

```java
package jmm;


import java.util.concurrent.atomic.AtomicInteger;

/**
 * 描述：     不适用于volatile的场景
 */
public class NoVolatile implements Runnable {

    volatile int a;
    AtomicInteger realA = new AtomicInteger();

    public static void main(String[] args) throws InterruptedException {
        Runnable r =  new NoVolatile();
        Thread thread1 = new Thread(r);
        Thread thread2 = new Thread(r);
        thread1.start();
        thread2.start();
        thread1.join();
        thread2.join();
        System.out.println(((NoVolatile) r).a);
        System.out.println(((NoVolatile) r).realA.get());
    }
    @Override
    public void run() {
        for (int i = 0; i < 10000; i++) {
            a++;
            realA.incrementAndGet();
        }
    }
}

```

![](image/Pasted%20image%2020220209154646.png)

```java
package jmm;

import java.util.concurrent.atomic.AtomicInteger;
import singleton.Singleton8;

/**
 * 描述：     volatile适用的情况1
 */
public class UseVolatile1 implements Runnable {

    volatile boolean done = false;
    AtomicInteger realA = new AtomicInteger();

    public static void main(String[] args) throws InterruptedException {
        Runnable r =  new UseVolatile1();
        Thread thread1 = new Thread(r);
        Thread thread2 = new Thread(r);
        thread1.start();
        thread2.start();
        thread1.join();
        thread2.join();
        System.out.println(((UseVolatile1) r).done);
        System.out.println(((UseVolatile1) r).realA.get());
    }
    @Override
    public void run() {
        for (int i = 0; i < 10000; i++) {
            setDone();
            realA.incrementAndGet();
        }
    }

    private void setDone() {
        done = true;
    }
}

```

```java
package jmm;

import java.util.concurrent.atomic.AtomicInteger;

/**
 * 描述：     volatile不适用的情况2
 */
public class NoVolatile2 implements Runnable {

    volatile boolean done = false;
    AtomicInteger realA = new AtomicInteger();

    public static void main(String[] args) throws InterruptedException {
        Runnable r =  new NoVolatile2();
        Thread thread1 = new Thread(r);
        Thread thread2 = new Thread(r);
        thread1.start();
        thread2.start();
        thread1.join();
        thread2.join();
        System.out.println(((NoVolatile2) r).done);
        System.out.println(((NoVolatile2) r).realA.get());
    }
    @Override
    public void run() {
        for (int i = 0; i < 10000; i++) {
            flipDone();
            realA.incrementAndGet();
        }
    }

    private void flipDone() {
        done = !done;
    }
}

```

![](image/Pasted%20image%2020220209154654.png)

![](image/Pasted%20image%2020220209160526.png) 

### volatile的作用：可见性、禁止重排序

![](image/Pasted%20image%2020220209160733.png)
	
### volatile和synchronized的关系

![](image/Pasted%20image%2020220209160921.png) 

### 用volatile修正重排序问题

![](image/Pasted%20image%2020220209161005.png)

```java
package jmm;

import java.util.concurrent.CountDownLatch;

/**
 * 描述：     演示重排序的现象 “直到达到某个条件才停止”，测试小概率事件
 */
public class OutOfOrderExecution {

    private static int x = 0, y = 0;
    private static int a = 0, b = 0;

    public static void main(String[] args) throws InterruptedException {
        int i = 0;
        for (; ; ) {
            i++;
            x = 0;
            y = 0;
            a = 0;
            b = 0;

            CountDownLatch latch = new CountDownLatch(3);

            Thread one = new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        latch.countDown();
                        latch.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    a = 1;
                    x = b;
                }
            });
            Thread two = new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        latch.countDown();
                        latch.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    b = 1;
                    y = a;
                }
            });
            two.start();
            one.start();
            latch.countDown();
            one.join();
            two.join();

            String result = "第" + i + "次（" + x + "," + y + ")";
            if (x == 0 && y == 0) {
                System.out.println(result);
                break;
            } else {
                System.out.println(result);
            }
        }
    }


}

```

### volatile小结

![](image/Pasted%20image%2020220209161051.png)

![](image/Pasted%20image%2020220209161124.png)

![](image/Pasted%20image%2020220209161147.png)

![](image/Pasted%20image%2020220209161245.png)

![](image/Pasted%20image%2020220209161259.png)

![](image/Pasted%20image%2020220209161318.png)

## 能保证可见性的措施

![](image/Pasted%20image%2020220209161456.png)

## 对synchronized可见性的理解

![](image/Pasted%20image%2020220209162240.png)

# 原子性

## 什么是原子性

![](image/Pasted%20image%2020220209191615.png)

![](image/Pasted%20image%2020220209191753.png)

![](image/Pasted%20image%2020220209192003.png)

![](image/Pasted%20image%2020220209191816.png)

## Java中原子操作有哪些

![](image/Pasted%20image%2020220209192800.png)

## long和double的原子性

![](image/Pasted%20image%2020220209193616.png)

![](image/Pasted%20image%2020220209193717.png)

## 原子操作 + 原子操作 != 原子操作

![](image/Pasted%20image%2020220209193847.png)

# 面试题

![](image/Pasted%20image%2020220209202303.png)

![](image/Pasted%20image%2020220209202431.png)

![](image/Pasted%20image%2020220209202442.png)

![](image/Pasted%20image%2020220209202455.png)

![](image/Pasted%20image%2020220209202510.png)

## 单例模式的8中写法

### 饿汉式（静态常量）[可用]

```java
package singleton;

/**
 * 描述：     饿汉式（静态常量）（可用）
 */
public class Singleton1 {

    private final static Singleton1 INSTANCE = new Singleton1();

    private Singleton1() {

    }

    public static Singleton1 getInstance() {
        return INSTANCE;
    }

}

```

### 饿汉式（静态代码块）[可用]

```java
package singleton;

/**
 * 描述：     饿汉式（静态代码块）（可用）
 */
public class Singleton2 {

    private final static Singleton2 INSTANCE;

    static {
        INSTANCE = new Singleton2();
    }

    private Singleton2() {
    }

    public static Singleton2 getInstance() {
        return INSTANCE;
    }
}

```

### 懒汉式（线程不安全）[不可用]

```java
package singleton;

/**
 * 描述：     懒汉式（线程不安全）
 */
public class Singleton3 {

    private static Singleton3 instance;

    private Singleton3() {

    }

    public static Singleton3 getInstance() {
        if (instance == null) {
            instance = new Singleton3();
        }
        return instance;
    }
}

```

### 懒汉式（线程安全、同步方法）[不推荐用]

```java
package singleton;

/**
 * 描述：     懒汉式（线程安全）（不推荐）
 */
public class Singleton4 {

    private static Singleton4 instance;

    private Singleton4() {

    }

    public synchronized static Singleton4 getInstance() {
        if (instance == null) {
            instance = new Singleton4();
        }
        return instance;
    }
}

```

### 懒汉式（线程安全、同步代码块）[不可用]

```java
package singleton;

/**
 * 描述：     懒汉式（线程不安全）（不推荐）
 */
public class Singleton5 {

    private static Singleton5 instance;

    private Singleton5() {

    }

    public static Singleton5 getInstance() {
        if (instance == null) {
            synchronized (Singleton5.class) {
                instance = new Singleton5();
            }
        }
        return instance;
    }
}

```

### 双重检查[推荐用]

![](image/Pasted%20image%2020220209210329.png)

1. 新建对象
2. 调用构造方法
3. 将对象的地址赋给引用

但是要注意 `new` 可不是像赋值是一个原子操作,所以要加上 volatile 防止指令重排序

```java
package singleton;

/**
 * 描述：     双重检查（推荐面试使用）
 */
public class Singleton6 {

    private volatile static Singleton6 instance;

    private Singleton6() {

    }

    public static Singleton6 getInstance() {
        if (instance == null) {
            synchronized (Singleton6.class) {
                if (instance == null) {
                    instance = new Singleton6();
                }
            }
        }
        return instance;
    }
}

```

### 静态内部类[推荐用]

JVM保证

```java
package singleton;

/**
 * 描述：     静态内部类方式，可用
 */
public class Singleton7 {

    private Singleton7() {
    }

    private static class SingletonInstance {

        private static final Singleton7 INSTANCE = new Singleton7();
    }

    public static Singleton7 getInstance() {
        return SingletonInstance.INSTANCE;
    }
}

```

### 枚举[推荐用]

```java
package singleton;

/**
 * 描述：     枚举单例
 */
public enum Singleton8 {
    INSTANCE;

    public void whatever() {

    }
}
```

## 对比

![](image/Pasted%20image%2020220209212145.png)

## 那种实现最好

![](image/Pasted%20image%2020220209212421.png)

## 适合场景

![](image/Pasted%20image%2020220209212531.png)

![](image/Pasted%20image%2020220209212646.png)

![](image/Pasted%20image%2020220209212720.png)

![](image/Pasted%20image%2020220209212742.png)

![](image/Pasted%20image%2020220209212753.png)

