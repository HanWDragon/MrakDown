# “三高”架构之路

## 什么是“三高”

![](image/Pasted%20image%2020220307151934.png)

## 为什么不直接讲“三高”

![](image/Pasted%20image%2020220307152058.png)

### 复制

![](image/Pasted%20image%2020220307152310.png)

### 扩展

![](image/Pasted%20image%2020220307152638.png)

### 切换

![](image/Pasted%20image%2020220307152730.png)

## “三高”的实现

![](image/Pasted%20image%2020220307152909.png)

## 接下来要学习的

![](image/Pasted%20image%2020220307152953.png)

# 常见的Mysql集群方案

![](image/Pasted%20image%2020220410204722.png)

## PXC原理

![](image/Pasted%20image%2020220410205011.png)

## 两种方案的对比

![](image/Pasted%20image%2020220411000839.png)

![](image/Pasted%20image%2020220411005242.png)

## 数据一致性

![](image/Pasted%20image%2020220411005432.png)

# 复制有哪些类型

## 复制的基本原理

![](image/Pasted%20image%2020220307153127.png)

## 复制的类型

![](image/Pasted%20image%2020220307155626.png)

### 异步复制（Asynchronous Replication）

![](image/Pasted%20image%2020220307155807.png)

![](image/Pasted%20image%2020220307155922.png)

### 半同步复制（Semisynchronous Replication）

![](image/Pasted%20image%2020220307160107.png)

![](image/Pasted%20image%2020220307160255.png)

### 组复制（Group Replication）

![](image/Pasted%20image%2020220307161722.png)

![](image/Pasted%20image%2020220307162049.png)

## 总结

![](image/Pasted%20image%2020220307162141.png)

# 主从复制演示

1. 首先双方都需要打开 `binlog` 可以通过修改MySQL的配置文件来指定 `binlog` 的存放位置

```shell
vim /etc/my.conf
```

![](image/Pasted%20image%2020220307162816.png)

设置了这些后就会打开binlog，如果不打开是没有的，而且注意 `server-id`  在一个集群中数字要不一样

2. 给主库上全局锁，因为我们要备份数据到从库，因为主备复制是复制的增量，所以先前的数据需要从原来的数据库恢复，请注意这里不能热备，因为此时如果有数据进来，会导致`binlog`发生变化，而且此时并未完全搭建好主从数据库，所以数据库只能只读或者关闭
```mysql
FLUSH TABLE WITH READ LOCK;
```

给MySQL加上全局锁，此时只能读，不会产生新的 `binlog`

```mysql
SHOW MASTER STATUS;
```

可以加入 /G 参数来竖着显示表格。

3. 现在开始使用备份工具备份主库的数据，通过命令传送到从库
```shell
scp dbdump.sql root@192。168.1.1:/root/dbdump.sql
```

等传送完成后，就可以解锁了，现在主库的任务就完成的，把目光放到从库上来

```mysql
UNLOCK TABLES;
```

导入备份文件

```mysql
source /root/dbdump.sql
```

我们先看一下从库的状态

```mysql
show slave status;
```

如果此时是从库，可以解除关系，或者重置，重新绑定主从关系

```mysql
stop slave;
reset slave;
```

现在就可以绑定主从关系,我们首先查看主库当时开始备份的状态，确定从`binlog`哪个部分开始进行同步，然后再来绑定关系

```mysql
SHOW MASTER STATUS;
```

```mysql
change master to 
MASTER_HOST='对应的主库IP地址',
MASTER_USER='你要登陆MySQL的账户名'
MASTER_LOG_FILE='你在主库查询当时备份的名称如：mysql-bin。000012'
MASTER_LOG_POS='你查询到的对应的位置';
```

当绑定好后我们可以查询对应的状态

```mysql
show slave status;
```

当看到下图这些都是：Yes，就代表从机已经启动了

![](image/Pasted%20image%2020220307185553.png)

而且MySQL默认的复制是异步，需要其他的在配置文件手动修改，半同步的机制是插件，不是跟着MySQL自动装上的

![](image/Pasted%20image%2020220307195404.png)

重启即可，现在我们可以查看脱扣的参数和启动的线程

```mysql
show variables like 'rpl_seim_sync_master_timeout';
show processlist;
```

# 怎样使得复制的配置更方便

## 思路

![](image/Pasted%20image%2020220307200006.png)

## GTID  (Global Transaction Identifier)

![](image/Pasted%20image%2020220307200150.png)

## 如何启动GTID

![](image/Pasted%20image%2020220307200246.png)

## 使用GTID进行主从复制

```mysql
change master to 
MASTER_HOST='对应的主库IP地址',
MASTER_USER='你要登陆MySQL的账户名'
master_auto_position=1;
```

当设置好后，我们就可以在从库的相关设置中看到

![](image/Pasted%20image%2020220307200706.png)

## 总结

![](image/Pasted%20image%2020220307200733.png)

# 为什么binlog格式会影响复制

## statement格式的binlog

![](image/Pasted%20image%2020220307200943.png)

也许你会疑惑为什么有风险，看下面的实验,看看对应的 `binlog` 格式

![](image/Pasted%20image%2020220307201201.png)

下面的SQL语句可以设置格式

```mysql
 SET binlog_format = STATEMENT
```

那么在主库执行下面的操作，可能会导致数据不一致

```mysql
delete from 'table' limit 1;
```

因为你并不知道数据库删除的是那一条，而且由于记录的是 SQL 原文，当从库执行的时候结果也是未知的，因为在很多时候，你并不确定主库和从库的索引是否相同，因为在真实环境下，索引可能会修改。

我们也可以自己查看 statement 格式的 binlog

```mysql
show master status;#找到当前使用的binlog
show binlog events in '当前使用的binlog';
```


## ROW格式的binlog

![](image/Pasted%20image%2020220307202602.png)

```mysql
set binlog_format = ROW;
```

## mixed格式的binlog

![](image/Pasted%20image%2020220307202928.png)

## 基于语句或行的复制

![](image/Pasted%20image%2020220307203017.png)

## 总结

![](image/Pasted%20image%2020220307203048.png)

# 备库延迟太大，如何解决

## 复制的基本原理

![](image/Pasted%20image%2020220307204114.png)

## 备库延迟的原因

![](image/Pasted%20image%2020220307204429.png)

## 处理方法

![](image/Pasted%20image%2020220307204934.png)

## 依然存在的问题

![](image/Pasted%20image%2020220307205218.png)

![](image/Pasted%20image%2020220307205230.png)

![](image/Pasted%20image%2020220307205206.png)

## 总结

![](image/Pasted%20image%2020220307205302.png)

## 并行复制的思路

![](image/Pasted%20image%2020220307205450.png)

![](image/Pasted%20image%2020220307205639.png)

## MySQL 5.6 并行复制

![](image/Pasted%20image%2020220307210050.png)

## MySQL 5.7 使用按事务组并行的策略

![](image/Pasted%20image%2020220307210305.png)

下面两张图就很好的解释了什么是事务组

![](image/Pasted%20image%2020220307210526.png)

将原来的单独提交，变成了 1 号把之后 2 号和 3 号 的修改都统一提交了，那么 1、2、3 号就是一个事务组

![](image/Pasted%20image%2020220307210602.png)

![](image/Pasted%20image%2020220307211412.png)

![](image/Pasted%20image%2020220307211441.png)

因为只有当第一个线程提交，剩下的事务才会去提交，可能会将MySQL的可用内存减少

![](image/Pasted%20image%2020220307211850.png)

## MySQL 5.7.22 并行复制

![](image/Pasted%20image%2020220307212107.png)

## 总结

![](image/Pasted%20image%2020220307212150.png)

# 如何在从库读到最新数据

## 强制走主库

## 如何判断从库已经追上

![](image/Pasted%20image%2020220307215634.png)

## 从库延迟从理论上无法消灭

![](image/Pasted%20image%2020220307215825.png)

![](image/Pasted%20image%2020220307215929.png)

## 判断具体的事务是否已经重放

![](image/Pasted%20image%2020220307221228.png)

## 总结

![](image/Pasted%20image%2020220307221301.png)

# 怎样实现最简单的高可用架构

## 主-主复制架构

![](image/Pasted%20image%2020220307221439.png)

![](image/Pasted%20image%2020220307221509.png)

![](image/Pasted%20image%2020220307221639.png)

![](image/Pasted%20image%2020220307221709.png)

![](image/Pasted%20image%2020220307221743.png)

### 问题

![](image/Pasted%20image%2020220307221954.png)

#### 数据冲突问题

![](image/Pasted%20image%2020220307222122.png)

#### 客户端切换

![](image/Pasted%20image%2020220307222228.png)

#### 循环复制

![](image/Pasted%20image%2020220307222331.png)

## 总结

![](image/Pasted%20image%2020220307222404.png)

# 本章小结

## 复制有哪些类型

![](image/Pasted%20image%2020220307222525.png)

## GTID（Global Transaction Identifier）

![](image/Pasted%20image%2020220307222636.png)

## binlog格式

![](image/Pasted%20image%2020220307222656.png)

## 从库延迟

 ![](image/Pasted%20image%2020220307222731.png)

 ## 并行复制

 ![](image/Pasted%20image%2020220307222803.png)

## 判断主备同步情况

![](image/Pasted%20image%2020220307222854.png)

## 主-主复制结构

![](image/Pasted%20image%2020220307222923.png)

