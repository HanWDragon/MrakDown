# 数据库动起来了，会发生什么

## 产生日志数据

![](image/Pasted%20image%2020220306001226.png)

## 客户端之间因为锁而相互影响

![](image/Pasted%20image%2020220306001506.png)

## 事务造成查询到的数据与磁盘上不一致

![](image/Pasted%20image%2020220306001820.png)

## 总结

![](image/Pasted%20image%2020220306001858.png)

# 什么日志不是给人看的

## MySQL日志体系

![](image/Pasted%20image%2020220306002056.png)

## binlog 归档日志

![](image/Pasted%20image%2020220306085802.png)

## undo log 回滚日志

![](image/Pasted%20image%2020220306090133.png)

## redo log

![](image/Pasted%20image%2020220306090343.png)

![](image/Pasted%20image%2020220306090721.png)

![](image/Pasted%20image%2020220306090429.png)

# 数据更新流程

![](image/Pasted%20image%2020220306091232.png)

## redo log 刷盘

![](image/Pasted%20image%2020220306091755.png)

## binlog 刷盘

![](image/Pasted%20image%2020220306091858.png)

## 持久化分析

![](image/Pasted%20image%2020220306092039.png)

## 为什么 redo log 在 binlog 之前

![](image/Pasted%20image%2020220306092348.png)

## 总结

所有不能撤销的操作，都要在 redo log 写入后执行操作。

![](image/Pasted%20image%2020220306092629.png)

# 锁：如何平衡功能与性能

![](image/Pasted%20image%2020220306092828.png)

## 全局锁

![](image/Pasted%20image%2020220306093108.png)

## 表锁（数据锁）

![](image/Pasted%20image%2020220306093240.png)

## 元数据锁（metadata lock）

![](image/Pasted%20image%2020220306093423.png)

  ## 行锁

![](image/Pasted%20image%2020220306093600.png)

![](image/Pasted%20image%2020220306093655.png)

## 数据更新流程

![](image/Pasted%20image%2020220306093857.png)

## 总结

![](image/Pasted%20image%2020220306094115.png)

# 事务：InnoDB的杀手锏

## 事务的特性

![](image/Pasted%20image%2020220306094448.png)

### 原子性（Atomicity）

![](image/Pasted%20image%2020220306094739.png)

### 一致性（Consistency）

![](image/Pasted%20image%2020220306094952.png)

### 隔离性（Isolation）

![](image/Pasted%20image%2020220306095217.png)

### 持久性（Durability）

![](image/Pasted%20image%2020220306095434.png)

## 知识图谱

![](image/Pasted%20image%2020220306095553.png)

## 隔离级别

![](image/Pasted%20image%2020220306095847.png)

### 读未提交（READ UNCOMMITTED）

![](image/Pasted%20image%2020220306121611.png)

```mysql
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
```

```mysql
SELECT
	*
FROM
	city
WHERE
	city = 'Xiangfan';
```

![](image/Pasted%20image%2020220306122859.png)

### 读提交（READ COMMITTED）

![](image/Pasted%20image%2020220306123146.png)

当一个客户端在这个表开启了事务，并且修改了数据，此时别的客户端想进行修改，就会进行阻塞，直到第一个修改的客户端完成了事务。

### 可重复读（REPEATABLE READ）

![](image/Pasted%20image%2020220306123840.png)

### 串行化（SERIALIZABLE）

![](image/Pasted%20image%2020220306124153.png)

## 总结

![](image/Pasted%20image%2020220306124259.png)

# MVCC是怎么做到千人千面的

## 行记录的版本控制

![](image/Pasted%20image%2020220306124801.png)

## 快照读（一致性非锁定读）

![](image/Pasted%20image%2020220306125013.png)

![](image/Pasted%20image%2020220306124857.png)

## 当前读（一致性锁定读）

![](image/Pasted%20image%2020220306125238.png)

![](image/Pasted%20image%2020220306124857.png)

# 隔离问题

![](image/Pasted%20image%2020220306125526.png)

## MySQL不同隔离级别的问题

在可重复读中，因为新插入的数据，没有历史版本，所以有幻读，但是MySQL通过锁解决了部分的幻读问题。

![](image/Pasted%20image%2020220306125622.png) 

## 如何解决幻读问题

![](image/Pasted%20image%2020220306130539.png)

![](image/Pasted%20image%2020220306130607.png)

![](image/Pasted%20image%2020220306130750.png)

## 总结

![](image/Pasted%20image%2020220306131015.png)

# 间隙表把全表锁住了，如何解决

## Next-Key Lock 的加锁逻辑

![](image/Pasted%20image%2020220306185336.png)

## 示例数据表

### 表结构

```mysql
CREATE TABLE t3 (
	id INT(11) NOT NULL,
	c INT(11) DEFAULT NULL,
	d INT(11) DEFAULT NULL,
	PRIMARY KEY (id),
	KEY c (c)
) ENGINE = INNODB;
```

### 数据

```mysql
INSERT INTO t3
		VALUES(0, 0, 0), (10, 10, 10), (20, 20, 20), (30, 30, 30), (50, 50, 50);
```

### 结构

![](image/Pasted%20image%2020220306185615.png)

## 等值查询间隙锁

![](image/Pasted%20image%2020220306191345.png)

![](image/Pasted%20image%2020220306191750.png)

注意这些都是在可重复读的隔离条件下进行（MySQL的默认隔离条件），上面执行的结果就是加锁逻辑的第四条，于是锁上了`(10,20)` 这个区间

## 非唯一索引等值锁

![](image/Pasted%20image%2020220306192407.png)

![](image/Pasted%20image%2020220306192551.png)

##  主键索引范围锁

![](image/Pasted%20image%2020220306194305.png)

![](image/Pasted%20image%2020220306194341.png)

## 非唯一索引范围锁

![](image/Pasted%20image%2020220306195414.png)

![](image/Pasted%20image%2020220306195535.png)

## 非索引字段查询

![](image/Pasted%20image%2020220306195809.png)

![](image/Pasted%20image%2020220306195850.png)

## 总结

![](image/Pasted%20image%2020220306200426.png)

# MYSQL也有“垃圾回收”

我们在业务开发中有时会遇到像Java和Go这些有GC的语言，因为垃圾回收突然停止处理业务逻辑，有时MySQL也有像这些语言一样的情况。

![](image/Pasted%20image%2020220306201320.png)

## MySQL脏页的产生

![](image/Pasted%20image%2020220306201905.png)

![](image/Pasted%20image%2020220306201752.png)

## 什么是刷脏页

![](image/Pasted%20image%2020220306202046.png)

![](image/Pasted%20image%2020220306202114.png)

## 为什么要刷脏页

![](image/Pasted%20image%2020220306202450.png)

## 如何避免被迫刷脏页

![](image/Pasted%20image%2020220306202556.png)

## 服务器IO配置

![](image/Pasted%20image%2020220306203007.png)

可以通过fio来测试IOPS

## 配置合理的脏页比例上限

![](image/Pasted%20image%2020220306204303.png)

## 控制顺便刷脏策略

![](image/Pasted%20image%2020220306204420.png)

## 总结

![](image/Pasted%20image%2020220306204445.png)

# 长事务的危害

## 主要危害：锁无法释放

![](image/Pasted%20image%2020220306213031.png)

### 行级锁长时间无法释放

![](image/Pasted%20image%2020220306213231.png)

### 解决方法

![](image/Pasted%20image%2020220306213416.png)

### 容易产生死锁

![](image/Pasted%20image%2020220306213509.png)

### 死锁是如何产生的

![](image/Pasted%20image%2020220306213618.png)

### 解决方法

![](image/Pasted%20image%2020220306213831.png)

**但是要注意，这个在事务很多的情况下十分影响性能，可能在一些高并发的场景下，查询缓慢，建议设置超时，而不是主动检测，尽量优化业务逻辑，避免长事务**

### MDL 锁（MetaDataLock / 元数据锁）

![](image/Pasted%20image%2020220306214453.png)

![](image/Pasted%20image%2020220306214522.png)

### 解决方法

![](image/Pasted%20image%2020220306215252.png)

## 如何查看影响性能的锁

![](image/Pasted%20image%2020220306215359.png)

## 如何查看影响性能的锁（8.0新增）

![](image/Pasted%20image%2020220306215459.png)

## 业务上的建议

在我们现在都在使用 ORM 框架，更是要注意这些锁和事务

![](image/Pasted%20image%2020220306215906.png)

## 总结

![](image/Pasted%20image%2020220306215933.png)

# 本章小结

## 动起来的数据库有哪些问题

![](image/Pasted%20image%2020220306220014.png)

## MySQL日志体系

![](image/Pasted%20image%2020220306220104.png)

 ## 数据更新流程

 ![](image/Pasted%20image%2020220306220204.png)

 ## MySQL的锁

 ![](image/Pasted%20image%2020220306220236.png)

 ## 事务和MVCC

  ![](image/Pasted%20image%2020220306220309.png)

## MySQL的刷新脏页策略

![](image/Pasted%20image%2020220306220450.png)

## 长事务有哪些危害

![](image/Pasted%20image%2020220306220513.png)

