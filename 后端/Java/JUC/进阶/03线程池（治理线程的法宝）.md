## 线程池的自我介绍

![](image/image-20220203140559504.png)

![](image/image-20220203140624424.png)

- 创建了一个线程

```java
package threadpool;

/**
 * 描述：     TODO
 */
public class EveryTaskOneThread {

    public static void main(String[] args) {
        Thread thread = new Thread(new Task());
        thread.start();
    }

    static class Task implements Runnable {

        @Override
        public void run() {
            System.out.println("执行了任务");
        }
    }

}
```

- 创建多个线程

```java
package threadpool;

import java.util.concurrent.Executors;

/**
 * 描述：     TODO
 */
public class ForLoop {

    public static void main(String[] args) {
        for (int i = 0; i < 1000; i++) {
            Thread thread = new Thread(new Task());
            thread.start();
        }
    }

    static class Task implements Runnable {

        @Override
        public void run() {
            System.out.println("执行了任务");
        }
    }

}
```

但是我们线程创建了许多线程，会给系统很大的压力

![](image/image-20220203141050195.png)

## 为什么要使用线程池

![](image/image-20220203141135907.png)

## 使用线程池的好处

![](image/image-20220203141230011.png)

## 线程池适合应用的场景

![image-20220203141341031](image/image-20220203141341031.png)

# 创建和停止线程池

![](image/image-20220203141436242.png)

## 线程池构造函数的参数

![](image/image-20220203141507568.png)

## 参数中的corePoolSize和maxpoolSize

![](image/image-20220203141721659.png)

## corePoolSize和maxpoolSize

![](image/image-20220203141806566.png)

## 添加线程规则

![](image/image-20220203141956910.png)

![](image/image-20220203142023492.png)

![](image/image-20220203142135376.png)

## 举个例子

![](image/image-20220203142224732.png)

## 增减线程的特点

![](image/image-20220203142429069.png)

## keepAliveTime

![](image/image-20220203142600629.png)

## ThreadFactory 用来创建线程

![](image/image-20220203142709569.png)

![](image/image-20220203142759294.png)

## 工作队列

![](image/image-20220203142925561.png)

## 线程池应该手动创建还是自动创建

![](image/image-20220203143019477.png)



```java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 描述：     演示newFixedThreadPool
 */
public class FixedThreadPoolTest {

    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(4);
        for (int i = 0; i < 1000; i++) {
            executorService.execute(new Task());
        }
    }
}

class Task implements Runnable {


    @Override
    public void run() {
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName());
    }
}
```

我们可以看到线程的名字始终都是那几个，所以这个也是线程池，我们看到源码

![](image/image-20220203143534414.png)

![](image/image-20220203143620273.png)

```java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 描述：     演示newFixedThreadPool出错的情况
 */
public class FixedThreadPoolOOM {

    private static ExecutorService executorService = Executors.newFixedThreadPool(1);
    public static void main(String[] args) {
        for (int i = 0; i < Integer.MAX_VALUE; i++) {
            executorService.execute(new SubThread());
        }
    }

}

class SubThread implements Runnable {


    @Override
    public void run() {
        try {
            Thread.sleep(1000000000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

```

![](image/image-20220203144151807.png)

```java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 描述：     TODO
 */
public class SingleThreadExecutor {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newSingleThreadExecutor();
        for (int i = 0; i < 1000; i++) {
            executorService.execute(new Task());
        }
    }
}

```

![](image/image-20220203144302051.png)

![](image/image-20220203145111487.png)

## CacheThreadPool

![](image/image-20220203144751771.png)

![](image/image-20220203144819535.png)

```java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 描述：     TODO
 */
public class CachedThreadPool {

    public static void main(String[] args) {
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i < 1000; i++) {
            executorService.execute(new Task());
        }
    }
}

```

![](image/image-20220203145705050.png)

## ScheduledThreadPool

![](image/image-20220203145650756.png)

```java
package threadpool;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * 描述：     TODO
 */
public class ScheduledThreadPoolTest {

    public static void main(String[] args) {
        ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(10);
//        threadPool.schedule(new Task(), 5, TimeUnit.SECONDS);
        threadPool.scheduleAtFixedRate(new Task(), 1, 3, TimeUnit.SECONDS);
    }
}

```

![](image/image-20220203145802070.png)

## 线程池里的线程数量设定为多少合适

![](image/image-20220203150005135.png)

## 停止线程池的正确方法

![](image/image-20220203152521700.png)

![](image/image-20220203152749231.png)



```java
package threadpool;

import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/**
 * 描述：     演示关闭线程池
 */
public class ShutDown {

    public static void main(String[] args) throws InterruptedException {
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        for (int i = 0; i < 100; i++) {
            executorService.execute(new ShutDownTask());
        }
        Thread.sleep(1500);
//        List<Runnable> runnableList = executorService.shutdownNow();

        executorService.shutdown();
        executorService.execute(new ShutDownTask());
//        boolean b = executorService.awaitTermination(7L, TimeUnit.SECONDS);
//        System.out.println(b);
//        System.out.println(executorService.isShutdown());
//        executorService.shutdown();
//        System.out.println(executorService.isShutdown());
//        System.out.println(executorService.isTerminated());
//        Thread.sleep(10000);
//        System.out.println(executorService.isTerminated());

//        executorService.execute(new ShutDownTask());
    }
}

class ShutDownTask implements Runnable {


    @Override
    public void run() {
        try {
            Thread.sleep(500);
            System.out.println(Thread.currentThread().getName());
        } catch (InterruptedException e) {
            System.out.println(Thread.currentThread().getName() + "被中断了");
        }
    }
}
```



# 常见线程池的特点和用法

![](image/image-20220203150142692.png)

![](image/image-20220203150214183.png)

![](image/image-20220203150233138.png)

![](image/image-20220203150414234.png)

![](image/image-20220203150428127.png)

![](image/image-20220203150456877.png)

![](image/image-20220203150659610.png)

![](image/image-20220203150717878.png)



## 以上四种线程池的构造函数的参数

![](image/image-20220203150933022.png)

## 阻塞队列分析

![](image/image-20220203151136133.png)

![](image/image-20220203151458099.png)

# 任务太多，怎么拒绝？

![](image/image-20220203153151174.png)

![](image/image-20220203153545818.png)

## 四种拒绝策略

![](image/image-20220203153722590.png)



# 钩子方法，给线程池加点料

![](image/image-20220203153916674.png)

```java
package threadpool;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.RejectedExecutionHandler;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 描述：     演示每个任务执行前后放钩子函数
 */
public class PauseableThreadPool extends ThreadPoolExecutor {

    private final ReentrantLock lock = new ReentrantLock();
    private Condition unpaused = lock.newCondition();
    private boolean isPaused;


    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime,
            TimeUnit unit,
            BlockingQueue<Runnable> workQueue) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
    }

    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime,
            TimeUnit unit, BlockingQueue<Runnable> workQueue,
            ThreadFactory threadFactory) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);
    }

    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime,
            TimeUnit unit, BlockingQueue<Runnable> workQueue,
            RejectedExecutionHandler handler) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, handler);
    }

    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime,
            TimeUnit unit, BlockingQueue<Runnable> workQueue,
            ThreadFactory threadFactory, RejectedExecutionHandler handler) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory,
                handler);
    }

    @Override
    protected void beforeExecute(Thread t, Runnable r) {
        super.beforeExecute(t, r);
        lock.lock();
        try {
            while (isPaused) {
                unpaused.await();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    private void pause() {
        lock.lock();
        try {
            isPaused = true;
        } finally {
            lock.unlock();
        }
    }

    public void resume() {
        lock.lock();
        try {
            isPaused = false;
            unpaused.signalAll();
        } finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        PauseableThreadPool pauseableThreadPool = new PauseableThreadPool(10, 20, 10l,
                TimeUnit.SECONDS, new LinkedBlockingQueue<>());
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println("我被执行");
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };
        for (int i = 0; i < 10000; i++) {
            pauseableThreadPool.execute(runnable);
        }
        Thread.sleep(1500);
        pauseableThreadPool.pause();
        System.out.println("线程池被暂停了");
        Thread.sleep(1500);
        pauseableThreadPool.resume();
        System.out.println("线程池被恢复了");

    }
}

```

# 实现原理、源码分析

![](image/image-20220203154647537.png)

![](image/image-20220203154733455.png)

## Executor家族

![](image/image-20220203154914565.png)

## 哪个是线程池

![](image/image-20220203155000680.png)

## 线程池实现任务复用的原理

![](image/image-20220203161302335.png)

## 线程池状态

![](image/image-20220203161635566.png)

# 使用线程池的注意点

![](image/image-20220203162120445.png)