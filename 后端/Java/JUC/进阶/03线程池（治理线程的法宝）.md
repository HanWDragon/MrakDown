## 线程池的自我介绍

<img src="image/image-20220203140559504.png" alt="image-20220203140559504" style="zoom:50%;" />

<img src="image/image-20220203140624424.png" alt="image-20220203140624424" style="zoom:50%;" />

- 创建了一个线程

```java
package threadpool;

/**
 * 描述：     TODO
 */
public class EveryTaskOneThread {

    public static void main(String[] args) {
        Thread thread = new Thread(new Task());
        thread.start();
    }

    static class Task implements Runnable {

        @Override
        public void run() {
            System.out.println("执行了任务");
        }
    }

}
```

- 创建多个线程

```java
package threadpool;

import java.util.concurrent.Executors;

/**
 * 描述：     TODO
 */
public class ForLoop {

    public static void main(String[] args) {
        for (int i = 0; i < 1000; i++) {
            Thread thread = new Thread(new Task());
            thread.start();
        }
    }

    static class Task implements Runnable {

        @Override
        public void run() {
            System.out.println("执行了任务");
        }
    }

}
```

但是我们线程创建了许多线程，会给系统很大的压力

<img src="image/image-20220203141050195.png" alt="image-20220203141050195" style="zoom:50%;" />

## 为什么要使用线程池

<img src="image/image-20220203141135907.png" alt="image-20220203141135907" style="zoom:50%;" />

## 使用线程池的好处

<img src="image/image-20220203141230011.png" alt="image-20220203141230011" style="zoom:50%;" />

## 线程池适合应用的场景

![image-20220203141341031](image/image-20220203141341031.png)

# 创建和停止线程池

<img src="image/image-20220203141436242.png" alt="image-20220203141436242" style="zoom:50%;" />

## 线程池构造函数的参数

<img src="image/image-20220203141507568.png" alt="image-20220203141507568" style="zoom:50%;" />

## 参数中的corePoolSize和maxpoolSize

<img src="image/image-20220203141721659.png" alt="image-20220203141721659" style="zoom:50%;" />

## corePoolSize和maxpoolSize

<img src="image/image-20220203141806566.png" alt="image-20220203141806566" style="zoom:50%;" />

## 添加线程规则

<img src="image/image-20220203141956910.png" alt="image-20220203141956910" style="zoom:50%;" />

<img src="image/image-20220203142023492.png" alt="image-20220203142023492" style="zoom:50%;" />

<img src="image/image-20220203142135376.png" alt="image-20220203142135376" style="zoom:50%;" />

## 举个例子

<img src="image/image-20220203142224732.png" alt="image-20220203142224732" style="zoom:50%;" />

## 增减线程的特点

<img src="image/image-20220203142429069.png" alt="image-20220203142429069" style="zoom:50%;" />

## keepAliveTime

<img src="image/image-20220203142600629.png" alt="image-20220203142600629" style="zoom:50%;" />

## ThreadFactory 用来创建线程

<img src="image/image-20220203142709569.png" alt="image-20220203142709569" style="zoom:50%;" />

<img src="image/image-20220203142759294.png" alt="image-20220203142759294" style="zoom:50%;" />

## 工作队列

<img src="image/image-20220203142925561.png" alt="image-20220203142925561" style="zoom:50%;" />

## 线程池应该手动创建还是自动创建

<img src="image/image-20220203143019477.png" alt="image-20220203143019477" style="zoom:50%;" />



```java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 描述：     演示newFixedThreadPool
 */
public class FixedThreadPoolTest {

    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(4);
        for (int i = 0; i < 1000; i++) {
            executorService.execute(new Task());
        }
    }
}

class Task implements Runnable {


    @Override
    public void run() {
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName());
    }
}
```

我们可以看到线程的名字始终都是那几个，所以这个也是线程池，我们看到源码

<img src="image/image-20220203143534414.png" alt="image-20220203143534414" style="zoom:50%;" />

<img src="image/image-20220203143620273.png" alt="image-20220203143620273" style="zoom:50%;" />

```java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 描述：     演示newFixedThreadPool出错的情况
 */
public class FixedThreadPoolOOM {

    private static ExecutorService executorService = Executors.newFixedThreadPool(1);
    public static void main(String[] args) {
        for (int i = 0; i < Integer.MAX_VALUE; i++) {
            executorService.execute(new SubThread());
        }
    }

}

class SubThread implements Runnable {


    @Override
    public void run() {
        try {
            Thread.sleep(1000000000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

```

<img src="image/image-20220203144151807.png" alt="image-20220203144151807" style="zoom:50%;" />

```java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 描述：     TODO
 */
public class SingleThreadExecutor {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newSingleThreadExecutor();
        for (int i = 0; i < 1000; i++) {
            executorService.execute(new Task());
        }
    }
}

```

<img src="image/image-20220203144302051.png" alt="image-20220203144302051" style="zoom:50%;" />

<img src="image/image-20220203145111487.png" alt="image-20220203145111487" style="zoom:50%;" />

## CacheThreadPool

<img src="image/image-20220203144751771.png" alt="image-20220203144751771" style="zoom:50%;" />

<img src="image/image-20220203144819535.png" alt="image-20220203144819535" style="zoom:50%;" />

```java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 描述：     TODO
 */
public class CachedThreadPool {

    public static void main(String[] args) {
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i < 1000; i++) {
            executorService.execute(new Task());
        }
    }
}

```

<img src="image/image-20220203145705050.png" alt="image-20220203145705050" style="zoom:50%;" />

## ScheduledThreadPool

<img src="image/image-20220203145650756.png" alt="image-20220203145650756" style="zoom:50%;" />

```java
package threadpool;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * 描述：     TODO
 */
public class ScheduledThreadPoolTest {

    public static void main(String[] args) {
        ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(10);
//        threadPool.schedule(new Task(), 5, TimeUnit.SECONDS);
        threadPool.scheduleAtFixedRate(new Task(), 1, 3, TimeUnit.SECONDS);
    }
}

```

<img src="image/image-20220203145802070.png" alt="image-20220203145802070" style="zoom:50%;" />

## 线程池里的线程数量设定为多少合适

<img src="image/image-20220203150005135.png" alt="image-20220203150005135" style="zoom:50%;" />

## 停止线程池的正确方法

<img src="image/image-20220203152521700.png" alt="image-20220203152521700" style="zoom:50%;" />

<img src="image/image-20220203152749231.png" alt="image-20220203152749231" style="zoom:50%;" />



```java
package threadpool;

import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/**
 * 描述：     演示关闭线程池
 */
public class ShutDown {

    public static void main(String[] args) throws InterruptedException {
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        for (int i = 0; i < 100; i++) {
            executorService.execute(new ShutDownTask());
        }
        Thread.sleep(1500);
//        List<Runnable> runnableList = executorService.shutdownNow();

        executorService.shutdown();
        executorService.execute(new ShutDownTask());
//        boolean b = executorService.awaitTermination(7L, TimeUnit.SECONDS);
//        System.out.println(b);
//        System.out.println(executorService.isShutdown());
//        executorService.shutdown();
//        System.out.println(executorService.isShutdown());
//        System.out.println(executorService.isTerminated());
//        Thread.sleep(10000);
//        System.out.println(executorService.isTerminated());

//        executorService.execute(new ShutDownTask());
    }
}

class ShutDownTask implements Runnable {


    @Override
    public void run() {
        try {
            Thread.sleep(500);
            System.out.println(Thread.currentThread().getName());
        } catch (InterruptedException e) {
            System.out.println(Thread.currentThread().getName() + "被中断了");
        }
    }
}
```



# 常见线程池的特点和用法

<img src="image/image-20220203150142692.png" alt="image-20220203150142692" style="zoom:50%;" />

<img src="image/image-20220203150214183.png" alt="image-20220203150214183" style="zoom:50%;" />

<img src="image/image-20220203150233138.png" alt="image-20220203150233138" style="zoom:50%;" />

<img src="image/image-20220203150414234.png" alt="image-20220203150414234" style="zoom:50%;" />

<img src="image/image-20220203150428127.png" alt="image-20220203150428127" style="zoom:50%;" />

<img src="image/image-20220203150456877.png" alt="image-20220203150456877" style="zoom:50%;" />

<img src="image/image-20220203150659610.png" alt="image-20220203150659610" style="zoom:50%;" />

<img src="image/image-20220203150717878.png" alt="image-20220203150717878" style="zoom:50%;" />



## 以上四种线程池的构造函数的参数

<img src="image/image-20220203150933022.png" alt="image-20220203150933022" style="zoom:50%;" />

## 阻塞队列分析

<img src="image/image-20220203151136133.png" alt="image-20220203151136133" style="zoom:50%;" />

<img src="image/image-20220203151458099.png" alt="image-20220203151458099" style="zoom:50%;" />

# 任务太多，怎么拒绝？

<img src="image/image-20220203153151174.png" alt="image-20220203153151174" style="zoom:50%;" />

<img src="image/image-20220203153545818.png" alt="image-20220203153545818" style="zoom:50%;" />

## 四种拒绝策略

<img src="image/image-20220203153722590.png" alt="image-20220203153722590" style="zoom:50%;" />



# 钩子方法，给线程池加点料

<img src="image/image-20220203153916674.png" alt="image-20220203153916674" style="zoom:50%;" />

```java
package threadpool;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.RejectedExecutionHandler;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 描述：     演示每个任务执行前后放钩子函数
 */
public class PauseableThreadPool extends ThreadPoolExecutor {

    private final ReentrantLock lock = new ReentrantLock();
    private Condition unpaused = lock.newCondition();
    private boolean isPaused;


    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime,
            TimeUnit unit,
            BlockingQueue<Runnable> workQueue) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
    }

    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime,
            TimeUnit unit, BlockingQueue<Runnable> workQueue,
            ThreadFactory threadFactory) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);
    }

    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime,
            TimeUnit unit, BlockingQueue<Runnable> workQueue,
            RejectedExecutionHandler handler) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, handler);
    }

    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime,
            TimeUnit unit, BlockingQueue<Runnable> workQueue,
            ThreadFactory threadFactory, RejectedExecutionHandler handler) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory,
                handler);
    }

    @Override
    protected void beforeExecute(Thread t, Runnable r) {
        super.beforeExecute(t, r);
        lock.lock();
        try {
            while (isPaused) {
                unpaused.await();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    private void pause() {
        lock.lock();
        try {
            isPaused = true;
        } finally {
            lock.unlock();
        }
    }

    public void resume() {
        lock.lock();
        try {
            isPaused = false;
            unpaused.signalAll();
        } finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        PauseableThreadPool pauseableThreadPool = new PauseableThreadPool(10, 20, 10l,
                TimeUnit.SECONDS, new LinkedBlockingQueue<>());
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println("我被执行");
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };
        for (int i = 0; i < 10000; i++) {
            pauseableThreadPool.execute(runnable);
        }
        Thread.sleep(1500);
        pauseableThreadPool.pause();
        System.out.println("线程池被暂停了");
        Thread.sleep(1500);
        pauseableThreadPool.resume();
        System.out.println("线程池被恢复了");

    }
}

```

# 实现原理、源码分析

<img src="image/image-20220203154647537.png" alt="image-20220203154647537" style="zoom:50%;" />

<img src="image/image-20220203154733455.png" alt="image-20220203154733455" style="zoom:50%;" />

## Executor家族

<img src="image/image-20220203154914565.png" alt="image-20220203154914565" style="zoom:50%;" />

## 哪个是线程池

<img src="image/image-20220203155000680.png" alt="image-20220203155000680" style="zoom:50%;" />

## 线程池实现任务复用的原理

<img src="image/image-20220203161302335.png" alt="image-20220203161302335" style="zoom:50%;" />

## 线程池状态

<img src="image/image-20220203161635566.png" alt="image-20220203161635566" style="zoom:50%;" />

# 使用线程池的注意点

<img src="image/image-20220203162120445.png" alt="image-20220203162120445" style="zoom:50%;" />