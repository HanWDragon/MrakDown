# 装饰者设计模式

## 星巴克咖啡订单项目

1. 咖啡种类/单品咖啡:Espresso(意大利浓咖啡)、ShortBlack、LongBlack(美式 咖啡)、Decaf(无因咖啡)
2. 调料:Milk、Soy(豆浆)、Chocolate
3. 要求在扩展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便
4. 使用OO的来计算不同种类咖啡的费用:客户可以点单品咖啡，也可以单品咖啡+调料组合。

### 方案1-较差的方案

### 方案1-问题分析

1. Drink 是一个抽象类，表示饮料
2. des就是对咖啡的描述, 比如咖啡的名字
3. cost()方法就是计算费用，Drink类中做成一个抽象方法.
4. Decaf 就是单品咖啡， 继承Drink, 并实现cost
5. Espress && Milk 就是单品咖啡+调料， 这个组合很多
6. 这样设计，会有很多类，当我们增加一个单品咖啡，或者一个新的调料，类的数量就会倍增，就会出现类爆炸

### 方案2-好些的方案

前面分析到方案1因为咖啡单品+调料 组合会造成类的倍增，因此可以做改 进，将调料内置到Drink类，这样就不 会造成类数量过多。从而提高项目 的维护性(如图):



说明: milk  soy  chocolate 可以设计为 Boolean,表示是否要添加相应的调料

### 方案2-问题分析

1. 方案2可以控制类的数量，不至于造成很多的类
2. 在增加或者删除调料种类时，代码的维护量很大
3. 考虑到用户可以添加多份调料时，可以将hasMilk返回一个对应int
4. 考虑使用装饰者模式

## 装饰者模式

**定义**

1. 装饰者模式:动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更 有弹性，装饰者模式也体现了开闭原则(ocp)
2. 这里提到的动态的将新功能附加到对象和ocp原则，在后面的应用实例上会以代码的形式体现，注意体会

### 装饰者模式(Decorator)原理

1. 装饰者模式就像打包一个快递

	主体:比如:陶瓷、衣服 (Component) // 被装饰者

	包装:比如:报纸填充、塑料泡沫、纸板、木板(Decorator)

2. Component

	主体:比如类似前面的Drink

3. ConcreteComponent和Decorator ConcreteComponent:具体的主体， 比如前面的各个单品咖啡
	 Decorator: 装饰者，比如各调料
	 
4. 在如图的Component与ConcreteComponent之间，如果 ConcreteComponent类很多,还可以设计一个缓冲层，将共有的部分提取出来， 抽象层一个类。

### 用装饰者模式设计的方案

说明

1. Drink 类就是前面说的抽象类， Component
2. ShortBlack 就单品咖啡
3. Decorator 是一个装饰类，含有一个被装饰的对象(Drink obj)
4. Decorator 的cost 方法 进行一个费用的叠加计算，递归的计算价格

### 装饰者模式解决星巴克咖啡订单

**2份巧克力+一份牛奶的LongBlack**

**说明:**

1. **Milk包含了LongBlack**
2. **一份Chocolate包含了(Milk+LongBlack)**
3. **一份Chocolate包含了(Chocolate+Milk+LongBlack)**
4. **这样不管是什么形式的单品咖啡+调料组合，通过递归方式可以方便的组合和维护**

### 装饰者模式咖啡订单项目应用实例

**代码示例:**

```java

```

## 装饰者模式在JDK应用的源码分析

Java的IO结构，FilterInputStream就是一个装饰者

