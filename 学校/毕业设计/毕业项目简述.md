### 为什么要写这个项目

1. 提高自己的代码水平
2. 高并发项目可以作为自己简历上的项目经历
3. 优秀毕设

### 了解并设计12306

#### 12306 有多忙碌

- 2020年高峰期，一天的请求大概在1600亿，平均180万/秒
	- 根据28理论，于是我们推测高峰期的请求大概是700万每秒，现实来看只会比理论更少
	- 因为12306一天存在很多的放票点，将大量的请求大致均匀的分开了，估算高峰期为300万QPS
- 平均一年平均售出30亿张，高峰期日售票能力达到2000万张
	- 一个数据库表每天能产生2万条数据都是少数
- 高峰期1秒可卖出1300张票 
	- 1300TPS一秒卖光一列火车
	- 淘宝双11：58万笔/秒

#### 如何解决忙碌问题

##### 提高处理能力：QPS和TPS

- 堆积硬件
- 自研软件：Gemfire是一个分布式内存数据库
	- 当时12306将4TB的数据放入了内存当中，主要来解决余票查询慢的问题
	- 将查询速度从15秒降低到了0.2秒
- 算法：模型+逻辑

##### 削峰 + 填谷

- 业务：验证码、分时段、排队
- 技术：限流、异步

#### 核心功能

![](image/Pasted%20image%2020230904092941.png)

#### 功能模块划分

- 在实际项目中热点接口会做成单独的模块
- 通过功能模块划分为不同的模块分配不同的资源

- 网关模块
	- 路由转发、登录校验
- 会员模块
	- 会员、乘客、已购买的车票
- 业务模块
	- 所有的车次数据，余票信息
- 跑批模块
	- 管理定时任务、界面启停
- web模块
	- 会员相关界面
- admin模块
	- 管理员相关界面

#### 整体系统架构设计

![](image/Pasted%20image%2020230904094507.png)

#### 系统数据库表设计

##### 会员模块

![](image/Pasted%20image%2020230904095514.png)

##### 业务模块

- 前面的车站表-座位表都是基本信息，每张票都需要这些基础信息
- 后面的每日余票表，其实冗余了车次表，这样方便查询，查询一次就可以得到余票信息了

![](image/Pasted%20image%2020230904101021.png)
##### 其他

![](image/Pasted%20image%2020230904101051.png)


### 仿12306的核心问题和解决方案

- 业务复杂度高于商城，考验功底
- 持续高并发设计，更需要持续的高并发设计

- 动态库存
	- 像是购物平台中商品都是提前补货完成，当开始售卖时是不可以修改商品数量的，逻辑简单
	- 但是购票时动态库存 eg：上海 -> 南京 -> 北京 这段路中可以只卖出一张上海到北京一张票，也可以卖出两张票 上海到南京和南京到北京 两张票，由不同人购买
	- 也就是卖出去一张又可以卖出去一张，每卖出一张票都会对剩余库存造成影响

- 选座功能
	- 方便了用户，但是编程难度却上升了一个级别

-  线上线下都有售卖平台

-  不停的刷票以及等退票

- 绝不能超卖

#### 如何保证不超卖，不少卖，还能抽手高并发

##### 模型设计&逻辑实现

- 座位选择和余票查询在操作的过程中要加事务保证完整性

- 余票查询：记录站与站之间的余票
	- 每卖一张票影响的是，**没卖过票有交集的区间**，这和购票区间和座次号都有关
	- 不能简单的认为就涉及到的区间票-1，这样会导致少卖
	- 假设一列火车有5个站，可拆分为 4+3+2+1=10 条站站记录

![](image/Pasted%20image%2020230903213428.png)

- 座位选择：记录座位销售情况
	- 一个火车有5个站 A～E，1号座位1010，代表1号座位只有BC和DE端可以买
	- 将卖票变为2进制的计算

![](image/Pasted%20image%2020230903214210.png)

#### 百万人抢1万张票，系统如何保证其正常及稳定性

- 持续秒杀高并发技术
##### 前端

- 针对静态资源做CDN
- 页面静态化
- 倒计时&Loading，用户操作后给出提示
- 使用验证码削峰
##### 后端

- 微服务-服务拆分
	- 一般是按功能模块来划分，热点接口也可以做成单独的服务
	- 负载均衡
	- 限流降级
	- 缓存
		- 本地缓存
		- 分布式缓存
		- 需要注意穿透，击穿，雪崩
	- 令牌
	- 异步处理

##### 数据库

- 分库：业务分库，读写分离
	- 将不同业务的表放在不同的数据库里，相互隔离
- 分表：横向分表，纵向分表
	- 横向分表：一般按地区或时间划分
	- 纵向分表：将一张表变成多个表，eg：文章表一：标题、作者、时间，文章表二：内容
- 冗余设计，反范式，空间换时间
- 分布式数据库
##### 其他

- 分时段秒杀
- 弹性扩容
	- 自动扩容有时候反应比较慢，不适合突发的大流量请求，所以可以在秒杀之前，提前扩容好，在秒杀之后，它可以自动回收，节约成本
- 候补+排队
### 高并发场景有哪些

- 商品秒杀，购物平台促销
	- 并发高，业务相对简单
	- 下单，库存-1，处理支付，不要超卖
- 微信支付宝，支付平台
- 微博突发热点
- 用户操作日志
- 12306购票平台
#### 常见的问题

- 秒杀还没开始，页面崩溃
	- CDN
- 秒杀刚开始服务器崩溃
- 秒杀结束，库存超卖
- 秒杀过程没有问题，但是相应很慢
	- 异步削峰 + 排队
- 服务器良好，缓存崩溃
	- 缓存穿透
	- 缓存击穿
	- 缓存雪崩

### 对应技术

#### 后端

- SpringCloud
- SpringBoot
#### 前端

- VUE
### 优势

- 分布式架构设计
- 高性能，高并发，高可用
- 技术新

### 大致步骤

1. 架构搭建，使用前后端分离架构
2. 功能开发，实现基本的选座排队购票功能（自制代码生成器，用于单表的增删改查）
3. 引入高并发技术，实现高并发抢票
	1. 限流 + 令牌 可以消除很多无效的请求
	2. 使用异步化 + 排队 进行削峰处理
	3. 使用分布式锁，让车票不超卖
### 项目收获

- 学习主流前后端分离架构，Spring Cloud Alibaba + VUE 3
	- 了解网关、注册中心、配置中心、限流降级、服务调用、分布式事务等微服务架构中常用的组件
- 熟悉高并发技术：缓存、分布式锁、限流、令牌、削峰、排队等
- 提升自己的技术能力广度和深度

#### 相关技术名称

- CDN
- 分布式缓存
- 两层验证码
- 限流技术
- 令牌技术
- 分布式锁
- 异步削峰
- 排队机制
- 分布式事务

### 项目的主要框架版本

- JDK 17
- SpringBoot3
- SpringCloud Alibaba 2020.0.0.0
- 第三方适配问题

### 为什么选择最新版本

- Spring作为Java的风险标，代表Java领域最时髦的技术
	- AOT
- SpringBoot 3 必须使用 JDK17+
- 学习要激进（了解趋势），项目要滞后（稳定）

#### 更新之后的新特性

###### JDK9

- 模块化开发
	- 使用module-info.java来声明一个模块，一个模块只能有一个文件，且在顶层包同目录下
	- 使用exports来声明可以被外部引用的包，可以有多个exports语句
	- 使用requires来声明可以被外部依赖的包，可以有多个requires语句
###### JDK10

- var局部变量推导
	- 必须能推导出实际类型
	- 只能用于局部变量

###### JDK11

- 单文件程序
- shebang脚本
	- `#!`这个符号叫shebang，shell脚本的开头
	- 音译为释伴，即解释伴随行
	- `#!/bin/bash`以此开头的程序，在执行时便会调用bash程序来执行
	- 使用`java --source 11`使得java命令可以执行非.java的文件

###### JDK14

- 文本块
	- 多行字符串：json、html、sql等
- instanceof增强

###### JDK16

- record类

###### JDK17

- sealed类
	- 类的继承很难管理，使用sealed类来显式管理
	- 继承父类后，尽量不要重写父类的方法，重写还得去理解原方法的逻辑，写出来不一定对
	- 父类如果是sealed类，则必须至少有个子类
	- sealed类的子类，必须是final、sealed、non-sealed之一
- switch增强（预览）

###### SpringBoot3-AOT和JIT介绍

- AOT和JIT
	- JIT(Just-in-Time，实时编译)Java跨平台的基础
	- AOT(Ahead-of-Time,预编译或提前编译)无法跨平台

- AOT的优点
	- 启动和运行的速度快
	- 传统SpringBoot空项目启动就需要2秒，AOT的启动大概是100毫秒
	- 打包体积小
	- 云原生，为云服务
- AOT的缺点
	- 编译后不支持跨平台
	- 不支持动态功能，如AOP
- JIT在高并发场景出现生产问题
	- 热点应用重启后，出现业务超时，几分钟后恢复正常
	- 解决方法
	- 预热：初始让程序自动运行热点代码几百次
	- 流量控制：启动时小流量，几分钟过后再放到正常流量

### 开发中遇到的问题

- column是mysql关键字，用关键字做列号正常使用mybatis没问题，会添加反引号''，但使用分布式事务还是会出问题，所以微服务项目不要使用关键字。
- 后端购票逻辑，分为选座和不选座
	- 不选座，以购买一等座为例：遍历一等座车厢，每个城厢从1号座位开始找，未被购买的，就选中它
	- 选座，以购买两张一等座AB为例：遍历一等座车厢，每个车厢从1号座位开始找A列座位，未被购买的，就预选中它；在选旁边的B，如果也未被购买，最终选中，如果B被购买，则回到第一步，继续找到未被购买的A座
	- 从方便的角度来说，只需要计算座位的偏移值，可以减少循环，提高选座效率
- 要注意站序要从0开始，座位号要从1开始